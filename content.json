{"pages":[],"posts":[{"title":" CodeForces 484 B. Maximum Value\t\t","text":"题目链接 题目翻译：给定序列$a_n$，求$a_i \\% a_j$的最大值，$1 \\leq i,j \\leq n$且$a_i&gt;a_j$。 可以先将输入的数据由小到大排序，如果有相同的数据就去重，然后枚举除数，对于一个除数，从它的二倍开始，直到它大于数列中的最大值。 。。。好不通顺。。。看代码吧。 #include&lt;bits/stdc++.h&gt; using namespace std; bool cmp(const int&amp; a,const int&amp; b){ return a&gt;b; } struct Solution{ int n,ans,maxn,q; vector&lt;int&gt; a; void Solve(){ scanf(&quot;%d&quot;,&amp;n); a.resize(n); for(int i=0;i&lt;n;i++){ scanf(&quot;%d&quot;,&amp;a[i]); maxn=max(maxn,a[i]); } sort(a.begin(),a.end()); n=unique(a.begin(),a.end())-a.begin(); a.resize(n); for(int i=0;i&lt;n;i++){ int k=2*a[i]; while(k&lt;maxn+a[i]){ int x=lower_bound(a.begin(),a.end(),k)-a.begin()-1; if(x==-1){ k+=a[i]; continue; } //printf(&quot;k=%d a[%d]=%d a[x] mod a[i]=%d\\n&quot;,k,x,a[x],a[x]%a[i]); ans=max(ans,a[x]%a[i]); k+=a[i]; } } printf(&quot;%d\\n&quot;,ans); } }; int main(){ Solution().Solve(); return 0; }","link":"/2019/06/06/codeforces-484-b-maximum-value/"},{"title":" 你好，初次见面。\t\t","text":"按说这篇文章应该是第一篇，但是前几天因为博客搬过来点东西，耽搁了时间。 你好，朋友，我是吴越洋，虽然不知道你是谁，但是你来了，就是我们之间的缘分。 我第一次知道OI，是我初三上学期的时候，初中同学ssk带我入门了Python，那可能算是我第一次接触了真正的计算机，也从他的口中得知了OI。 那时，刚学习Python，还在简单的输入输出上徘徊，经常因为一个非常简单的字典问题思考数个小时，那时已经听说有人学OI了，我想或许我也可以尝试一下，但快中考了，所以也只是想想罢了。 不知不觉，中考已经结束了，我也如愿考上了想去的高中，虽然分数不是很高，但也算是圆了我初中的目标了吧。中考完，就开始疯玩了，也不知道什么时候看到一篇文章，上面写道一些关于信息学竞赛的故事，于是便想要学学试试。不久领完录取通知书后，正值七月中旬，学校让学竞赛，我考虑了一下，最后选择了OI。没想到碰到了asdfczf，于是就拉上他一起学了OI，成为了OIer。 暑假的竞赛班选拔一共持续了20天左右的时间，有四次考试，其间遇到了另外一位同学，qwerdkr，当时并没有想到他会成为和我们并肩学习的唯一的同学。最终，我们通过了最后的面试，进入了G1801班。 开学之后，我们认识了1702班的lzk，1703的njl，1602的hhm，mzy，znt，zhl，wxz，还有几个外校的神仙dky，yrt，ACCEPT，和小学同学jdx等OIers。再来看我们这一届，虽然比上一届学的人还少，但是每个人都在努力，我相信会有很大的收获。 不知道NOIp2019会有一个什么样的结果，可能能拿到省一？亦或什么也没有。但即使这样，我也不会后悔，因为它已经教给了我足够多的东西，我不会忘记。 差不多了，文笔很差，甚至有些逻辑不通，多多包涵。最后， 初次见面，请多关照。:bowtie:","link":"/2019/03/10/e4-bd-a0-e5-a5-bd-ef-bc-8c-e5-88-9d-e6-ac-a1-e8-a7-81-e9-9d-a2-e3-80-82/"},{"title":" 图论——Tarjan算法求lca\t\t","text":"Tarjan算法 tarjan算法本质是使用并查集对“向上标记法”的一种优化。它是一个离线算法。理论时间复杂度为$O(n+m)$。 在dfs当中，树中的节点一共可以分为3类： 已经访问完毕并且回溯的节点。在这些节点标记2。 已经开始递归，但是尚未回溯的节点。这些节点就是当前正在访问的节点$x$以及$x$的祖先。在这些节点标记1。 尚未访问的节点。不标记。 对于正在访问的节点$x$，它到根节点的路径以及标记为1。若$y$是以及访问完回溯的节点，那么$lca(x,y)$就是从y节点向上走，直到遇到第一个标记为1的节点。 可以使用并查集对此进行优化，即每次回溯时，把它所在的集合合并到它父亲所在的集合当中，这样，$lca(x,y)$只需查询$get(y)$，就等价于从y向上找到第一个标记为1的节点。 每当dfs回溯时，扫描有关x的所有讯问，若y的标记为2，则$lca(x,y)$就是$get(y)$。 代码如下：#include&lt;bits/stdc++.h&gt; using namespace std; const int SIZE=500009; struct Edge{ int to,next; }e[SIZE*2]; int deep[SIZE],fa[SIZE],tot,head[SIZE],tag[SIZE],lca[SIZE]; int n,m,s; vector&lt;int&gt; ask[SIZE],ask_id[SIZE]; void add(int x,int y){ e[++tot].to=y; e[tot].next=head[x]; head[x]=tot; } int get(int x){ return x==fa[x]?x:fa[x]=get(fa[x]); } void tarjan(int x){ tag[x]=1; for(int i=head[x];i;i=e[i].next){ int y=e[i].to; if(tag[y]) continue; deep[y]=deep[x]+1; tarjan(y); fa[y]=x; } for(int i=0;i&lt;ask[x].size();i++){ if(tag[ask[x][i]]==2){ lca[ask_id[x][i]]=get(ask[x][i]); } } tag[x]=2; } int main(){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; for(int i=1;i&lt;=n;i++) fa[i]=i; for(int i=1;i&lt;n;i++){ int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y),add(y,x); } for(int i=1;i&lt;=m;i++){ int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); ask[x].push_back(y); ask[y].push_back(x); ask_id[x].push_back(i); ask_id[y].push_back(i); } tarjan(s); for(int i=1;i&lt;=m;i++){ printf(&quot;%d\\n&quot;,lca[i]); } return 0; }","link":"/2019/03/11/e5-9b-be-e8-ae-ba-tarjan-e7-ae-97-e6-b3-95-e6-b1-82lca/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/07/11/hello-world/"},{"title":"test","text":"test如今看来飞机洒到了lsdkjfs $\\sum^a_av\\le $ dsklfjsdlkjfldskjflaskfjsdlfjsdklfjdsklfjdskljfsdkljsdkleuwiruwoirw |dfd|dfds| |:|:| 1 3 12#include&lt;iostream&gt;#include&lt;cstdio&gt;","link":"/2019/07/11/test/"}],"tags":[{"name":"精","slug":"精","link":"/tags/精/"},{"name":"LCA","slug":"LCA","link":"/tags/LCA/"},{"name":"图论","slug":"图论","link":"/tags/图论/"}],"categories":[{"name":"OI","slug":"OI","link":"/categories/OI/"},{"name":"随笔","slug":"随笔","link":"/categories/随笔/"},{"name":"题目","slug":"OI/题目","link":"/categories/OI/题目/"}]}