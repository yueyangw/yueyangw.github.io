{"pages":[{"title":"about","text":"我是吴越洋，现就读于山西省实验中学，最弱OIer。 联系方式： 手机：18636850163 邮箱：[yueyang_wu@outlook.com](mailto:yueyang_wu@outlook.com) GitHub：[yueyangw](https://github.com/yueyangw) QQ：1393073734 luogu：[118087](https://www.luogu.org/space/show?uid=118087) 实用工具： [算法可视化](https://visualgo.net/zh) [数列大全](https://oeis.org/) [OI Wiki](https://oi-wiki.org/) [在线IDE（600+语言）](https://tio.run/) [$L^AT_EX$数学公式参考](http://www.mohu.org/info/symbols/symbols.htm) [图论画板](https://csacademy.com/app/graph_editor/) [在线剪贴板](https://paste.ubuntu.com/) [gdb调试技巧](https://github.com/hellogcc/100-gdb-tips) [c++语法查询](https://zh.cppreference.com/w/)","link":"/about/index.html"},{"title":"testtt","text":"欢迎您加入山西省实验中学。这里是山西省实验中学的blog。本文遵循cc协议，转载请标注原文链接及作者。信息竞赛全部通过。明天正常上课以下是第一次竞赛选拔通过名单：（请通过的学生明天按照之前课表准时上课）数学：![数学](/img/数学.jpg) 物理：![物理](/img/物理.jpg) 化学：![化学](/img/化学.jpg) 生物：![生物](/img/生物.jpg) 明天按照课表继续上课。","link":"/testtt/index.html"}],"posts":[{"title":"Luogu P2279 [HNOI2003]消防局的设立","text":"[题目链接](https://www.luogu.org/problem/P2279) 设计状态：$f[x][0-4]$表示以x为根节点的子树，能覆盖到向上2到-2个节点需要的最小消防局数量，这样明显$f[x][0]\\leq f[x][1]\\leq f[x][2] \\leq f[x][3] \\leq f[x][4]$所以转移的时候尽量选第二维大的转移，能保证最小： $f[x][0] = \\sum f[y][4]+1$ 如果能延伸到x的祖父节点，那么x必须为消防局，所以答案是x的所有儿子向下2个，及x所有孙子的儿子都能被覆盖即可，因为x为消防局，所以数量加一。$$f[x][1] = min\\{\\sum_{s\\in t且s \\not= k} f[s][3]+f[k][0]\\}$$ 延伸到x的父亲，只需要保证所有的孙子已经被覆盖，并且其中一个儿子可以向上延伸2个，这就意味着所有的x的儿子和x本身还有x的父亲都可以被这个消防局覆盖。 $f[x][2]$同理 $f[x][3] = \\sum f[y][2]$ 能保证x的儿子们都被覆盖，相当于儿子们自己都被覆盖。 $f[x][4] = \\sum f[y][3]$ 同理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;int n;struct Edge{ int to, nxt;}e[2009];int head[1009], tot;int f[1009][5];void add(int x, int y){ e[++tot].to = y; e[tot].nxt = head[x]; head[x] = tot;}void dfs(int x, int fa){ for(int i = head[x]; i; i = e[i].nxt){ int y = e[i].to; if(y == fa) continue; dfs(y, x); f[x][0] += f[y][4]; f[x][3] += f[y][2]; f[x][4] += f[y][3]; } f[x][0] += 1; f[x][1] = f[x][2] = 0x3f3f3f3f; for(int i = head[x]; i; i = e[i].nxt){ int y = e[i].to; if(y == fa) continue; f[x][1] = min(f[x][1], f[x][4] - f[y][3] + f[y][0]); f[x][2] = min(f[x][2], f[x][3] - f[y][2] + f[y][1]); } f[x][1] = min(f[x][1], f[x][0]); f[x][2] = min(f[x][2], f[x][1]); f[x][3] = min(f[x][3], f[x][2]); f[x][4] = min(f[x][4], f[x][3]);}int main(){ scanf(\"%d\", &amp;n); for(int i = 2; i &lt;= n; i++){ int y; scanf(\"%d\", &amp;y); add(i, y), add(y, i); } dfs(1, 0); printf(\"%d\\n\", f[1][2]); return 0;}","link":"/2019/07/29/P2279-消防局的设立/"},{"title":" 图论——Tarjan算法求lca\t\t","text":"Tarjan算法 **tarjan算法本质是使用并查集对“向上标记法”的一种优化。它是一个离线算法。理论时间复杂度为$O(n+m)$。** **在dfs当中，树中的节点一共可以分为3类：** 已经访问完毕并且回溯的节点。在这些节点标记2。 已经开始递归，但是尚未回溯的节点。这些节点就是当前正在访问的节点$x$以及$x$的祖先。在这些节点标记1。 尚未访问的节点。不标记。 对于正在访问的节点$x$，它到根节点的路径以及标记为1。若$y$是以及访问完回溯的节点，那么$lca(x,y)$就是从y节点向上走，直到遇到第一个标记为1的节点。 可以使用并查集对此进行优化，即每次回溯时，把它所在的集合合并到它父亲所在的集合当中，这样，$lca(x,y)$只需查询$get(y)$，就等价于从y向上找到第一个标记为1的节点。 每当dfs回溯时，扫描有关x的所有讯问，若y的标记为2，则$lca(x,y)$就是$get(y)$。 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;const int SIZE=500009;struct Edge{ int to,next;}e[SIZE*2];int deep[SIZE],fa[SIZE],tot,head[SIZE],tag[SIZE],lca[SIZE];int n,m,s;vector&lt;int&gt; ask[SIZE],ask_id[SIZE];void add(int x,int y){ e[++tot].to=y; e[tot].next=head[x]; head[x]=tot;}int get(int x){ return x==fa[x]?x:fa[x]=get(fa[x]);}void tarjan(int x){ tag[x]=1; for(int i=head[x];i;i=e[i].next){ int y=e[i].to; if(tag[y]) continue; deep[y]=deep[x]+1; tarjan(y); fa[y]=x; } for(int i=0;i&lt;ask[x].size();i++){ if(tag[ask[x][i]]==2){ lca[ask_id[x][i]]=get(ask[x][i]); } } tag[x]=2;}int main(){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; for(int i=1;i&lt;=n;i++) fa[i]=i; for(int i=1;i&lt;n;i++){ int x,y; scanf(\"%d%d\",&amp;x,&amp;y); add(x,y),add(y,x); } for(int i=1;i&lt;=m;i++){ int x,y; scanf(\"%d%d\",&amp;x,&amp;y); ask[x].push_back(y); ask[y].push_back(x); ask_id[x].push_back(i); ask_id[y].push_back(i); } tarjan(s); for(int i=1;i&lt;=m;i++){ printf(\"%d\\n\",lca[i]); } return 0;}","link":"/2019/03/11/e5-9b-be-e8-ae-ba-tarjan-e7-ae-97-e6-b3-95-e6-b1-82lca/"},{"title":" 你好，初次见面。\t\t","text":"你好 按说这篇文章应该是第一篇，但是前几天因为博客搬过来点东西，耽搁了时间。 你好，朋友，我是吴越洋，虽然不知道你是谁，但是你来了，就是我们之间的缘分。 我第一次知道OI，是我初三上学期的时候，初中同学ssk带我入门了Python，那可能算是我第一次接触了真正的计算机，也从他的口中得知了OI。 那时，刚学习Python，还在简单的输入输出上徘徊，经常因为一个非常简单的字典问题思考数个小时，那时已经听说有人学OI了，我想或许我也可以尝试一下，但快中考了，所以也只是想想罢了。 不知不觉，中考已经结束了，我也如愿考上了想去的高中，虽然分数不是很高，但也算是圆了我初中的目标了吧。中考完，就开始疯玩了，也不知道什么时候看到一篇文章，上面写道一些关于信息学竞赛的故事，于是便想要学学试试。不久领完录取通知书后，正值七月中旬，学校让学竞赛，我考虑了一下，最后选择了OI。没想到碰到了asdfczf，于是就拉上他一起学了OI，成为了OIer。 暑假的竞赛班选拔一共持续了20天左右的时间，有四次考试，其间遇到了另外一位同学，qwerdkr，当时并没有想到他会成为和我们并肩学习的唯一的同学。最终，我们通过了最后的面试，进入了G1801班。 开学之后，我们认识了1702班的lzk，1703的njl，1602的hhm，mzy，znt，zhl，wxz，还有几个外校的神仙dky，yrt，ACCEPT，和小学同学jdx等OIers。再来看我们这一届，虽然比上一届学的人还少，但是每个人都在努力，我相信会有很大的收获。 不知道NOIp2019会有一个什么样的结果，可能能拿到省一？亦或什么也没有。但即使这样，我也不会后悔，因为它已经教给了我足够多的东西，我不会忘记。 差不多了，文笔很差，甚至有些逻辑不通，多多包涵。最后， 初次见面，请多关照。:bowtie:","link":"/2019/03/10/e4-bd-a0-e5-a5-bd-ef-bc-8c-e5-88-9d-e6-ac-a1-e8-a7-81-e9-9d-a2-e3-80-82/"},{"title":" 最短路算法——SPFA\t\t","text":"emmmm。。。我不得不承认。。。学OI这么长时间，并不会写SPFA。。。 好吧。。直接上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,s,dis[10009];bool flag,vis[10009];int cnt[10009];//环 struct Edge{ int to,nxt,w;}e[500009];int head[10009],tot;void add(int x,int y,int w){ e[++tot].to=y; e[tot].nxt=head[x]; e[tot].w=w; head[x]=tot;}void spfa(int st){ queue&lt;int&gt; q; q.push(st); dis[st]=0; while(!q.empty()){ int x=q.front(); q.pop(); vis[x]=1; for(int i=head[x];i;i=e[i].nxt){ int y=e[i].to; if(dis[y]&gt;dis[x]+e[i].w){ dis[y]=dis[x]+e[i].w; cnt[y]++; if(cnt[y]&gt;n){ flag=1; return; }//判环 if(!vis[y]){ q.push(y); vis[y]=1; } } } vis[x]=0; }}int main(){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; for(int i=1;i&lt;=m;i++){ int x,y,w; cin&gt;&gt;x&gt;&gt;y&gt;&gt;w; add(x,y,w); } memset(dis,0x3f,sizeof(dis)); spfa(s); for(int i=1;i&lt;=n;i++){ if(dis[i]==0x3f3f3f3f) cout&lt;&lt;2147483647&lt;&lt;\" \"; else cout&lt;&lt;dis[i]&lt;&lt;\" \"; } return 0;}","link":"/2019/05/15/e6-9c-80-e7-9f-ad-e8-b7-af-e7-ae-97-e6-b3-95-spfa/"},{"title":" 无向图的双连通分量\t\t","text":"双连通分量又分点双连通分量和边双连通分量两种。若一个无向图中的去掉任意一个节点(一条边)都不会改变此图的连通性，即不存在割点(桥)，则称作点(边)双连通图。一个无向图中的每一个极大点(边)双连通子图称作此无向图的点(边)双连通分量。——来自360百科 边双联通分量（e-DCC）的求法计算e-DCC只需要把原无向图中所有的桥删去后，会分成若干连通块，每一个连通块都是一个边双联通分量。 一般可以先使用Tarjan求出所有桥，再执行一次dfs，划分出每个连通块。 c\\[x\\]代表x点所处的边连通分量编号。 e-DCC的缩点把每个e-DCC看做一个节点，把桥看做连接$c\\[x\\]$和$c\\[y\\]$的无向边，产生一棵树。 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188 #include&lt;bits/stdc++.h&gt; using namespace std; const int SIZE=100009; struct Edge{ int to,next; }e[SIZE*2],ec[SIZE*2]; int head[SIZE],dfn[SIZE],low[SIZE],num,tot,dcc,c[SIZE]; int headc[SIZE],totc; bool bridge[SIZE]; int n,m; void add(int x,int y){ e[++tot].to=y; e[tot].next=head[x]; head[x]=tot; } void add_c(int x,int y){ ec[++totc].to=y; ec[totc].next=head[x]; headc[x]=totc; } void tarjan(int x,int in_edge){ dfn[x]=low[x]=++num; for(int i=head[x];i;i=e[i].next){ int y=e[i].to; if(!dfn[y]){ tarjan(y,i); low[x]=min(low[x],low[y]); if(dfn[x]&lt;low[y]) bridge[i]=bridge[i^1]=1; } else if(i!=(in_edge^1)){ low[x]=min(low[x],dfn[y]); } } } void dfs(int x){ c[x]=dcc; for(int i=head[x];i;i=e[i].next){ int y=e[i].to; if(c[y]||bridge[i]) continue; dfs(y); } } int main(){ cin&gt;&gt;n&gt;&gt;m; tot=1; for(int i=1;i&lt;=m;i++){ int x,y; cin&gt;&gt;x&gt;&gt;y; add(x,y),add(y,x); } for(int i=1;i&lt;=n;i++){ if(!dfn[i]) tarjan(i,0); } cout&lt;&lt;\"桥：\"&lt;&lt;endl; for(int i=2;i&lt;tot;i+=2){ if(bridge[i]) cout&lt;&lt;e[i].to&lt;&lt;\" \"&lt;&lt;e[i^1].to&lt;&lt;endl; } for(int i=1;i&lt;=n;i++){ if(!c[i]) dcc++,dfs(i); } for(int i=1;i&lt;=n;i++){ printf(\"%d属于第%d个dcc\\n\",i,c[i]); } //缩点 totc=1; for(int i=2;i&lt;=tot;i++){ int x=e[i^1].to,y=e[i].to; if(c[x]==c[y]) continue; add_c(c[x],c[y]); } printf(\"缩点后共%d个节点，%d条边\\n\",dcc,totc/2); for(int i=2;i&lt;totc;i+=2){ cout&lt;&lt;ec[i^1].to&lt;&lt;\" \"&lt;&lt;ec[i].to&lt;&lt;endl; } return 0; } ``` * * *#### 点双连通分量（v-DCC）的求法求出v-DCC，需要维护一个栈，按照如下方法维护栈： 1. 当一个节点被访问时，将它压入栈。 2. 当判定条件$dfn\\[x\\]\\\\leq low\\[y\\]$成立时，无论x是否为根，都需要： 1. 从栈顶不断弹出点，直至y被弹出。 2. 弹出的所有节点与x构成一个v-DCC。 $vector dcc\\[i\\]$表示第$i$个v-DCC的所有节点#### v-DCC的缩点设图中有n个v-DCC,m个割点，这样缩点后形成一张n+m的树。把每个割点与和它相邻的v-DCC相连接。#### 代码如下```cpp #include&lt;bits/stdc++.h&gt; using namespace std; const int SIZE=100010; struct Edge{ int to,next; }e[SIZE*2]; int head[SIZE],dfn[SIZE],low[SIZE],strck[SIZE],num,tot,sta,cnt; int n,m,root; bool cut[SIZE]; vector&lt;int&gt; dcc[SIZE]; Edge ec[SIZE*2]; int headc[SIZE],totc,tree_id[SIZE]; void add(int x,int y){ e[++tot].to=y; e[tot].next=head[x]; head[x]=tot; } void add_c(int x,int y){ ec[++totc].to=y; ec[totc].next=headc[x]; headc[x]=totc; } void tarjan(int x){ strck[++sta]=x; dfn[x]=low[x]=++num; int flag=0; for(int i=head[x];i;i=e[i].next){ int y=e[i].to; if(!dfn[y]){ tarjan(y); low[x]=min(low[x],low[y]); if(dfn[x]&lt;=low[y]){ flag++; if(x!=root||flag&gt;1) cut[x]=1; int z; cnt++; do{ z=strck[sta--]; dcc[cnt].push_back(z); }while(z!=y); dcc[cnt].push_back(x); } } else low[x]=min(low[x],dfn[y]); } } int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++){ int x,y; cin&gt;&gt;x&gt;&gt;y; add(x,y),add(y,x); } for(int i=1;i&lt;=n;i++){ if(!dfn[i]) root=i,tarjan(i); } printf(\"有%d个DCC\\n\",cnt); for(int i=1;i&lt;=cnt;i++){ printf(\"v-DCC #%d:\",i); //cout&lt;&lt;dcc[i].size(); for(int j=0;j&lt;dcc[i].size();j++){ printf(\"%d \",dcc[i][j]); } cout&lt;&lt;endl; } int treec=cnt; for(int i=1;i&lt;=n;i++){ if(cut[i]) tree_id[i]=++treec; } totc=1; for(int i=1;i&lt;=cnt;i++){ for(int j=0;j&lt;dcc[i].size();j++){ if(!cut[dcc[i][j]]) continue; add_c(i,tree_id[dcc[i][j]]); add_c(tree_id[dcc[i][j]],i); } } printf(\"缩点后共有%d个点，%d条边\\n\",treec,totc/2); printf(\"编号在[1,%d]的为原图v-DCC,编号大于%d的为原图割点。\\n\",cnt,cnt); for(int i=2;i&lt;totc;i+=2){ printf(\"%d %d\\n\",ec[i^1].to,ec[i].to); } return 0; }","link":"/2019/03/13/e6-97-a0-e5-90-91-e5-9b-be-e7-9a-84-e5-8f-8c-e8-bf-9e-e9-80-9a-e5-88-86-e9-87-8f/"},{"title":"CodeForces 484 B. Maximum Value","text":"[题目链接](http://codeforces.com/problemset/problem/484/B “题目链接”) 题目翻译：给定序列$a\\_n$，求$a\\_i \\\\% a\\_j$的最大值，$1 \\\\leq i,j \\\\leq n$且$a\\_i&gt;a_j$。 可以先将输入的数据由小到大排序，如果有相同的数据就去重，然后枚举除数，对于一个除数，从它的二倍开始，直到它大于数列中的最大值。 。。。好不通顺。。。看代码吧。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;bool cmp(const int&amp; a,const int&amp; b){ return a&gt;b;}struct Solution{ int n,ans,maxn,q; vector&lt;int&gt; a; void Solve(){ scanf(\"%d\",&amp;n); a.resize(n); for(int i=0;i&lt;n;i++){ scanf(\"%d\",&amp;a[i]); maxn=max(maxn,a[i]); } sort(a.begin(),a.end()); n=unique(a.begin(),a.end())-a.begin(); a.resize(n); for(int i=0;i&lt;n;i++){ int k=2*a[i]; while(k&lt;maxn+a[i]){ int x=lower_bound(a.begin(),a.end(),k)-a.begin()-1; if(x==-1){ k+=a[i]; continue; } //printf(\"k=%d a[%d]=%d a[x] mod a[i]=%d\\n\",k,x,a[x],a[x]%a[i]); ans=max(ans,a[x]%a[i]); k+=a[i]; } } printf(\"%d\\n\",ans); }};int main(){ Solution().Solve(); return 0;}","link":"/2019/06/06/codeforces-484-b-maximum-value/"},{"title":"AtCoder Beginner Contest 135","text":"[AtCoder Beginner Contest 135](https://atcoder.jp/contests/abc135) 这应该是我第一次打Atcoder，写个blog留纪念。 A - Harmony 就是求是否有一个数，在数轴上距离a，b相等，直接代码。123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll a, b;int main(){ scanf(\"%lld%lld\", &amp;a, &amp;b); if(abs(a - b) % 2 == 1){ printf(\"IMPOSSIBLE\\n\"); return 0; } printf(\"%lld\\n\", (a + b) / 2); return 0;} B - 0 or 1 Swap 把数列读进来，排个序，和原来的对比一下就行了。12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;int a[59], b[59], n;int main(){ scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; i++){ scanf(\"%d\", &amp;a[i]); b[i] = a[i]; } int ans = 0; sort(a + 1, a + n + 1); for(int i = 1; i &lt;= n; i++){ if(a[i] != b[i]){ ans++; } } if(ans &lt;= 2) printf(\"YES\\n\"); else printf(\"NO\\n\"); return 0;} C - City Savers 额，这道题一开始我错了一次，但是我也不知道哪错了。。。好像是贪心没考虑清楚？我一开始枚举的下面那个数组，后来改成上面的就A了。貌似是因为得优先把上一个剩下的用完？123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n;ll a[100009], b[100009];ll ans;int main(){ scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n + 1; i++){ scanf(\"%lld\", &amp;a[i]); } for(int i = 1; i &lt;= n; i++){ scanf(\"%lld\", &amp;b[i]); } for(int i = 1; i &lt;= n + 1; i++){ if(b[i - 1] &gt; 0 &amp;&amp; a[i] &gt; 0){ int k = min(a[i], b[i - 1]); ans += k; a[i] -= k; b[i - 1] -= k; } if(b[i] &gt; 0 &amp;&amp; a[i] &gt; 0){ int k = min(a[i], b[i]); ans += k; a[i] -= k; b[i] -= k; } } printf(\"%lld\\n\", ans); return 0;} D - Digits Parade 这个是个dp，还是竹神提醒了一下状态，感觉以前做过这样的题，应该是一个类型的。 $f(i,j)$表示前i个组成的数模13余j的种类数，然后就可以转移，当第i个是一个确定的数时，可以直接枚举上一个位置的余数，然后因为到这位以后相当于上一位乘了10，所以上一位的余数*10再模13再加这一位再模13就是要转移的对象，同理如果这一位是一个问号，只需要枚举这一位是从0到9的情况即可。具体不太清楚的看代码。12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll mod = 1e9 + 7;string s;int n, a[100009];ll f[100009][20];int main(){ cin &gt;&gt; s; n = s.length(); for(int i = 1; i &lt;= n; i++){ a[i] = (s[i - 1] == '?' ? -1 : s[i - 1] - '0'); } if(a[1] == -1) for(int i = 0; i &lt;= 9; i++) f[1][i] = 1; else f[1][a[1]] = 1; for(int i = 2; i &lt;= n; i++){ if(a[i] == -1){ for(int j = 0; j &lt;= 9; j++){ for(int k = 0; k &lt;= 12; k++){ (f[i][(((k*10)%13)+j)%13] += f[i - 1][k] % mod) %= mod; } } } else{ for(int j = 0; j &lt;= 12; j++){ (f[i][(((j*10)%13)+a[i])%13] += f[i - 1][j] % mod) %= mod; } } } printf(\"%lld\\n\", f[n][5] % mod); return 0;}","link":"/2019/07/27/atcoder-abc135/"},{"title":" 清北学堂noip2018集训D3\t\t","text":"高精度算法 大数的存储 思路大概就是把数以字符串的形式读入，然后将它们一位一位倒叙存进一个整形数组。 高精度加法 把每一位相加，若有进位就将下一位加一。 高精度乘法 与高精度加法类似。 示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;string s1,s2;int input(string &amp;s,int a[],int &amp;len){ cin&gt;&gt;s; len=s.length(); for(int i=0;i&lt;len;i++){ a[i]=s[len-i-1]-'0'; } return len;}int plus_(int a[],int b[],int lena,int lenb,int c[]){//O(n) int lenc=0; while(lenc&lt;lena||lenc&lt;lenb){ c[lenc]=a[lenc]+b[lenc]; if(c[lenc]&gt;=10){ c[lenc]-=10; c[lenc+1]++; } lenc++; } if(c[lenc]==0){ lenc--; } return lenc;}int time_(int a[],int b[],int lena,int lenb,int c[]){//O(n^2) int lenc; for(int i=0;i&lt;lenb;i++){ for(int j=0;j&lt;lena;j++){ c[i+j]+=a[j]*b[i]; lenc=i+j; } } lenc+=20; for(int i=0;i&lt;2000;i++){ c[i+1]+=c[i]/10; c[i]%=10; } while(c[lenc]==0){ lenc--; } return lenc;}int main(){ int a[2000],lena,b[2000],lenb,c[2000],lenc; memset(a,0,sizeof(a)); memset(b,0,sizeof(a)); memset(c,0,sizeof(a)); input(s1,a,lena); input(s2,b,lenb); lenc=time_(a,b,lena,lenb,c); for(int i=lenc;i&gt;=0;i--){ cout&lt;&lt;c[i]; } cout&lt;&lt;endl; memset(c,0,sizeof(c)); lenc=plus_(a,b,lena,lenb,c); for(int i=lenc;i&gt;=0;i--){ cout&lt;&lt;c[i]; }} 快速幂 $a^bmodc;a,b,c\\\\le 10^9$ 代码见Day1 进制转换 从10进制转其他进制 代码： 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;char s[100];int tot;int main(){ int a[20000]; int b=121; int tobase=2; cin&gt;&gt;b&gt;&gt;tobase; while(b&gt;0){ a[tot++]=b%tobase; b/=tobase; } for(int i=tot-1;i&gt;=0;i--){ printf(\"%d\",a[i]); } return 0;} 从其它进制转10进制 代码： 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;char s[100];int main(){ int base; cin&gt;&gt;base; scanf(\"%s\",s); int x=1; int num=0; int l=strlen(s); for(int i=l-1;i&gt;=0;i--){ int a = s[i]-'0'; if(a&gt;=base){ cout&lt;&lt;\"Error!\"; return 0; } num += a*x; x *= base; } cout&lt;&lt;num; return 0;} 素数 大于一且因数只有1和它本身。 算数基本定理 任何一个大于1的自然数 N,如果N不为质数，那么N可以唯一分解成有限个质数的乘积$N=P\\_1^{a\\_1}\\\\times P\\_2^{a\\_2}\\\\times P\\_3^{a\\_3}\\\\times ……\\\\times P\\_n^{a\\_n}$，这里$P\\_1&lt;P\\_2&lt;P\\_3……&lt;P\\_n$均为质数，其中指数$a_i$是正整数。 判断一个数是不是素数 一般算法 `cpp #include&lt;bits/stdc++.h&gt; using namespace std; bool is_prime(int x){ for(int i=2;i*i&lt;=x;i++){ if(x%i==0) return 0; } return 1; } int main(){ int n; cin&gt;&gt;n; cout&lt;&lt;is_prime(i); return 0; }` $O(nloglogn)$算法 `cpp #include&lt;bits/stdc++.h&gt; using namespace std; bool a[100000005]; int x[100000005]; int find_prime(int n){ int tot=0; for(int i=2;i&lt;=n;i++){ if(!a[i]){ x[tot++]=i; for(int j=2;j*i&lt;=n;j++){ a[j*i]=1; } } } return tot; } int main(){ int len=find_prime(100000); for(int i=0;i&lt;len;i++){ cout&lt;&lt;x[i]&lt;&lt;” “; } return 0; }` gcd/lcm gcd:最大公约数 lcm:最小公倍数 $(a,b)\\[a,b\\]=ab$ gcd $gcd(a,b)=p\\_1^{min(a\\_1,b\\_1)}\\\\times p\\_2^{min(a\\_2,b\\_2)}\\\\times …\\\\times p\\_n^{min(a\\_n,b_n)}$ 怎么算？ 辗转相减 $gcd(a,b) = gcd(b,a-b)$ 辗转相除法 $gcd(a,b) = gcd(b,a\\\\%b)$ 代码如下： `cpp int gcd(int a,int b){ if(b==0) return a; return gcd(b,a%b); }` lcm $lcm(a,b)=p\\_1^{max(a\\_1,b\\_1)}\\\\times p\\_2^{max(a\\_2,b\\_2)}\\\\times …\\\\times p\\_n^{max(a\\_n,b_n)}$ 代码如下： `cpp int lcm(int a,int b){ return a*b/gcd(a,b); }` 示例代码1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;int gcd(int a,int b){ if(b==0) return a; return gcd(b,a%b);}int lcm(int a,int b){ return a*b/gcd(a,b);}int main(){ cout&lt;&lt;gcd(3,4)&lt;&lt;endl; cout&lt;&lt;lcm(3,4); return 0;} 裴蜀定理 $gcd(a,b)=d\\\\Rightarrow ax+by=d$ $gcd(a,b)=1\\\\Leftarrow\\\\Rightarrow ax+by=1$","link":"/2019/03/09/e6-b8-85-e5-8c-97-e5-ad-a6-e5-a0-82noip2018-e9-9b-86-e8-ae-add3/"},{"title":" 清北学堂noip2019-DP图论-Day1\t\t","text":"上午都是些概念啥的。。。 [![从沙雕题看dp](https://yueyangwu.cn/wp-content/uploads/2019/04/dp.png “从沙雕题看dp”)](https://yueyangwu.cn/wp-content/uploads/2019/04/dp.png “从沙雕题看dp”) 下午。。。回文问题 Q1:给定一个数列，求一个最长的回文子序列。 f\\[i\\]\\[j\\]:A\\[i ~ j\\]的最长回文子序列 12345678910for (int i = 0; i &lt; n; i++) f[i][i] = 1;for (int step = 2; step &lt;= n; step++) { for (int i = 0; i + step - 1 &lt; n; i++) { int j = i + step - 1; f[i][j] = max(f[i + 1][j], f[i][j - 1]); if (A[i] == A[j]) f[i][j] = max(f[i][j], f[i + 1][j - 1] + 2); }} Q2:给定一个数列，求回文子序列的个数 f\\[i\\]\\[j\\]:A\\[i ~ j\\]的回文子序列个数 用了个容斥原理emmmmmmmm 12345678910for (int i = 0; i &lt; n; i++) f[i][i] = 1;for (int step = 2; step &lt;= n; step++) { for (int i = 0; i + step - 1 &lt; n; i++) { int j = i + step - 1; f[i][j] = f[i][j - 1] + f[i + 1][j] - f[i + 1][j - 1]; if (A[i] == A[j]) f[i][j] += f[i + 1][j - 1] + 1; }} 乌龟棋[![1](http://yueyangwu.cn/wp-content/uploads/2019/04/图片1.png “1”)](http://yueyangwu.cn/wp-content/uploads/2019/04/图片1.png “1”) [![2](http://yueyangwu.cn/wp-content/uploads/2019/04/图片2.png “2”)](http://yueyangwu.cn/wp-content/uploads/2019/04/图片2.png “2”) 先使用一般的思路，可否使用下标作为状态？ 不行，因此使用每个类型卡牌的数量作为状态，定义$f[a][b][c][d]$为用a张1卡牌，b张2卡牌，c张3卡牌，d张4卡牌所得到的最高分数。这样可以判断当前位置$r=a+2\\\\times b+3\\\\times c+4\\\\times d$，再使用$w\\[i\\]$表示每个点的权值，即可得到状态转移方程： $f\\[a\\]\\[b\\]\\[c\\]\\[d\\]=max(f\\[a\\]\\[b\\]\\[c\\]\\[d\\],f\\[a-1\\]\\[b\\]\\[c\\]\\[d\\]+w\\[r\\])$ $f\\[a\\]\\[b\\]\\[c\\]\\[d\\]=max(f\\[a\\]\\[b\\]\\[c\\]\\[d\\],f\\[a\\]\\[b-1\\]\\[c\\]\\[d\\]+w\\[r\\])$ $f[a][b][c][d]=max(f[a][b][c][d],f[a][b][c-1][d]+w[r])$ $f[a][b][c][d]=max(f[a][b][c][d],f[a][b][c][d-1]+w[r])$ 最终答案即为$f[n][m][l][k]$,其中$n,m,l,k$分别为第$1,2,3,4$类型卡牌的张数。 NlogN的sd题。。。[![sdt](http://yueyangwu.cn/wp-content/uploads/2019/04/QQ截图20190429074813.png “sdt”)](http://yueyangwu.cn/wp-content/uploads/2019/04/QQ截图20190429074813.png “sdt”) 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std; int i,j,n,s,t,a[100001];int main(){ cin&gt;&gt;n; a[0]=-1000000; for(i=0;i&lt;n;i++) { cin&gt;&gt;t; if(t&gt;a[s]) a[++s]=t; else { int l=1,h=s,m; while(l&lt;=h) { m=(l+h)/2; if(t&gt;a[m]) l=m+1; else h=m-1; } a[l]=t; } } cout&lt;&lt;s&lt;&lt;endl;} sd题的nlogn告诉我们：有时候善用贪心规则可以优化 DP 的时间复杂度！ [![片段1](http://yueyangwu.cn/wp-content/uploads/2019/04/图片3.png “片段1”)](http://yueyangwu.cn/wp-content/uploads/2019/04/图片3.png “片段1”) [![片段2](http://yueyangwu.cn/wp-content/uploads/2019/04/图片4.png “片段2”)](http://yueyangwu.cn/wp-content/uploads/2019/04/图片4.png “片段2”) 通过分析该题目可知，本质上是求一个最长抖动序列。。。类似lca这样的算法，$O(n^2)$只能码70分，满分算法需要$O(nlogn)$ 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;int a[1000009],f[1000009][2],n;int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; } f[1][0]=f[1][1]=1; for(int i=2;i&lt;=n;i++){ if(a[i]&gt;a[i-1]) f[i][0]=f[i-1][1]+1; if(a[i]&lt;a[i-1]) f[i][1]=f[i-1][0]+1; if(a[i]&lt;=a[i-1]) f[i][0]=f[i-1][0]; if(a[i]&gt;=a[i-1]) f[i][1]=f[i-1][1]; } cout&lt;&lt;max(f[n][0],f[n][1]); return 0;}","link":"/2019/04/30/e6-b8-85-e5-8c-97-e5-ad-a6-e5-a0-82noip2019-dp-e5-9b-be-e8-ae-ba-day1/"},{"title":" 清北学堂noip2019-DP图论-Day2树形DP\t\t","text":"清北学堂noip2019-DP图论-Day2树形DP 简单入门题——没有上司的舞会一棵树，每个点有权值，一个点和其儿子 / 父亲不能同时取，求解从树上选取点能获得的最大权值。 \\- 树形 DP 中的覆盖问题，同时是一个子树转移问题（当前树的最优解由子树的最优解得到） 对于这类问题，我们应该维护每个子树的最优解 并关注子树到根的转移方式 $dp\\[i\\]\\[0\\]$ 表示我们不选择 $i$ 节点时子树的最大值 $dp\\[i\\]\\[1\\]$ 表示我们选择 $i$ 节点时子树的最大值 转移方程，对于每个节点 $i$ 的所有子节点 $dp\\[i\\]\\[0\\] += max(dp\\[j\\]\\[0\\], dp\\[j\\]\\[1\\])$ $dp\\[i\\]\\[1\\] += dp\\[j\\]\\[0\\]$12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int n,f[6009][2],value[6009],root;bool vis[6009];vector&lt;int&gt; son[6009];void dp(int u){ f[u][0]=0; f[u][1]=value[u]; for(int i=0;i&lt;son[u].size();i++){ int y=son[u][i]; dp(y); f[u][0]+=max(f[y][0],f[y][1]); f[u][1]+=f[y][0]; }}int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;value[i]; } while(1){ int x,y; cin&gt;&gt;x&gt;&gt;y; if(x==y&amp;&amp;x==0) break; vis[x]=1; son[y].push_back(x); } for(int i=1;i&lt;=n;i++){ if(vis[i]==0){ root=i; break; } } dp(root); cout&lt;&lt;max(f[root][0],f[root][1]); return 0;} Codeforce——767C Garland给定一个树，树有点权 要求你把树的某些边删去，使得树变成三个部分 每个部分的点权值和都相等 ![题目](http://yueyangwu.cn/wp-content/uploads/2019/04/图片1-1.png “题目”) \\- 思路：可以想到，一旦能够找到一颗子树和为$w_总/3$就把它和它的父节点断开，即可。 - 原因：因为如果两颗子树的和各是总和的三分之一，那么它们一定不会有交集。 HDU 3586给定一颗无向带权树，要切断所有叶子节点和根节点的联系，每次切断的费用不能超过上限 Limit，问在保证 总费用 &lt;=m 的情况下最小的 Limit - 二分+树形DP - dp\\[u\\]表示u子树中上限为limit时符合条件的最小总费用。 那么可以这样设计转移： 123456if(dis(u,v)&gt;limit){ dp[u]+=dp[v];}else{ dp[u]+=min(dp[u],dis(u,v));} Luogu P2458——保安站岗设计状态$dp\\[i\\]\\[0/1/2\\]$， - $dp\\[i\\]\\[0\\]$表示靠父节点的控制 - $dp\\[i\\]\\[1\\]$表示靠自己的控制 - $dp\\[i\\]\\[2\\]$表示靠子节点的控制 这样即可推得状态转移方程： - $dp\\[u\\]\\[0\\]=\\\\sum min(dp\\[v\\]\\[1\\],dp\\[v\\]\\[2\\])$ - $dp\\[u\\]\\[1\\]=\\\\sum min(dp\\[v\\]\\[0\\],dp\\[v\\]\\[1\\],dp\\[v\\]\\[2\\])+val\\[u\\]$ - $dp\\[u\\]\\[2\\]=\\\\sum min(dp\\[v\\]\\[1\\],dp\\[v\\]\\[2\\])+某一个dp\\[v\\]\\[2\\]$(这个比较麻烦。。。) 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; son[1509];int n,v[1509],dp[1509][3];void f(int x,int fa){ dp[x][0]=dp[x][1]=0; for(int i=0;i&lt;son[x].size();i++){ int y=son[x][i]; if(y==fa) continue; f(y,x); dp[x][0]+=min(dp[y][1],dp[y][2]); dp[x][1]+=min(min(dp[y][0],dp[y][1]),dp[y][2]); } dp[x][1]+=v[x];dp[x][2]=0x3f3f3f3f; for(int i=0;i&lt;son[x].size();i++){ int y=son[x][i]; if(y==fa) continue; dp[x][2]=min(dp[x][2],dp[x][0]-min(dp[y][1],dp[y][2])+dp[y][1]); }}int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ int x,m; cin&gt;&gt;x; cin&gt;&gt;v[x]; cin&gt;&gt;m; for(int i=1;i&lt;=m;i++){ int y; cin&gt;&gt;y; son[x].push_back(y); son[y].push_back(x); } } f(1,-1); cout&lt;&lt;min(dp[1][1],dp[1][2]); return 0;} 树上dp的链问题有一类树上 DP 的问题，求的是树上的满足条件的“最优链” 经典问题：HDU 2196 给定一棵有边权的树，输出树中与其距离最远的点的距离值 - 显然，从一个节点x出发到达的点只有两种情况： 1. 在x的子树中。 2. 在x的子树外。 显然第一种十分好维护，令 f\\[i\\] 表示以 i 为起点的，到 i 的子树内距离最远是多少 则 $f\\[i\\] = max(f\\[j\\] + dist(i,j))$ 那么第二种如何维护？我们令 $g\\[i\\]$ 表示 i 为起点到 i 的子树外距离最远是多少 第二种情况需要再做一次分类 一类是经过它的父亲，到父亲外，即 $g\\[i\\]$ &lt;- $g\\[fa\\[i\\]\\]$ 另一类是经过它的父亲，到了它的兄弟子树中","link":"/2019/04/30/e6-b8-85-e5-8c-97-e5-ad-a6-e5-a0-82noip2019-dp-e5-9b-be-e8-ae-ba-day2-e6-a0-91-e5-bd-a2dp/"},{"title":" 清北学堂noip2019-DP图论-Day2背包\t\t","text":"A.M. 背包和数位DP背包问题01背包 注意： 虽然一维空间的 0-1 背包不但省空间而且好写，但这并不意味着你可以忘记 0-1 背包二维的写法，有些题目其实会用到，而且输出方案的时候需要保持数组两维 0-1 背包问题有两种：第一种是输出容量不超过 V 的最大收益，而第二种则是输出容量恰好为 V 的最大收益，两者的预处理并不相同 Q：如何计算背包的方案总数与最优方案总数？ 方案总数for(int i=1;i&lt;=n;i++){ for(int j=0;j&lt;=m;j++){ f[i][j]=f[i-1][j]; if(j-v[i]&gt;=0) f[i][j]+=f[i-1][j-v[i]]; } }最优方案总数$f\\[i\\]\\[j\\]$是一个正常01背包，$g\\[i\\]\\[j\\]$表示前i个物品选择j体积的物品的最优方案总数。 for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= V; j++) { f[i][j] = f[i - 1][j]; if (j &gt;= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]); } for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= V; j++) { g[i][j] = g[i - 1][j]; if (j &gt;= v[i] &amp;&amp; f[i][j] == f[i - 1][j - v[i]] + w[i]) g[i][j] += g[i - 1][j - v[i]]; }例题——Luogu P1489 Q1：问一共 n 个人分成两队拔河，要求在保证两队人数的差的绝对值不超过1的情况下，输出两队体重差的绝对值的最小值。 这题看起来和背包没啥关系，但是仔细思考，可以发现$f\\[i\\]\\[j\\]\\[k\\]$表示前i个人里选j个可否组成k，这样问题就变成了01背包变形，第一维可以省去。 #include&lt;bits/stdc++.h&gt;using namespace std; int n,a[209],sum;bool f[209][80009]; int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; sum+=a[i]; } f[0][0]=1; for(int i=1;i&lt;=n;i++){ for(int j=n/2;j&gt;=1;j--){ for(int k=sum;k&gt;=a[i];k--){ if(f[j][k]||f[j-1][k-a[i]]) f[j][k]=1; } } } int ans1,ans2; for(int i=sum/2;i&gt;=0;i--){ if(f[n/2][i]) {ans1=i;break;} } ans2=sum-ans1; if(ans1&gt;ans2) swap(ans1,ans2); cout&lt;&lt;ans1&lt;&lt;&quot; &quot;&lt;&lt;ans2; return 0;} 完全背包 和01背包没啥区别，一个贪心预处理优化： 对于所有 Vi≥Vj，Ci≤Cj 的物品 i，都可以完全扔掉。 对于体积相同的物品只需要留下价值最大的物品。 对于随机数据，该优化力度很大。 多重背包多重背包问题，即每样物品 i ，有自己的体积 Vi，价值 Ci，和数量 Ti，数量并不是无限的，求最大价值 - 思路1：直接把其当做01背包，写出代码。 for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ for(int k=1;k&lt;=t[i];k++){ if(j-k*w[i]&gt;=0) f[j]=max(f[j],f[j-k*v[i]]+k*w[i]); } } }但很明显，这样做复杂度很高。 \\- 思路2：我们注意到我们只关心最终答案是几，而不关心我放进几个物品，所以当$T\\_i=3$时，我们可以不必放入3个$(V\\_i,W\\_i)$，而可以放入一个$(V\\_i,W\\_i)$和一个$(2V\\_i,2W\\_i)$，这样仍然可以枚举出放入3个的情况。因此，我们把每个$T\\_i$都分解为2的幂次，复杂度可以降到$O(n^2logn)$。 for(int i=1;i&lt;=n;i++){ int tt=t[i]; for(int k=1;k&lt;=tt;k&lt;&lt;=1){ for(int j=v;j&gt;=k*w[i];j--){ f[j]=max(f[j],f[j-k*w[i]]+k*v[i]); tt-=k; } } if(tt&gt;0){ for(int j=v;j&gt;=tt*w[i];j--){ f[j]=max(f[j],f[j-tt*w[i]]+tt*v[i]); } } } 分组背包每一个物品隶属于一个组，每个组里的物品是互斥的，意味着你在一组物品中只能选择一个物品。 for (int i = 1; i &lt;= K; i++) //一共有 K 组 for (int j = V; j &gt;= 0; j--) for (对于第 i 组内的物品k) dp[j] = max(dp[j], dp[j - v[k]] + w[k])","link":"/2019/05/01/e6-b8-85-e5-8c-97-e5-ad-a6-e5-a0-82noip2019-dp-e5-9b-be-e8-ae-ba-day2-e8-83-8c-e5-8c-85/"},{"title":" 清北学堂noip2019集训D5——动态规划\t\t","text":"动态规划 ==== 动态规划难点 意识到这个题用动态规划解决 高效设计状态 多做题 最长上升子序列问题 **题目：** （） 设计状态： $f\\[i\\]$表示以$a\\[i\\]$结尾的最长上升子序列长度。 最终答案$max_1\\\\leq i \\\\leq n$ 如何转移？ for(int i=1;i&lt;=n;i++){ f[i]=1; for(int j=1;j&lt;i;j++){ if(a[i]&lt;a[j]) f[i]=max(f[i],1+f[j]); }} 时间复杂度$O(n^2)$ 如何优化？ 方法一：树状数组优化 假设$a_i$互不相同。 离散化：$a\\_1,a\\_2,…,a_n$是一个${1,2,…,n}$的排列 DP值$f\\[i\\]$插入数组的$a_i$位置（这里树状数组用于求前缀max） 离散化？ //a[i]互不相同时int a[N];int a2[N];int ord[N];int cmp(int i,int j){ return a[i]&lt;a[j];}void lsh(){ for(int i=0;i&lt;=n;i++){ ord[i]=i; } sort(ord+1,ord+n+1,cmp); for(int i=1;i&lt;=n;i++){ a2[ord[i]]=a[i]; }} 时间复杂度$O(nlogn)$。 方法二：”单调栈” 令$g\\[j\\]$表示目前为止，长度为j的上升子序列的末尾元素最小是多少。 $a\\[1…5\\]={1,5,2,4,3}$ $g\\[1\\]=inf$ 插入1，$g\\[1\\]=1,g\\[2\\]=inf$ 插入5，$g\\[1\\]=1,g\\[2\\]=5,g\\[3\\]=inf$ 插入2，$g\\[1\\]=1,g\\[2\\]=2,g\\[3\\]=inf$ 插入4，$g\\[1\\]=1,g\\[2\\]=2,g\\[3\\]=4,g\\[4\\]=inf$ 插入3，$g\\[1\\]=1,g\\[2\\]=2,g\\[3\\]=3,g\\[4\\]=inf$ 如何快速更新？ 二分查找？ 时间复杂度$O(nlogn)$ 假如输入数列有重复？ 映射到不同的值上。 例题 输入一个整数序列$a\\_1,a\\_2,…,a_n$，最少需要修改几次使整个序列变成严格上升序列？（要求修改后均为整数）。 让$a_i$减去$i$，得到一个数列，求n-该数列最长不下降子序列长度。 最长公共子序列 状态：$f\\[i\\]\\[j\\]$表示$s\\[1..i\\],t\\[1,,j\\]$的最长公共子序列 转移方程： $s\\[i\\]=t\\[j\\]：f\\[i\\]\\[j\\]=f\\[i-1\\]\\[j-1\\]+1$ $s\\[i\\]\\\\neq t\\[j\\]：f\\[i\\]\\[j\\]=max{f\\[i-1\\]\\[j\\],f\\[i\\]\\[j-1\\]}$ 时间复杂度$O(n^2)$ 如果$s,t\\\\leq100000$呢？ 保证s中每一个元素出现的次数小于10次。 思路 如果互不相同 让t中在s中没有出现过的元素删去，让t以s的顺序排序，算一个最长上升子序列。 那次数$\\\\leq10$呢？ 转化为LIS（最长上升子序列） 例如： s=abdbad t=abcbd a:5,1 b:4,2 c:。。 d:6,3 所以t转化为5，1，4，2，4，2，6，3 再求t的最长上升子序列。 总结起来就是： 将每个元素在s中出现的下表以降序存在一个链表里，未完。。。 DAG上的dp 输入一个有向无环图（DAG），并给定起点s，边权为正，计算从s到每个点u的最长路长度$d\\[u\\]$. 要求时间复杂度$O(n+m)$ 先进行拓扑排序$v\\_1,v\\_2…,v\\_n$ 假设$v\\_1=s$。（否则，s走不到排在s前面的点，可以直接设置它们最短路为-inf） $d\\[v\\_i\\]=0$ 从$i=2,…,n$，枚举所有指向$v\\_i$的边，计算的$d\\[v\\_i\\]=max{d\\[v\\_j\\]+w(v\\_j,v\\_i)}$ 记忆化搜索![记忆化搜索](https://img-blog.csdnimg.cn/20190129102104444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNDQwNDg=,size_16,color_FFFFFF,t_70) 背包问题01背包 有$n$个物品，每个有体积$w\\[i\\]$,价值$v\\[i\\]$。总体积为$W$的背包最多能装多少总价值？ $(n,W\\\\leq2000)$ 设计状态：$f\\[i\\]\\[j\\]$表示$j$体积装前$i$件物品，最大的总价值。 如何转移？ $f\\[i\\]\\[j\\]=max(f\\[i-1\\]\\[j\\],f\\[i-1\\]\\[j-w\\[i\\]\\]+v\\[i\\])$ `cpp for(int i=1;i&lt;=n;i++){ for(int j=0;j&lt;=w[i];j++) f[i][j]=f[i-1][j]; for(int j=w[i];j&lt;=W;j++){ f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+v[i]) } }` 优化空间后： for(int i=1;i&lt;=n;i++){ for(int j=W;j&gt;=w[i];j--){ f[j]=max(f[j],f[j-w[i]]+v[i]) } } 完全背包 有$n$种物品，每种有体积$w\\[i\\]$,价值$v\\[i\\]$且有无限个。总体积为$W$的背包最多能装多少总价值？ $(n,W\\\\leq2000)$ `cpp for(int i=1;i&lt;=n;i++){ for(int j=w[i];j&lt;=W;j++){ f[j]=max(f[j],f[j-w[i]]+v[i]) } }` 子集和问题 有$n$个物品，第$i$个体积为$w_i$。能否选出一个子集和，使总容量为$W$的背包装满？ $f\\[i\\]\\[j\\]=1 or 0$表示用前$i$件物品能否凑出$j$体积。 $f\\[0\\]\\[0\\]=1$ `cpp for(int i=1;i&lt;=n;i++){ for(int j=0;j&lt;=W;j++) f[i][j]=f[i-1][j]; for(int j=w[i];j&lt;=W;j++){ if(f[i-1][j-w[i]]) f[i][j]=1; } } //f[n][W]==1 or 0?` 动态子集和问题![动态子集和问题](https://img-blog.csdnimg.cn/20190129105743142.) 01背包 有$n$个物品，每个有体积$w\\[i\\]$,价值$v\\[i\\]$。总体积为$W$的背包最多能装多少总价值？ $(n\\\\leq2000，v\\[1\\]+v\\[2\\]+···+v\\[n\\]\\\\leq2000,W\\\\leq10^9)$ 小技巧：反转状态和dp值 状态$f\\[i\\]\\[v\\]$表示前$i$件物品凑出$v$的总价值最小总体积。 边界$f\\[0\\]\\[0\\]=0$。 伪代码： f[0][0]=0;for(int i=0;i&lt;=n;i++){ f[0][i]=inf;} for(int i=1;i&lt;=n;i++){ for(int j=0;j&lt;=2000;j++){ f[i][j]=f[i-1][j]; } for(int j=0;j&lt;=2000;j++){ f[i][j]=min(f[i][j],f[i-1][j-v[i]]+w[i]); }} 区间DP合法子序列问题 一个由$$组成的序列，求出最长的合法子序列长度，$(n\\\\leq300)$。 定义：合法子序列是一个合法的括号序列，每一对匹配的括号都是同一类型的。比如$[()\\[\\]](()())$是合法的。 设计状态： $f\\[i\\]\\[j\\]$表示在$\\[i,j\\]$有多长的合法子序列。 转移： 如果$a\\[l\\],a\\[r\\]$是匹配的括号，则$2+f\\[l+1\\]\\[r-1\\]$ 枚举断点$k:f\\[l\\]\\[k\\]+f\\[k+1\\]\\[r\\]$ 按什么顺序进行DP？ 区间长度从小到大的顺序。 （或者：记忆化搜索） 时间复杂度：$O(n^3)$ 矩阵链乘法 将一个$p \\\\times q$的矩阵乘一个$q \\\\times r$的矩阵，得到一个$p \\\\times r$的矩阵，运算花费是$p \\\\times q \\\\times r$。 现在输入$p\\_1,p\\_2,p\\_3,…,p\\_n$。将$p\\_1 \\\\times p\\_2,p\\_2 \\\\times p\\_3,…,p_{n-1} \\\\times p_n$的矩阵乘起来，最小的总运算花费是多少？ 例题n（记不清了）![例题](https://img-blog.csdnimg.cn/20190129151756823.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNDQwNDg=,size_16,color_FFFFFF,t_70) \\- 设计状态： $f\\[l\\]\\[r\\]$表示$a\\[l,r\\]$字串的答案。 - 转移：$f\\[l\\]\\[k\\]+f\\[k+1\\]\\[r\\]$ 当a\\[l\\]==a\\[r\\]时，未完。。。 Floyd也是dp n个点的无向图，有向点和边权。每一对s，t，计算从s到t的路径，使得最小化：路径上的总边权+路径最大点权 $(n\\\\leq300)$ 状态压缩DP经典问题 求n个点的无向图的色数。（可以把顶点染成k种颜色之一，使得每条边两端不同色。最小的k是多少） $n\\\\leq16$ 设计状态，用f\\[s\\]表示结点子集S的色数。枚举子集进行转移。 $f\\[S\\]=min(f\\[S\\],1+f\\[S-T\\])$，T是S的子集$((T\\\\&amp;S)==t)$，T中的点两两不相邻。","link":"/2019/03/09/e6-b8-85-e5-8c-97-e5-ad-a6-e5-a0-82noip2019-e9-9b-86-e8-ae-add5-e5-8a-a8-e6-80-81-e8-a7-84-e5-88-92/"},{"title":" 清北学堂noip2019集训D6——动态规划\t\t","text":"状态压缩DP 最短哈密顿回路问题 给定一个完全图，带正边权$w(u,v)$。求出一个顶点的排列$v\\_1,v\\_2,…,v\\_n$，使得$w(v\\_1,v\\_2),w(v\\_2,v\\_3),…,w(v\\_{n-1},v\\_n),w(v\\_n,v_1)$的和最小。 $n\\\\leq17$ $f\\[i\\]\\[j\\]$表示在$i$这个点集中，从$0$到$j$的最短距离。（$0和$j$都在$i$集合里）//0~n-1 for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) f[i][j]=inf; f[1&lt;&lt;0][0]=0; for(int i=1;i&lt;(1&lt;&lt;n);i++){ if(!(i&amp;1)) continue; for(int j=0;j&lt;n;j++){ if(!((1&lt;&lt;j)&amp;1)) continue; for(int k=1;k&lt;n;k++){ if((1&lt;&lt;k)&amp;i) continue; f[i|(1&lt;&lt;k)][k]=min(f[i|(1&lt;&lt;k)][k],f[i][j]+w[j][k]); } } } int ans=inf; for(int j=1;j&lt;n;j++){ ans=min(ans,f[(1&lt;&lt;n)-1][j]+w[j][0]); } 例题2![例题2](https://img-blog.csdnimg.cn/20190130092435236.) \\- 设计状态： $f\\[i\\]\\[S\\]$表示只填入前i行当每个格子，有多少种合法方案，使得第$i$行当01串等于$S$。（合法：相邻两个格子不同时为$1$）。 sum1234567891011121314151617181920bool xl[1&lt;&lt;10];for(int i=0;i&lt;(1&lt;&lt;10);i++) if(\"S串中存在两个相邻的1\"){ xl[S]=1; }for(int s=0;s&lt;(1&lt;&lt;m);s++) f[1][s]=!xl[s];for(int i=2;i&lt;n;i++){ for(int =0;s&lt;(1&lt;&lt;m);s++){ if(xl[s]) f[i][s]=0; else{ //假设上一行填的是t for(int t=0;t&lt;(1&lt;&lt;m);t++){ if((t&amp;s)==0) f[i][s]=(f[i][s]+f[i-1][t])%p; } } }} &lt;/code&gt;&lt;/pre&gt; - 优化后 12345678910111213141516171819202122232425 sum=0; for(int i=0;i&lt;(i&lt;&lt;n);i++){ sum=sum+f[n][i]%p; }bool xl[1&lt;&lt;10];for(int i=0;i&lt;(1&lt;&lt;10);i++) if(\"S串中存在两个相邻的1\"){ xl[S]=1; }for(int s=0;s&lt;(1&lt;&lt;m);s++) f[1][s]=!xl[s];for(int i=2;i&lt;n;i++){ for(int =0;s&lt;(1&lt;&lt;m);s++){ if(xl[s]) f[i][s]=0; else{ int buji=(1&lt;&lt;m)-1-s;//补集 for(int t=buji;t;t=(t-1)&amp;buji){ f[i][s]=(f[i][s]+f[i-1][t])%p; } f[i][s]=(f[i][s]+f[i-1][0])%p; } }} Dominating set支配集 一个无向图的支配集是一个点的子集$S$，使得图中每个点都属于S或者与至少与一个$S$中的节点相邻 二者至少一个成立 $n$个点的二分图，求其最小支配集。$n\\leq30$(两边一共$n$个点)","link":"/2019/03/09/e6-b8-85-e5-8c-97-e5-ad-a6-e5-a0-82noip2019-e9-9b-86-e8-ae-add6-e5-8a-a8-e6-80-81-e8-a7-84-e5-88-92/"},{"title":" Luogu P1272 重建道路","text":"[题目链接](https://www.luogu.org/problem/P1272) 树形DP，有点背包的意思。 用$f[x][i]$表示以x为根的子树，保留i个节点，最少割掉多少条边。然后搜一次树，回溯的时候转移，方程是$f[x][i]=min(f[x][i],f[x][j]+f[y][i-j]-2)$枚举j从1道i-1，具体看代码注释吧。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;int n, p, dig[159];struct Edge{ int to, nxt;}e[309];int head[159], tot;int f[159][159];void add(int x, int y){ e[++tot].to = y; e[tot].nxt = head[x]; head[x] = tot;}void dfs(int x, int fa){ f[x][1] = dig[x]; //初始化一下，以x为根，只保留一个节点就是砍掉其他所有相连边，就是度数。 for(int i = head[x]; i; i = e[i].nxt){ int y = e[i].to; if(y == fa) continue; dfs(y, x); for(int j = p; j &gt;= 1; j--){ for(int k = 1; k &lt; j; k++){ f[x][j] = min(f[x][j], f[x][k] + f[y][j - k] - 2); //之所以要-2是因为刚刚初始化的时候砍掉了x-&gt;y的这条边，f[x][k]多砍了一次，f[y][j-k]又多砍了一次，所以减去2。 } } }}int main(){ scanf(\"%d%d\", &amp;n, &amp;p); for(int i = 1; i &lt;= n - 1; i++){ int x, y; scanf(\"%d%d\", &amp;x, &amp;y); add(x, y), add(y, x); dig[x]++, dig[y]++; } memset(f, 0x3f, sizeof(f)); dfs(1, 0); int ans = 0x3f3f3f3f; for(int i = 1; i &lt;= n; i++){ ans = min(ans, f[i][p]); } printf(\"%d\\n\", ans); return 0;}","link":"/2019/07/27/luogu-P1272-重建道路/"},{"title":"luogu-P2467-地精部落","text":"","link":"/2019/07/27/luogu-P2467-地精部落/"},{"title":" Luogu P1026 统计单词个数\t\t","text":"这两天都忙得忘了写了。。。 今天把这几天做的好题都补一下吧。。。 [题目链接](https://www.luogu.org/problemnew/show/P1026 “题目链接”) 老实说，这道题已经困扰我好几个月了，刚学dp就知道这道题，现在才做出来，所以准备写一下。。 题意大概就是给一个字符串，和一堆单词，问把这个字符串分成k段后，每段的单词数量的和的最大值是多少。 这道题用string的几个方法非常方便。 - 1.find(2)在第一个字符串中查找字符串2，并返回第一个下标，如果不存在，返回1844674407370955161这是个什么鬼东西我也不知道。 - .substr(x,len)取出字符串中以x开头长度为len的一个子字符串。 设计状态：$f\\[i\\]\\[k\\]$代表前i个字符分成k段的最大单词总数。 转移：$f\\[i\\]\\[k\\]=max(f\\[i\\]\\[k\\],f\\[j\\]\\[k-1\\]+sum\\[j+1\\]\\[i\\])$枚举断点j，$sum\\[i\\]\\[j\\]$代表原字符串从i到j的单词总数，先预处理一下。 剩下的看代码吧： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;int n,k,m;string s,x;string d[8];int dl[8],sum[209][209];int dp[209][49];bool pd(int l,int r){ string x=s.substr(l,r-l+1); for(int i=1;i&lt;=m;i++){ if(x.find(d[i])==0) return 1; } return 0;}int main(){ cin&gt;&gt;n&gt;&gt;k; s=\"0\"; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;x; s=s+x; } cin&gt;&gt;m; for(int i=1;i&lt;=m;i++){ cin&gt;&gt;d[i]; } int len=s.length()-1; for(int i=len;i&gt;=1;i--){ for(int j=i;j&gt;=1;j--){ sum[j][i]=sum[j+1][i]; if(pd(j,i)) sum[j][i]++; } } for(int i=1;i&lt;=len;i++) dp[i][1]=sum[1][i]; for(int q=1;q&lt;=k;q++){ for(int i=q+1;i&lt;=len;i++){ for(int j=q;j&lt;i;j++){ dp[i][q]=max(dp[i][q],dp[j][q-1]+sum[j+1][i]); } } } cout&lt;&lt;dp[len][k]; return 0;}","link":"/2019/05/28/luogu-p1026-e7-bb-9f-e8-ae-a1-e5-8d-95-e8-af-8d-e4-b8-aa-e6-95-b0/"},{"title":"luogu-P1831-重要的城市","text":"[题目链接](https://www.luogu.org/problem/P1841) 跑一次floyd即可，新建一个数组c，如果i到j的最短路能被k更新，那么说明最短路一定会经过k，所以c[i][j]保存一下k，如果更新过程发现存在一个相等的更新条件，说明最短路有多条，这个时候就可以删去c[i][j]里面的数. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;int n, m;int f[209][209], cnt[209][209];bool ans[209];int tot;int main(){ scanf(\"%d%d\", &amp;n, &amp;m); memset(f, 0x3f, sizeof(f)); for(int i = 1; i &lt;= n; i++){ f[i][i] = 0; } for(int i = 1; i &lt;= m; i++){ int x, y, w; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;w); f[x][y] = w; f[y][x] = w; } for(int k = 1; k &lt;= n; k++){ for(int i = 1; i &lt;= n; i++){ if(i == k) continue; for(int j = 1; j &lt;= n; j++){ if(i == j || j == k) continue; if(f[i][k] + f[k][j] &lt; f[i][j]){ f[i][j] = f[i][k] + f[k][j]; cnt[i][j] = k; } else if(f[i][k] + f[k][j] == f[i][j]){ cnt[i][j] = 0; } } } } for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= n; j++){ ans[cnt[i][j]] = 1; } } for(int i = 1; i &lt;= n; i++){ if(ans[i]) printf(\"%d \", i), tot++; } if(tot == 0) printf(\"No important cities.\"); return 0;}","link":"/2019/07/29/luogu-P1831-重要的城市/"},{"title":"Luogu P2831 愤怒的小鸟","text":"[题目链接](https://www.luogu.org/problem/P2831) 一个搜索，或者状压，蒟蒻不会状压dp，就写了搜索。。。 一个猪，有两种方式死，一是只被一只鸟打死，另外一个是和之前一只猪一起被同一只鸟打死，因为两只猪确定一条抛物线。 然后搜索其实就是对于第i个猪，到目前为止已经确定了ok条抛物线，还有no个没有组成抛物线的猪（就是独自被一只鸟打死的），然后看一下之前已经组成的抛物线有没有一条能够打死该猪，可以的话就往后搜就行，不然就分两种情况： 这只猪和这只猪之前的一只猪组成一条抛物线。 这只猪单独被打中。 对于每种情况单独搜索即可。具体描述放在代码里。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;int n, m, ans;int maxn;struct node{ double x, y;}a[20];struct node1{ double a, b;}p[20];bool vis[20];bool sam(double a, double b){ return abs(a - b) &lt;= 1e-6;}void dfs(int k, int ok, int no){ if(k == n + 1){ ans = min(ans, ok + no); } if(ok + no &gt;= ans) return; //这个地方一定得注意，上面这句写&gt;=是最优性剪枝。 //一定得写&gt;=,写&gt;会超时，T一个点。 //下面一定得&gt;，因为会WA。。。 if(ok + no &gt; maxn) return; int flag = 1; for(int i = 1; i &lt;= ok; i++){ if(sam(p[i].a*a[k].x*a[k].x+p[i].b*a[k].x, a[k].y)){ //这里处理了第一种情况，就是能和之前已经有的抛物线组成一起。 //然后vis数组这个比较正常。 vis[k] = 1; dfs(k + 1, ok, no); vis[k] = 0; flag = 0; break; } } if(flag){ //这里处理第二种情况，与这个猪前面其中一个猪组成一条抛物线。 for(int i = 1; i &lt; k; i++){ if(vis[i]) continue; if(a[i].x == a[k].x) continue; //这里计算一下aa和bb，就是抛物线的a和b，拿方程组手推一下就出来了。 double aa = (a[k].y*a[i].x/a[k].x-a[i].y)/(a[i].x*(a[k].x-a[i].x)); double bb = (a[k].y-aa*a[k].x*a[k].x)/a[k].x; if(aa &lt; 0){ p[ok+1].a = aa; p[ok+1].b = bb; vis[i] = 1; vis[k] = 1; dfs(k + 1, ok + 1, no - 1); vis[i] = 0; vis[k] = 0; } } //最后这里是第三种情况，就是这一个单独组成一个抛物线。。。 dfs(k + 1, ok, no + 1); }}int main(){ int T; scanf(\"%d\", &amp;T); while(T--){ ans = 0x3f3f3f3f; maxn = 0x3f3f3f3f; memset(vis, 0, sizeof(vis)); scanf(\"%d%d\", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++){ double x, y; scanf(\"%lf%lf\", &amp;x, &amp;y); a[i].x = x; a[i].y = y; } if(m == 1) maxn = ceil(n / 3.0 + 1); dfs(1, 0, 0); printf(\"%d\\n\", ans); } return 0;}","link":"/2019/07/28/luogu-P2831-愤怒的小鸟/"},{"title":" Luogu P1073 最优贸易\t\t","text":"[题目链接](https://www.luogu.org/problemnew/show/P1073 “题目链接”) 这道题没太明白。。。 题解好多种方法，我就看了看第一种方法。 动态规划+dfs $f\\[x\\]$表示到x节点所能拿到差价的最大值。 状态转移方程：$f\\[x\\]=max(f\\[fa\\],c\\[x\\]-minx)$ $c\\[x\\],minx$分别是x节点的售价和到x节点的路上的最小售价。 剩下的写注释吧。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,w[100009];struct Edge{ int to,nxt;}e[1000009];int head[100009],tot;int f[100009],minn[100009];void add(int x,int y){ e[++tot].to=y; e[tot].nxt=head[x]; head[x]=tot;}void dfs(int x,int fa,int minx){ int pd=1;//这个就是判断要不要继续找下去的一个变量。 minx=min(minx,w[x]);//更新minx if(minx&lt;minn[x]) minn[x]=minx,pd=0;//minn保存的是到x节点最小值，这里就是如果最小值小于上一次访问这个节点的最小值，就更新。 int maxx=max(f[fa],w[x]-minx);//dp if(f[x]&lt;maxx) f[x]=maxx,pd=0;//这里是如果这次最大值大于上次访问这个节点时候的最大值，就要把这个新的值传递下去，直到全部传递完。 //其实就是这里不太明白。。。 if(pd) return; for(int i=head[x];i;i=e[i].nxt){ int y=e[i].to; dfs(y,x,minx); }}int main(){ cin&gt;&gt;n&gt;&gt;m; memset(minn,0x3f,sizeof(minn)); for(int i=1;i&lt;=n;i++) cin&gt;&gt;w[i]; for(int i=1;i&lt;=m;i++){ int x,y,op; cin&gt;&gt;x&gt;&gt;y&gt;&gt;op; if(op==1) add(x,y); else add(x,y),add(y,x); } dfs(1,0,0x3f3f3f3f); cout&lt;&lt;f[n]; return 0;}","link":"/2019/05/21/luogu-p1073-e6-9c-80-e4-bc-98-e8-b4-b8-e6-98-93/"},{"title":"Luogu P4046 [JSOI2010]快递服务","text":"[题目链接](https://www.luogu.org/problem/P4046) 这个题的输入挺坑的。。。反正我调了挺久。 $f_{i,j,k,l}$表示到第$i$个取货位置，三个车的位置分别在$i,j,k$，那么转移可以是:$$f_{i,j,k,a_i}=min(f_{i,j,k,a_i},f_{i,j,k}+dis(l,a_i))$$$$f_{i,j,a_i,l}=min(f_{i,j,a_i,l},f_{i,j,k}+dis(k,a_i))$$$$f_{i,a_i,k,l}=min(f_{i,a_i,k,l},f_{i,j,k}+dis(j,a_i))$$这样枚举一下$i,j,k$，取最小值即为答案。 然后时间空间就都炸了。。。 考虑优化：因为肯定有一个车的位置在$a_{i-1}$这样可以省去一维，然后第一维做一个滚动数组。$$f_{i,j,k}=min(f_{i,j,k},f_{i-1,j,k}+dis(a_{i-1},a_i))$$$$f_{i,j,a_{i-1}}=min(f_{i,j,a_{i-1}},f_{i-1,j,k}+dis(k,a_i))$$$$f_{i,a_{i-1},k}=min(f_{i,a_{i-1},k},f_{i-1,j,k}+dis(j,a_i))$$这个得仔细思考一下才行，我看题解的时候这里一直理解不了，之所以是转移到$a_{i-1}$而不是$a_i$是可以通过原来的那个没有优化的想一想得到的。。。反正玄学。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int inf = 0x3f3f3f3f;int n, m;ll d[209][209];ll f[2][209][209];int a[1009];int main(){ scanf(\"%d\", &amp;m); for(int i = 1; i &lt;= m; i++){ for(int j = 1; j &lt;= m; j++){ scanf(\"%d\", &amp;d[i][j]); f[0][i][j] = f[1][i][j] = inf; } } int n = 1; while(scanf(\"%d\", &amp;a[n]) == 1) n++; n--; int now = 0, last = 1; f[0][1][2] = 0; a[0] = 3; for(int t = 1; t &lt;= n; t++){ now = 1-now, last = 1-last; for(int i = 1; i &lt;= m; i++){ for(int j = 1; j &lt;= m; j++){ f[now][i][j] = inf; } } for(int i = 1; i &lt;= m; i++){ for(int j = 1; j &lt;= m; j++){ if(i == j || j == a[t-1] || i == a[t-1]) continue; if(f[last][i][j] == inf) continue; if(i != a[t] &amp;&amp; j != a[t]) f[now][i][j] = min(f[now][i][j],f[last][i][j]+d[a[t-1]][a[t]]); if(j != a[t]) f[now][a[t-1]][j] = min(f[now][a[t-1]][j],f[last][i][j]+d[i][a[t]]); if(i != a[t]) f[now][i][a[t-1]] = min(f[now][i][a[t-1]],f[last][i][j]+d[j][a[t]]); } } } ll ans = inf; for(int i = 1; i &lt;= m; i++){ for(int j = 1; j &lt;= m; j++){ ans = min(ans, f[now][i][j]); } } printf(\"%d\\n\", ans); return 0;}","link":"/2019/07/27/luogu-P4046-快递服务/"},{"title":" Luogu P1122 最大子树和\t\t","text":"[链接标题](https://www.luogu.org/problemnew/show/P1122 “链接标题”) 树形dp 统计出每个子树的大小，求max \\- 回溯时$f\\[x\\]=max(0,f\\[x_{son}\\])$代码如下1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;const int N=16009;vector&lt;int&gt; son[N];int v[N],n,maxn=-0x3f3f3f3f,f[N];void dp(int x,int fa){ f[x]=v[x]; for(int i=0;i&lt;son[x].size();i++){ int y=son[x][i]; if(y==fa) continue; dp(y,x); f[x]+=max(0,f[y]); } maxn=max(maxn,f[x]);}int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;v[i]; } for(int i=1;i&lt;n;i++){ int a,b; cin&gt;&gt;a&gt;&gt;b; son[a].push_back(b); son[b].push_back(a); } dp(1,0); cout&lt;&lt;maxn; return 0;}","link":"/2019/03/23/luogu-p1122-e6-9c-80-e5-a4-a7-e5-ad-90-e6-a0-91-e5-92-8c/"},{"title":" Luogu P1282 多米诺骨牌（精）\t\t","text":"[题目链接](https://www.luogu.org/problemnew/show/P1282 “题目链接”) 总结一下：这种题用背包。。。（蒟蒻的我看不出来qwq） 我们先把骨牌翻转，调整至点数大的在上面 这样，我们就能保证上方的点数一定比下方大，并且保证每翻转一 次，都能使上下的点数之差变小，而变小的点数，就是上下点数之差乘以2。 把改变的点数看成物品的体积，初始上下方的点数之差看做背包体积，不难看出背包问题的模型。 那么物品的重量是什么呢？ 因为我们一开始就把点数大的放在了上面，而每放一次，翻转次数就+1。考虑：要是我后来后悔了，我发现不翻这个骨牌更好怎么办？那我会把它翻回来，那么相当于没有翻这个骨牌。 因此，一开始翻过的骨牌重量就是-1，未翻过的骨牌重量就是1（重量等价于翻转次数） 当然，上下相同的骨牌就是体积为0，重量为0的物品，因为他们无论怎么翻，都不会对上下点数差造成影响。 至此，背包的模型就出来了。这个问题被简化成：有n个物品，给出每个物品的体积v\\[i\\],他们的重量是1或-1。背包的重量为base，体积为tot，现在请把这n个物品放到背包里去，总体积不能超过tot，体积最大的情况下使得物品重量之和最小。 其中，dp\\[i\\]\\[j\\]表示前i件物品能装到体积为j的最小重量 vs\\[i\\]\\[j\\]表示前i件物品能否装到j体积 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,c;struct node{ int a,b;}a[1009];int f[1009][5009],v[1009],w[1009];bool vis[1009][5009];int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i].a&gt;&gt;a[i].b; if(a[i].a&lt;a[i].b){ swap(a[i].a,a[i].b); w[i]=-1; v[i]=a[i].a-a[i].b; m+=v[i]; v[i]*=2; c++; } else{ w[i]=1; v[i]=a[i].a-a[i].b; m+=v[i]; v[i]*=2; } } for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ f[i][j]=f[i-1][j]; vis[i][j]=vis[i-1][j]; if(vis[i-1][j-v[i]]||j-v[i]==0){ if(!vis[i][j]){ f[i][j]=f[i-1][j-v[i]]+w[i]; vis[i][j]=1; } else{ f[i][j]=min(f[i][j],f[i-1][j-v[i]]+w[i]); } } } } for(int i=m;i&gt;=0;i--){ if(vis[n][i]){ cout&lt;&lt;f[n][i]+c; return 0; } } return 0;}","link":"/2019/05/08/luogu-p1282-e5-a4-9a-e7-b1-b3-e8-af-ba-e9-aa-a8-e7-89-8c-ef-bc-88-e7-b2-be-ef-bc-89/"},{"title":" Luogu P1271 聚会的快乐\t\t","text":"[题目链接](https://www.luogu.org/problemnew/show/P1271 “题目链接”) 树上dp 水题，和《没有上司的舞会》基本一样，多个字符串的hash（可以直接用STL-map） 设计状态：f\\[i\\]\\[0/1\\]表示第i个节点参加活动（1）或者不参加活动（0）。 状态转移方程： $f\\[fa\\]\\[1\\]+=f\\[x\\]\\[0\\]$ $f\\[fa\\]\\[0\\]+=max(f\\[x\\]\\[0\\],f\\[x\\]\\[1\\])$ 代码如下12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;map&lt;string,int&gt; hash;vector&lt;int&gt; son[209];struct Edge{ string u,fa; int w; }edge[209];int n,f[209][2],tot,tot_h,val[209],head[209];void dp(int x,int fa){ f[x][0]=0; f[x][1]=val[x]; for(int i=0;i&lt;son[x].size();i++){ int y=son[x][i]; if(y==fa) continue; dp(y,x); f[x][1]+=f[y][0]; f[x][0]+=max(f[y][0],f[y][1]); }}int main(){ cin&gt;&gt;n; int s; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;edge[i].u&gt;&gt;val[i]&gt;&gt;edge[i].fa; hash[edge[i].u]=i; } for(int i=1;i&lt;=n;i++){ son[hash[edge[i].fa]].push_back(i); } for(int i=1;i&lt;=n;i++){ if(!hash[edge[i].u]) s=i; } dp(s,-1); cout&lt;&lt;max(f[s][1],f[s][0]); return 0;}","link":"/2019/03/22/luogu-p1271-e8-81-9a-e4-bc-9a-e7-9a-84-e5-bf-ab-e4-b9-90/"},{"title":" Luogu P1550 [USACO08OCT]打井Watering Hole\t\t","text":"[题目链接](https://www.luogu.org/problemnew/show/P1550 “题目链接”) 这道题的思路感觉可以留下来，题目大意就是每个村能打一个井，也能挖水渠到其他村，但是需要所有村都有水，问最小花费。 \\- 可以建一个虚拟节点，和每个村连起来，边权就是打水井的花费，挖水渠就正常建边。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n,fa[309];int find(int x){ return x==fa[x]?x:fa[x]=find(fa[x]);}struct Edge{ ll x,y,w;}e[180009];int tot;void add(int x,int y,int w){ e[++tot].x=x; e[tot].y=y; e[tot].w=w;}bool cmp(Edge a,Edge b){ return a.w&lt;b.w;}ll kru(){ ll ans=0,cnt=0; for(int i=1;i&lt;=tot;i++){ int xx=find(e[i].x),yy=find(e[i].y); if(xx==yy) continue; fa[xx]=yy; ans+=e[i].w; cnt++; if(cnt==n) break; } return ans;}int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) fa[i]=i; for(int i=1;i&lt;=n;i++){ int w; cin&gt;&gt;w; add(0,i,w),add(i,0,w); } for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ int w; cin&gt;&gt;w; add(i,j,w); } } sort(e,e+tot+1,cmp); cout&lt;&lt;kru(); return 0;}","link":"/2019/05/16/luogu-p1550-usaco08oct-e6-89-93-e4-ba-95watering-hole/"},{"title":" Luogu P1353 [USACO08JAN]跑步Running\t\t","text":"[题目链接](https://www.luogu.org/problemnew/show/P1353 “题目链接”) 这是道绿题？？？？ 简单到不敢相信 直接上代码： 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;int f[10009][509],n,m,a[10009];int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; } f[1][1]=a[1]; //f(i,j)代表前i个时间里劳累度为j的最大路程。 for(int i=1;i&lt;=n;i++){ for(int j=0;j&lt;=m&amp;&amp;j&lt;=i;j++){ if(j==0){ f[i][j]=max(f[i][j],f[i-1][j]); } else{ f[i+j][0]=max(f[i+j][0],f[i][j]); } f[i+1][j+1]=max(f[i+1][j+1],f[i][j]+a[i+1]); } } cout&lt;&lt;f[n][0]; return 0;}","link":"/2019/03/12/luogu-p1353-usaco08jan-e8-b7-91-e6-ad-a5running/"},{"title":" Luogu P1363 幻想迷宫\t\t","text":"[链接](https://www.luogu.org/problemnew/show/P1363 “链接”) 看完题目，最开始的思路是先对图进行搜索，然后搜索在边界的位置是否有道路可以通向这张图对面相同的位置，但是这样的情况就判断不了。 S.#.. ##### #...#很明显这张图中上面的道路和下面的道路并不直接相连，但是却可以无限延伸。 所以我看了题解。。。 掌嘴。。。 我好菜啊。。。 心里好慌。。。 然后就是搜索，每一个点向四个方向搜，如果搜到边界，用取模的方式到这张地图的另外一边，同时保存其真实的坐标，这样一来，当真实坐标和这个位置上次访问到的坐标不同时，说明这个点访问了两次，就是说可以无限延伸。 具体看代码吧 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;int a[1509][1509];struct node{ int x,y; bool v;}d[1509][1509];bool flag=0;int yc[4]={0,0,-1,1},xc[4]={1,-1,0,0};void dfs(int x,int y,int rx,int ry){ if(flag) return; if(d[x][y].v&amp;&amp;(d[x][y].x!=rx||d[x][y].y!=ry)){ flag=1; return; } d[x][y].x=rx,d[x][y].y=ry,d[x][y].v=1;//这里更新一下相当于上次访问到的真实坐标。 for(int i=0;i&lt;4;i++){ int nx,ny; if(x+xc[i]==0) nx=n; else if(x+xc[i]==n+1) nx=1; else nx=x+xc[i]; if(y+yc[i]==0) ny=m; else if(y+yc[i]==m+1) ny=1; else ny=y+yc[i]; int nrx=rx+xc[i],nry=ry+yc[i]; if(!a[nx][ny]&amp;&amp;(d[nx][ny].x!=nrx||d[nx][ny].y!=nry||!d[nx][ny].v)){ dfs(nx,ny,nrx,nry); } }}int main(){ node start; while(cin&gt;&gt;n&gt;&gt;m){ flag=0; for(int i=1;i&lt;=n;i++){ string c; cin&gt;&gt;c; for(int j=1;j&lt;=m;j++){ d[i][j].x=0,d[i][j].y=0,d[i][j].v=0; a[i][j]=0; if(c[j-1]=='#') a[i][j]=1; if(c[j-1]=='S') start.x=i,start.y=j; } } dfs(start.x,start.y,start.x,start.y); if(flag) cout&lt;&lt;\"Yes\"&lt;&lt;endl; else cout&lt;&lt;\"No\"&lt;&lt;endl; } return 0;}","link":"/2019/05/31/luogu-p1363-e5-b9-bb-e6-83-b3-e8-bf-b7-e5-ae-ab/"},{"title":" Luogu P1537 弹珠\t\t","text":"[题目链接](https://www.luogu.org/problemnew/show/P1537 “题目链接”) 水背包，$f\\[i\\]$表示能否凑成$i$价值的物品； 分成两组，及判断$f\\[sum/2\\]$的情况。 代码12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int f[210009],a[7],s,tot;int main(){ while(1){ tot++; s=0; for(int i=1;i&lt;=6;i++){ cin&gt;&gt;a[i]; s+=a[i]*i; } if(s==0) break; printf(\"Collection #%d:\\n\",tot); if(s%2==1){ printf(\"Can't be divided.\\n\\n\"); continue; } f[0]=1; for(int i=1;i&lt;=6;i++){ for(int j=s/2;j&gt;=i;j--){ for(int k=1;k&lt;=a[i];k++){ if(i*k&lt;=j&amp;&amp;f[j-k*i]==1) f[j]=1; } } } if(f[s/2]==1) printf(\"Can be divided.\\n\\n\"); else printf(\"Can't be divided.\\n\\n\"); for(int i=1;i&lt;=s/2;i++) f[i]=0; } return 0;}","link":"/2019/03/24/luogu-p1537-e5-bc-b9-e7-8f-a0/"},{"title":" Luogu P1622 释放囚犯\t\t","text":"[题目链接](https://www.luogu.org/problemnew/show/P1622 “题目链接”) 区间dp$f\\[i\\]\\[j\\]$表示释放$i$\\\\~$j$的罪犯所需要的最少的肉，转移枚举分界点$k$。 转移方程:$f\\[i\\]\\[j\\]=min(f\\[i\\]\\[j\\],f\\[i\\]\\[k-1\\]+f\\[k+1\\]\\[j\\]+a\\[j+1\\]-a\\[i-1\\]-1)$ $a\\[j+1\\]-a\\[i-1\\]-1$就是第$i-1$到$j+1$个罪犯之间的人数，及所需肉的数量。 - 注意，上述方程需要满足单调性，所以先排序。 代码如下:12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int a[1009],f[109][109];int n,m;int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++){ cin&gt;&gt;a[i]; f[i][i]=n-1; } a[m+1]=n+1; sort(a+1,a+m+1); for(int l=1;l&lt;=m;l++){ for(int i=1;i+l-1&lt;=m;i++){ int j=i+l-1; f[i][j]=0x3f3f3f3f; for(int k=i;k&lt;=j;k++){ if(f[i][j]&gt;f[i][k-1]+f[k+1][j]+a[j+1]-a[i-1]-2) f[i][j]=f[i][k-1]+f[k+1][j]+a[j+1]-a[i-1]-2; } } } cout&lt;&lt;f[1][m]; return 0;}","link":"/2019/03/15/luogu-p1622-e9-87-8a-e6-94-be-e5-9b-9a-e7-8a-af/"},{"title":" Luogu P1594 护卫队\t\t","text":"[题目链接](https://www.luogu.org/problemnew/show/P1594 “题目链接”) $f\\[i\\]$表示前$i$辆车通过桥所需要的最短时间,$len$表示桥长度，$minx\\[i\\]\\[j\\]$表示从i到j的速度最小值，$sum\\[i\\]$表示前$i$辆车的重量前缀和。 - 首先$f\\[i\\]=len/v_i+f\\[i-1\\]$ - 枚举$j&lt;i$，如果第$j$到$i$辆车可以同时通过，那么$f\\[i\\]=min(f\\[i\\],f\\[j\\]+len/minx\\[j\\]\\[i\\])$ 代码如下：123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;long long g,l,n;struct node{ long long w,s;}a[1009];long long minx[1009][1009],sum[1009];double dp[1009];int main(){ cin&gt;&gt;g&gt;&gt;l&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i].w&gt;&gt;a[i].s; sum[i]=sum[i-1]+a[i].w; minx[i][i]=a[i].s; } for(int i=1;i&lt;=n;i++){ for(int j=i+1;j&lt;=n;j++){ minx[i][j]=min(a[j].s,minx[i][j-1]); } } for(int i=1;i&lt;=n;i++){ dp[i]=(double)l/a[i].s+dp[i-1]; for(int j=i;j&gt;0;j--){ if(sum[i]-sum[j-1]&lt;=g) dp[i]=min(dp[i],dp[j-1]+(double)l/minx[j][i]); } } dp[n]*=60; printf(\"%.1lf\",dp[n]); return 0;}","link":"/2019/04/09/luogu-p1594-e6-8a-a4-e5-8d-ab-e9-98-9f/"},{"title":" Luogu P1651 塔\t\t","text":"[题目链接](https://www.luogu.org/problemnew/show/P1651 “题目链接”) 突然发现，我还是太菜了。 这道题做了一个半小时，开始的一个小时想的都是错的，后来还是看了题解，本来我想的是用bool数组$f\\[i\\]\\[j\\]$来表示从木块中选i个木块能否组成j的高度，用0和1表示。后来打了70分（数据好水）才发现这有后效性。 正解因为题目中讲能否选择几个木块构成两个高度相同的塔，要求输出这个塔的最大高度，那么就可以想到，使用$f\\[i\\]\\[j\\]$来表示选到第i个时，且两个塔的高度差为j时，较高的那个塔的高度，这样便有四个状态可以转移。 - 不放第i个：$f\\[i\\]\\[j\\]=f\\[i-1\\]\\[j\\]$ - 把第i个放到较矮的塔上，矮塔还是矮塔：$f\\[i\\]\\[j\\]=max(f\\[i\\]\\[j\\],f\\[i-1\\]\\[j+a\\[i\\]\\])$ - 放到较高的塔上，高塔当然高：$f\\[i\\]\\[j\\]=max(f\\[i\\]\\[j\\],f\\[i-1\\]\\[j-a\\[i\\]\\]+a\\[i\\])$ - 放到较低的塔上，低塔变成高塔：$f\\[i\\]\\[j\\]=max(f\\[i\\]\\[j\\],f\\[i-1\\]\\[a\\[i\\]-j\\]+j)$ 综上，代码如下： 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;int n,a[55],sum;int f[55][500005];int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; sum+=a[i]; } memset(f,-0x3f,sizeof(f)); f[0][0]=0; for(int i=1;i&lt;=n;i++){ for(int j=sum;j&gt;=0;j--){ f[i][j]=max(f[i][j],f[i-1][j]); f[i][j]=max(f[i][j],f[i-1][j+a[i]]); if(j&gt;=a[i]) f[i][j]=max(f[i][j],f[i-1][j-a[i]]+a[i]); if(j&lt;=a[i]) f[i][j]=max(f[i][j],f[i-1][a[i]-j]+j); } } if(f[n][0]&lt;=0) cout&lt;&lt;\"-1\"; else cout&lt;&lt;f[n][0]; return 0;}","link":"/2019/04/14/luogu-p1651-e5-a1-94/"},{"title":" Luogu P1875 佳佳的魔法药水\t\t","text":"[链接](https://www.luogu.org/problemnew/show/P1875 “链接”) 图论，明显是dijkstra，$d\\[i\\]$数组保存第$i$个药水的最小配置价格，$cnt\\[i\\]$保存第$i$个药水最小配置价格的方案数，具体过程： 1. 每次找一个没有访问过的配置价格最小的药水$x$。 2. 枚举所有可以和$x$组成新药水的药水$i$并且已经访问过的节点。 3. 如果$x$和$i$组成的新药水的最小配置价格$d\\[j\\]&lt;d\\[x\\]+d\\[i\\]$，那就更新，并且$cnt\\[j\\]=cnt\\[x\\] \\\\times cnt\\[i\\]$ 4. 否则如果$d\\[j\\]=d\\[x\\]+d\\[i\\]$，那么$cnt\\[j\\]+=cnt\\[i\\] \\\\times cnt\\[x\\]$ 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;int a[1509][1509];struct node{ int x,y; bool v;}d[1509][1509];bool flag=0;int yc[4]={0,0,-1,1},xc[4]={1,-1,0,0};void dfs(int x,int y,int rx,int ry){ if(flag) return; if(d[x][y].v&amp;&amp;(d[x][y].x!=rx||d[x][y].y!=ry)){ flag=1; return; } d[x][y].x=x,d[x][y].y=y,d[x][y].v=1; for(int i=0;i&lt;4;i++){ int nx,ny; if(x+xc[i]==0) nx=n; else if(x+xc[i]==n+1) nx=1; else nx=x+xc[i]; if(y+yc[i]==0) ny=m; else if(y+yc[i]==m+1) ny=1; else ny=y+yc[i]; int nrx=rx+xc[i],nry=ry+yc[i]; if(!a[nx][ny]&amp;&amp;(d[nx][ny].x!=nrx||d[nx][ny].y!=nry||!d[nx][ny].v)){ dfs(nx,ny,nrx,nry); } }}int main(){ node start; while(cin&gt;&gt;n&gt;&gt;m){ flag=0; for(int i=1;i&lt;=n;i++){ string c; cin&gt;&gt;c; for(int j=1;j&lt;=m;j++){ d[i][j].x=0,d[i][j].y=0,d[i][j].v=0; a[i][j]=0; if(c[j-1]=='#') a[i][j]=1; if(c[j-1]=='S') start.x=i,start.y=j; } } dfs(start.x,start.y,start.x,start.y); if(flag) cout&lt;&lt;\"Yes\"&lt;&lt;endl; else cout&lt;&lt;\"No\"&lt;&lt;endl; } return 0;}","link":"/2019/06/01/luogu-p1875-e4-bd-b3-e4-bd-b3-e7-9a-84-e9-ad-94-e6-b3-95-e8-8d-af-e6-b0-b4/"},{"title":" Luogu P1896 [SCOI2005]互不侵犯\t\t","text":"我感觉这道题还不错，状压dp的一类典型问题？ [题目链接](https://www.luogu.org/problemnew/show/P1896 “题目链接”) 就是给个n*n的表格，然后放k个旗子，旗子每个旗子相邻的8个格子不能放旗子。问最多有几种放的方法。 状态就是$f\\[i\\]\\[j\\]\\[k\\]$表示第i行，状态为j，并且已经放了k个格子的方案总数。然后预处理一下can数组，保存左右互不侵犯的状态。再预处理$gs\\[i\\]$数组表示状态为i的有多少个旗子(i的二进制里有多少个1)。 这样枚举上一行状态，如果上一行和这一行满足左上，上，右上互不侵犯，那么$f\\[i\\]\\[j\\]\\[k+gs\\[i\\]\\]+=f\\[i-1\\]\\[l\\]\\[k\\]$ 最终答案就是所有$f\\[n\\]\\[i\\]\\[k\\]$的和。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n,k;ll f[10][1&lt;&lt;10][90],can[1&lt;&lt;10],tot;int gs[1&lt;&lt;10];int gs1(int x){ int cnt=0; while(x){ if(1&amp;x) cnt++; x&gt;&gt;=1; } return gs[tot]=cnt;}int main(){ cin&gt;&gt;n&gt;&gt;k; for(int i=0;i&lt;(1&lt;&lt;n);i++) if(!(i&amp;(i&lt;&lt;1))) can[++tot]=i,f[1][tot][gs1(i)]=1; for(int i=2;i&lt;=n;i++){ for(int j=1;j&lt;=tot;j++){ int a=can[j]; for(int l=1;l&lt;=tot;l++){ int b=can[l]; if(a&amp;b) continue; if(a&amp;(b&lt;&lt;1)) continue; if(a&amp;(b&gt;&gt;1)) continue; for(int g=0;g+gs[j]&lt;=k;g++) f[i][j][gs[j]+g]+=f[i-1][l][g]; } } } ll ans=0; for(int i=1;i&lt;=tot;i++) ans+=f[n][i][k]; cout&lt;&lt;ans; return 0;}","link":"/2019/05/28/luogu-p1896-scoi2005-e4-ba-92-e4-b8-8d-e4-be-b5-e7-8a-af/"},{"title":" Luogu P1983 车站分级\t\t","text":"[题目链接](https://www.luogu.org/problemnew/show/P1983 “题目链接”) 又是一道比较经典的题，据说有什么线段树优化构造。。。反正我是不懂。 这道题使用topsort（拓扑排序）的思想； 简化题意：n个车站，每个车站有一个级别，如果有一趟列车，这趟列车经过$a\\_1,a\\_2,···,a_s$站，且如果这些站中级别最低的车站的级别为$minx$，那么所有在起点站到终点站之间级别大于等于$minx$的车站都必须停靠。那么m趟列车，给定每趟列车的经过站（车站编号升序给出），求所有车站至少分成多少级。 思路：如果从起点站到终点站之间有火车站没有停靠，就说明这个火车站的级别一定小于所有停靠了的火车站，那么就将每个没有停靠的火车站向停靠的火车站连一条边，这样用topsort的思想，可算出最终分成了几层，便是最少的级别数量； 例如数据 1 3 5 6停靠 ![1](http://yueyangwu.cn/wp-content/uploads/2019/06/56401.png “1”) 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,a[1009],cd[1009],st[1009];bool v[1009],top[1009][1009],del[1009];int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++){ memset(v,0,sizeof(v)); int s; cin&gt;&gt;s; for(int j=1;j&lt;=s;j++){ cin&gt;&gt;a[j]; v[a[j]]=1; } for(int j=a[1];j&lt;=a[s];j++){ if(!v[j]){ for(int k=1;k&lt;=s;k++){ if(top[a[k]][j]) continue; top[a[k]][j]=1; cd[a[k]]++; } } } } int r=1,ans=0; while(r){ r=0; for(int i=1;i&lt;=n;i++){ if(cd[i]==0&amp;&amp;!del[i]){ st[++r]=i; del[i]=1; } } if(r) ans++; for(int i=1;i&lt;=r;i++){ for(int j=1;j&lt;=n;j++){ if(!top[j][st[i]]) continue; top[j][st[i]]=0; cd[j]--; } } } cout&lt;&lt;ans; return 0;}","link":"/2019/06/03/luogu-p1983-e8-bd-a6-e7-ab-99-e5-88-86-e7-ba-a7/"},{"title":" Luogu P2024 [NOI2001]食物链\t\t","text":"题目描述动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。A 吃 B，B 吃 C，C 吃 A。 现有 N 个动物，以 1 － N 编号。每个动物都是 A,B,C 中的一种，但是我们并不知道 它到底是哪一种。 有人用两种说法对这 N 个动物所构成的食物链关系进行描述： 第一种说法是“1 X Y”，表示 X 和 Y 是同类。 第二种说法是“2 X Y”，表示 X 吃 Y 。 此人对 N 个动物，用上述两种说法，一句接一句地说出 K 句话，这 K 句话有的是真 的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 • 当前的话与前面的某些真的话冲突，就是假话 • 当前的话中 X 或 Y 比 N 大，就是假话 • 当前的话表示 X 吃 X，就是假话 你的任务是根据给定的 N 和 K 句话，输出假话的总数。 输入输出格式**输入格式：** 第一行两个整数，N，K，表示有 N 个动物，K 句话。 第二行开始每行一句话（按照题目要求，见样例） **输出格式：** 一行，一个整数，表示假话的总数。 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190225192244940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNDQwNDg=,size_16,color_FFFFFF,t_70) 题解转载：[Sooke’s OI Record](https://www.luogu.org/blog/Sooke/solution-p2024)","link":"/2019/03/09/luogu-p2024-noi2001-e9-a3-9f-e7-89-a9-e9-93-be/"},{"title":" Luogu P2280 [HNOI2003]激光炸弹\t\t","text":"[题目链接](https://www.luogu.org/problemnew/show/P2280 “题目链接”) 一道水体，很显然需要二维前缀和，然后考虑一个$O(n^2)$算法，枚举每一个点作为炸弹投放矩阵的右下角，这题就做完了qwq。 代码如下1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;const int N=5009;int a[N][N],ans;int main(){ int n,r; cin&gt;&gt;n&gt;&gt;r; for(int i=1;i&lt;=n;i++){ long long x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; a[x+1][y+1]=z; } for(int i=1;i&lt;=5001;i++){ for(int j=1;j&lt;=5001;j++){ a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1]; } } for(int i=r;i&lt;=5001;i++){ for(int j=r;j&lt;=5001;j++){ ans=max(ans,a[i][j]-a[i-r][j]-a[i][j-r]+a[i-r][j-r]); } } if(ans==0) return 0; cout&lt;&lt;ans; return 0;} P.S.绿题难度怎么差异这么大，~也太简单了吧!~","link":"/2019/03/18/luogu-p2280-hnoi2003-e6-bf-80-e5-85-89-e7-82-b8-e5-bc-b9/"},{"title":" Luogu P2327 [SCOI2005]扫雷\t\t","text":"[题目链接](https://www.luogu.org/problemnew/show/P2327 “题目链接”) 思路： 这道题一开始想的状态是$f(i,j)$表示第i个位置放与不放炸弹（用j表示），后来怎么也写不对代码:sweat:，所以我看了眼题解，少了一维。 咳咳，正解： 先设计状态，$f(i,j,k)$表示第i个位置放不放炸弹和下一位放不放炸弹（分别用j，k表示），这样就可以推出转移的方法。 当第i位数字为0时，那直接从$f(i-1,0,0)$转移过来。 当为1时，就有分别把炸弹放到3个格子当中的3种方法。 当为2,3时，同理。 P.S. 题解上说答案只能是大于0，小于2，貌似是的，但是为什么？求大佬解释qwq。 代码如下：12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;int f[10009][2][2],a[10009],n;int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; } f[0][0][0]=f[0][0][1]=1;//第0个位置一定不选，下个位置有选和不选两种情况。 for(int i=1;i&lt;=n;i++){ if(a[i]==0)//如果这个位置为0，那这个位置和上下位置均不选。 f[i][0][0]+=f[i-1][0][0]; if(a[i]==1)//如果为1，那可以这个位置和上下两个位置任意一个选。下方同理。 f[i][1][0]+=f[i-1][0][1],f[i][0][1]+=f[i-1][0][0],f[i][0][0]+=f[i-1][1][0]; if(a[i]==2) f[i][1][0]+=f[i-1][1][1],f[i][0][1]+=f[i-1][1][0],f[i][1][1]+=f[i-1][0][1]; if(a[i]==3) f[i][1][1]+=f[i-1][1][1]; } cout&lt;&lt;f[n][1][0]+f[n][0][0];//在第n个选与不选的结果相加即为ans。 return 0;}","link":"/2019/03/11/luogu-p2327-scoi2005-e6-89-ab-e9-9b-b7/"},{"title":" Luogu P2285 [HNOI2004]打鼹鼠\t\t","text":"[题目链接](https://www.luogu.org/problemnew/show/P2285 “题目链接”) 我开始想到棋盘问题。。。三维数组爆空间。。。 然后就看了看算法标签 想了个一维dp $f\\[i\\]$表示前i个地鼠最多能被砸死几个，因为发现时间是按顺序排列的，所以可以想到从当前时间前面探出头的地鼠转移，所以 - $f\\[i\\]=max(f\\[i\\],f\\[j\\]+1)(a\\[j\\].t&lt;a\\[i\\].t$且$dis(i,j)\\\\leq tim(i,j))$ 代码： 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;int f[10009],n,m;struct node{ int t,x,y;}a[10009];int dis(int i,int j){ return abs(a[i].x-a[j].x)+abs(a[i].y-a[j].y);}int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++){ cin&gt;&gt;a[i].t&gt;&gt;a[i].x&gt;&gt;a[i].y; f[i]=1; } for(int i=1;i&lt;=m;i++){ for(int j=1;j&lt;=i-1;j++){ if(dis(i,j)&lt;=abs(a[i].t-a[j].t)){ f[i]=max(f[i],f[j]+1); } } } int ans=0; for(int i=1;i&lt;=m;i++){ ans=max(ans,f[i]); } cout&lt;&lt;ans; return 0;}","link":"/2019/05/09/luogu-p2285-hnoi2004-e6-89-93-e9-bc-b9-e9-bc-a0/"},{"title":" Luogu P2340 奶牛会展\t\t","text":"题意：给定$n$组数，每组数包含2个数字$S\\_i$和$F\\_i$。 要求：取其中几组数，要求他们的和最大，并且所有$S\\_i$的和与$F\\_i$的和均大于0。 $1\\\\leq N\\\\leq 400$ $-1000\\\\leq S\\_i,F\\_i\\\\leq 1000$ 可以看出，每组数有选与不选两种情况，可以转化为01背包，让$S\\_i$作为物品体积，$F\\_i$作为物品价值。但是由题意可以发现，$S\\_i$有可能为负数，又因为$-1000\\\\leq S\\_i\\leq 1000$，所以背包体积可以是$-400000\\\\leq m\\\\leq 400000$，因为数组下标不可以为负，所以将整个数组向右平移$400000$个单位，把$400000$当做$0$。 这样如果$S_i&lt;0$那么正序枚举，反之倒序枚举。 代码： 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;int v[409],w[409];int f[800009],n;int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;w[i]&gt;&gt;v[i]; } memset(f,~0x3f,sizeof(f)); f[400000]=0; for(int i=1;i&lt;=n;i++){ if(v[i]&gt;=0){ for(int j=800000;j&gt;=v[i];j--){ f[j]=max(f[j],f[j-v[i]]+w[i]); } } else{ for(int j=0;j&lt;=800000+v[i];j++){ f[j]=max(f[j],f[j-v[i]]+w[i]); } } } int ans=0; for(int i=400000;i&lt;=800000;i++) if(f[i]&gt;=0) ans=max(ans,f[i]+i-400000); cout&lt;&lt;ans; return 0;}","link":"/2019/05/07/luogu-p2340-e5-a5-b6-e7-89-9b-e4-bc-9a-e5-b1-95/"},{"title":" Luogu P3128 [USACO15DEC]最大流Max Flow\t\t","text":"[题目链接](https://www.luogu.org/problemnew/show/P3128) 这几天在学LCA，这道题使用了LCA+树上差分的思路。 题目描述，每经过一次的点就会加1，换言之，就是统计每一个节点经过了多少次，所以可以使用树上差分快速得到每个点经过的次数。 我们可以这样统计：如果x和y之间有一条路径，那么可以看做x-&gt;lca(x,y),lca(x,y)-&gt;y；两条路径各自分别加1，但是这样lca（x，y）会被加两遍，所以cnt\\[x\\]++,cnt\\[y\\]++,cnt\\[lca(x,y)\\]-=2。 但是这样一来，lca(u,v)上+2又-2等于0，也就是u—&gt;v整条路经上除了lca(u,v)都加了1，为了排除这个干扰，我们把cnt\\[lca(u,v)\\]-=2改成- -cnt\\[lca(u,v)\\],- -cnt\\[lca(u,v)的父亲\\] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;int tot,head[50009],n,m,s,d[50009],f[50009][20],t,lg[50009],cnt[50009];struct Edge{ int to,next;}e[100009];void add(int x,int y){ e[++tot].to=y; e[tot].next=head[x]; head[x]=tot;}void dfs(int y,int x){ d[y]=d[x]+1; f[y][0]=x; for(int i=1;(1&lt;&lt;i)&lt;=d[y];i++) f[y][i]=f[f[y][i-1]][i-1]; for(int i=head[y];i;i=e[i].next) if(e[i].to!=x) dfs(e[i].to,y);}void dfs_sum(int u,int fa){ for(int i=head[u];i;i=e[i].next){ int y=e[i].to; if(y==fa) continue; dfs_sum(y,u); cnt[u]+=cnt[y]; }}int lca(int x,int y){ if(d[x]&gt;d[y]) swap(x,y); while(d[x]&lt;d[y]) y=f[y][lg[d[y]-d[x]]-1]; if(x==y) return x; for(int i=lg[d[x]]-1;i&gt;=0;i--) if(f[x][i]!=f[y][i]) y=f[y][i],x=f[x][i]; return f[x][0];}int main(){ scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;n;i++){ int x,y; scanf(\"%d%d\",&amp;x,&amp;y); add(x,y); add(y,x); } for(int i=1;i&lt;=n;i++) lg[i]=lg[i-1]+(1&lt;&lt;lg[i-1]==i); dfs(1,0); for(int i=1;i&lt;=m;i++){ int x,y; scanf(\"%d%d\",&amp;x,&amp;y); int lcas=lca(x,y); cnt[x]++,cnt[y]++,cnt[lcas]--,cnt[f[lcas][0]]--; } dfs_sum(1,0); int maxn=0; for(int i=1;i&lt;=n;i++) maxn=max(maxn,cnt[i]); cout&lt;&lt;maxn; return 0;}","link":"/2019/03/09/luogu-p3128-usaco15dec-e6-9c-80-e5-a4-a7-e6-b5-81max-flow/"},{"title":" Luogu P3398 仓鼠找sugar\t\t","text":"Luogu P3398 仓鼠找sugar 题目描述小仓鼠的和他的基（mei）友（zi）sugar住在地下洞穴中，每个节点的编号为1~n。地下洞穴是一个树形结构。这一天小仓鼠打算从从他的卧室（a）到餐厅（b），而他的基友同时要从他的卧室（c）到图书馆（d）。他们都会走最短路径。现在小仓鼠希望知道，有没有可能在某个地方，可以碰到他的基友？ 小仓鼠那么弱，还要天天被zzq大爷虐，请你快来救救他吧！ 输入输出格式输入格式：第一行两个正整数n和q，表示这棵树节点的个数和询问的个数。 接下来n-1行，每行两个正整数u和v，表示节点u到节点v之间有一条边。 接下来q行，每行四个正整数a、b、c和d，表示节点编号，也就是一次询问，其意义如上。 输出格式：对于每个询问，如果有公共点，输出大写字母“Y”；否则输出“N”。 输入输出样例输入样例#1：5 5 2 5 4 2 1 3 1 4 5 1 5 1 2 2 1 4 4 1 3 4 3 1 1 5 3 5 1 4输出样例#1：Y N Y Y Y 思路：首先很容易想到，若是两条路径有相交，记$x=lca(a,b),y=lca(c,d)$那么一定有x在c\\\\~d上或者y在a\\\\~b上。 那如何判断一个点是否在一条路径上呢？不妨记x点是否在a\\\\~b上，那么若x在a\\\\~b上，则一定有 1. $x$的深度大于$lca(a,b)$的深度 2. $lca(a,x)==x$或者$lca(b,x)==x$ 综上，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;int head[100009],f[100009][20],d[100009],tot,n,m,t,lg[100009];queue&lt;int &gt; q;struct Edge{ int to,next;}e[2*100009];void add(int x,int y){ e[++tot].to=y; e[tot].next=head[x]; head[x]=tot;}void bfs(){ q.push(1),d[1]=1; while(!q.empty()){ int x=q.front();q.pop(); for(int i=head[x];i;i=e[i].next){ int y=e[i].to; if(d[y]) continue; d[y]=d[x]+1; f[y][0]=x; for(int j=1;(1&lt;&lt;j)&lt;=d[y];j++) f[y][j]=f[f[y][j-1]][j-1]; q.push(y); } }}int lca(int x,int y){ if(d[x]&gt;d[y]) swap(x,y); while(d[x]&lt;d[y]) y=f[y][lg[d[y]-d[x]]-1]; if(x==y) return x; for(int i=lg[d[x]]-1;i&gt;=0;i--) if(f[x][i]!=f[y][i]) y=f[y][i],x=f[x][i]; return f[x][0];}int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;n;i++){ int x,y; scanf(\"%d%d\",&amp;x,&amp;y); add(x,y),add(y,x); } for(int i=1;i&lt;=n;i++) lg[i]=lg[i-1]+(1&lt;&lt;lg[i-1]==i); bfs(); for(int i=1;i&lt;=m;i++){ int a,b,c,d1; scanf(\"%d%d%d%d\",&amp;a,&amp;b,&amp;c,&amp;d1); int x=lca(a,b),y=lca(c,d1); if(d[x]&lt;d[y]){ swap(x,y),swap(a,c),swap(b,d1); } if(lca(x,c)==x||lca(x,d1)==x) cout&lt;&lt;\"Y\"&lt;&lt;endl; else cout&lt;&lt;\"N\"&lt;&lt;endl; } return 0;}","link":"/2019/03/09/luogu-p3398-e4-bb-93-e9-bc-a0-e6-89-besugar/"},{"title":" Luogu P3469 [POI2008]BLO-Blockade\t\t","text":"[题目链接](https://www.luogu.org/problemnew/show/P3469 “题目链接”) 题目大意给定一张无向图，求每个点被封锁之后有多少个有序点对(x,y)(x!=y,1&lt;=x,y&lt;=n)满足x无法到达y。 输入第1行：N, M （1&lt;=N&lt;=100000, 1&lt;=M&lt;=500000） 第2~M+1行 X Y 表示X与Y中有一条边。 输出共N行，每行一个正整数代表如果去掉第i个点有多少个不能到大的点对。 代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int SIZE=500009;struct Edge{ int to,next;}e[2*SIZE];int head[100010],tot,num,dfn[100010],low[100010],n,m;ll ans[100009],size[100009];bool cut[100010];void add(int x,int y){ e[++tot].to=y; e[tot].next=head[x]; head[x]=tot;}void tarjan(int x){ dfn[x]=low[x]=++num; size[x]=1; int cnt=0; ll sum=0; for(int i=head[x];i;i=e[i].next){ int y=e[i].to; if(!dfn[y]){ tarjan(y); size[x]+=size[y]; low[x]=min(low[x],low[y]); if(low[y]&gt;=dfn[x]){ cnt++; ans[x]+=(ll)size[y]*(n-size[y]); sum+=size[y]; if(x!=1||cnt&gt;1) cut[x]=1; } } else low[x]=min(low[x],dfn[y]); } if(cut[x]){ ans[x]+=(n-sum-1)*(sum+1)+(n-1); } else ans[x]=2*(n-1);}int main(){ cin&gt;&gt;n&gt;&gt;m; tot=1; for(int i=1;i&lt;=m;i++){ int x,y; scanf(\"%d%d\",&amp;x,&amp;y); if(x==y) continue; add(x,y),add(y,x); } tarjan(1); for(int i=1;i&lt;=n;i++){ printf(\"%lld\\n\", ans[i]); } return 0;}","link":"/2019/03/12/luogu-p3469-poi2008blo-blockade/"},{"title":" Luogu P2733 家的范围\t\t","text":"[题目链接](https://www.luogu.org/problemnew/show/P2733 “题目链接”) 题目大意给定一个$n\\\\times n$的01矩阵，问其中所有由1组成的边长不同的正方形的数量。 输入6 101111 001111 111111 001111 101101 111001输出2 10 3 4 4 1 原来曾经做过一道题，用两个数组分别表示从一个点$(i,j)$向上、左走分别到达的第一个零的位置，这道题也能用。 - $l\\[i\\]\\[j\\]$表示从$(i,j)$点开始向左走，最长的1序列的长度。 - 同理，$u\\[i\\]\\[j\\]$表示从$(i,j)$点开始向上走，最长的1序列的长度。 - 理论复杂度$O(n^3)$ 详细解释看代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;int f[259],l[259][259],u[259][259],n;bool a[259][259];int main(){ cin&gt;&gt;n; string s; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;s; for(int j=1;j&lt;=n;j++){ a[i][j]=s[j-1]-'0'; if(a[i][j]) l[i][j]=u[i][j]=1; } } for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ if(a[i][j]) l[i][j]=max(l[i][j-1]+1,l[i][j]);//预处理l，u数组 if(a[i][j]) u[i][j]=max(u[i-1][j]+1,u[i][j]); } } int minx=0x3f3f3f3f,maxx=0,maxn=0; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ minx=0x3f3f3f3f; maxx=0;//maxx代表以（i，j）作为右下角的最大正方形的边长。 for(int k=i;i-k&lt;u[i][j];k--){ minx=min(minx,l[k][j]);//将minx更新为当前第k行至第i行最大矩阵的长。 if(min(minx,u[i][j])&gt;=2&amp;&amp;(i-k+1&lt;=min(minx,u[i][j]))) maxx=max(maxx,i-k+1); //如果当前边长大于二，并且当前宽小于等于长，就让maxx更新为最长边长的正方形。 } f[maxx]++;//以(i,j)为右下角的最大正方形的边长加一。 maxn=max(maxx,maxn); } } int t=0; for(int i=maxn;i&gt;1;i--){ f[i-1]+=f[i];//因为如果容纳一个边长为x的正方形，那一定可以容纳边长比i小的正方形。 } for(int i=2;i&lt;=n;i++){ if(f[i]) cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;f[i]&lt;&lt;endl; } return 0;}","link":"/2019/03/14/luogu-p2733-e5-ae-b6-e7-9a-84-e8-8c-83-e5-9b-b4/"},{"title":" Luogu P3916 图的遍历\t\t","text":"[题目链接](https://www.luogu.org/problemnew/show/P3916 “题目链接”) 又是一道神奇的题目，题目问从每个点能到达的编号最大的点，相当于一到多，这样可以建反向边，然后跑dfs。 每个点跑一遍dfs，从n到1循环。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,ans[100009];struct Edge{ int to,nxt;}e[100009];int head[100009],tot;void add(int x,int y){ e[++tot].to=y; e[tot].nxt=head[x]; head[x]=tot;}void dfs(int x,int fa){ if(ans[x]!=0) return; ans[x]=fa; for(int i=head[x];i;i=e[i].nxt){ int y=e[i].to; if(ans[y]==0) dfs(y,fa); }}int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++){ int x,y; cin&gt;&gt;x&gt;&gt;y; add(y,x); } for(int i=n;i&gt;=1;i--){ dfs(i,i); } for(int i=1;i&lt;=n;i++){ cout&lt;&lt;ans[i]&lt;&lt;\" \"; } return 0;}","link":"/2019/05/16/luogu-p3916-e5-9b-be-e7-9a-84-e9-81-8d-e5-8e-86/"},{"title":" Luogu P4677 山区建小学\t\t","text":"[题目链接](https://www.luogu.org/problemnew/show/P4677 “题目链接”) 这题做了一个小时，最后还是借鉴了题解······ 这题得开俩数组，$f\\[i\\]\\[j\\]$记录从i到j建一所学校的最小距离，然后$dp\\[i\\]\\[j\\]$就是前i个里面建j所学校的最小距离，状态转移方程： $dp\\[i\\]\\[j\\]=min(dp\\[i\\]\\[j\\],dp\\[k\\]\\[j-1\\]+f\\[k+1\\]\\[i\\])$ 然后$f\\[i\\]\\[j\\]=dis(k,mid)$(直觉我没有) 代码如下： 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,in[509],f[509][509],dp[509][509],a[509];int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;n;i++){ cin&gt;&gt;in[i];a[i+1]=a[i]+in[i]; } for(int k=1;k&lt;n;k++){ for(int l=1;l+k&lt;=n;l++){ int r=l+k; int mid=(l+r)/2; for(int p=l;p&lt;=r;p++) f[l][r]+=abs(a[mid]-a[p]); } } memset(dp,0x3f,sizeof(dp)); dp[0][0]=0; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ if(j&gt;i) { dp[i][j]=0; continue; } for(int k=j-1;k&lt;=i;k++){ dp[i][j]=min(dp[i][j],dp[k][j-1]+f[k+1][i]); } } } cout&lt;&lt;dp[n][m]; return 0;}","link":"/2019/04/21/luogu-p4677-e5-b1-b1-e5-8c-ba-e5-bb-ba-e5-b0-8f-e5-ad-a6/"},{"title":" Luogu P2948 [USACO09OPEN]滑雪课Ski Lessons\t\t","text":"[题目链接](https://www.luogu.org/problemnew/show/P2948 “题目链接”) 现在这蓝题都不好想啊qwq 设计状态：$f\\[i\\]\\[j\\]$表示到一门课程结束时间为$i$，能力值为$j$的最多滑雪次数。 所以先给课程按结束时间排个序。 转移： 1. $dp\\[x\\]\\[y\\]=max(dp\\[x\\]\\[y\\],dp\\[x2\\]\\[y2\\]+q)$，$q$是从上节课的结束时刻到这节课的开始时刻的最多滑雪次数。 2. $dp\\[x\\]\\[y2\\]=dp\\[x2\\]\\[y2\\]+(x-x2)/minn\\[y2\\]$，$minn\\[i\\]$是能力值为i时的最小滑雪时间； 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;int t,s,n;struct clas{ int begin,end; int v;}c[109];int a[10009][2],minn[10009];int f[10009][109];bool cmp(clas x,clas y){ return x.end&lt;y.end;}int main(){ cin&gt;&gt;t&gt;&gt;s&gt;&gt;n; memset(minn,0x3f,sizeof(minn)); for(int i=1;i&lt;=s;i++){ cin&gt;&gt;c[i].begin&gt;&gt;c[i].end&gt;&gt;c[i].v; c[i].end+=c[i].begin; } for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i][0]&gt;&gt;a[i][1]; minn[a[i][0]]=min(minn[a[i][0]],a[i][1]); } for(int i=1;i&lt;=100;i++) minn[i]=min(minn[i],minn[i-1]); sort(c+1,c+s+1,cmp); c[0].v=1,c[0].begin=0,c[0].end=0; for(int i=0;i&lt;=s;i++){ for(int j=0;j&lt;i;j++){ int ti1=c[i].end,v1=c[i].v; int ti2=c[j].end,v2=c[j].v; if(ti2&lt;c[i].begin) f[ti1][v1]=max(f[ti1][v1],f[ti2][v2]+(c[i].begin-ti2)/minn[v2]); f[ti1][v2]=max(f[ti1][v2],f[ti2][v2]+(ti1-ti2)/minn[v2]); } } for(int i=0;i&lt;=s;i++){ int ti=c[i].end,v=c[i].v; f[t][v]=max(f[t][v],f[ti][v]+(t-ti)/minn[v]); } int ans=0; for(int i=0;i&lt;=s;i++) ans=max(ans,f[t][c[i].v]); cout&lt;&lt;ans; return 0;}","link":"/2019/06/01/luogu-p2948-usaco09open-e6-bb-91-e9-9b-aa-e8-af-beski-lessons/"},{"title":" OI之路——崔肇峰\t\t","text":"OI之路——崔肇峰 OI 就像状态转移方程，由一个阶段转移到另一个阶段，但是， 不同的是，我们不知道下一个状态是什么。有时候坚定信念，有时候会感到迷茫 看着深夜微微发亮的屏幕，还有满屏的WA,当已经没信心的时候，告诉自己，已经结束了，现在是倒叙， 当不想学数论向量要崩溃的时候，告诉自己，已经考完了，没考上，许个愿给自己一个机会穿越回过去， 睁开眼睛愿望是实现了，代码就在眼前。 我作为一个信息竞赛生，对于现在网上对于信息竞赛的情况各有其词， 一些记者公众号为了吸引人的眼球而夸大一些事实，实在让人气愤。 对于我而言，确实一开始选择信息竞赛是出于一些功利的目的，虽然只有小小的热爱，却也不报希望， 清北以及顶尖院校的营地及自主招生简章中对于学科竞赛都有明确要求， 而且仔细读招生简章其实并不是对竞赛的打击，而是对一门学科的从高中开始的人才培养。 随着学习的深入，我心里的动力逐渐由功利转向对信息学的喜爱。 主席树，红黑树，平衡树，可持久化动态仙人掌，上下界最小费用流等等等等， 这些在noip联赛考点中并没有要求，但我依然去学习，出发点便是热爱。 信息竞赛的学习，丰富了我的知识，对于信息学有了更深刻的理解，对于一切的发展，都有了明确的打算。 或许在一些人看来，竞赛就是在走捷径，是“权贵”的游戏，但我想，对于一名真正的竞赛生而言，竞赛，或者说那一个 学科已经是生命中不可分割的一部分。 去qbxt，感受全国各地的OIer实力与风采，同时提升了自己的实力，慢慢地从只会看题解，到自己独自切掉一个题， AC的时候，那种喜悦感，常人根本无法理解。qbxt的老师学长们不同的讲课风格，只感觉能和一群与自己有相同爱好 的人在一起，真好；斜率优化，四边形不等式，凸包优化，轮廓线优化让我感受到信息学中数学的魅力；每年学长们 的励志小企鹅，还有一次次的祝福rp++，很让人感动。记忆很深的是一次中秋节校内集训，很强的一位学长给我们做 考前辅导，不过毕竟高一一群萌新，还是有一些恐惧以及胆小，不过，这位学长见我们的第一面，竟然是：泥萌要吃 月饼吗？从此以后，不在害怕与畏惧这个陌生的学校，只感到温暖。想起这一幕幕，不觉泪目。 这是我们的故事啊，其实还是挺惆怅的。一届一届的学长毕业，留下的不只是码风，更有传统。 一种不放弃，不服气，考跪了自己菜，就是这样； 在逆境中自我学习，在山西这样的弱省，在NOI中留下一席之地； 在比赛结束前，调试代码； 认真做好每一件小事，认真地写好每一个函数，每一句话； 以及，不畏惧一切。 “实中能搞个屁的信竞” “实中信息一年不如一年了” “在实中就毁了” “就算省队7个真的挤出来两个你中奖的概率又有多少” 我们在这一年里，在这样的声音里走过，顶着对手巨大的压力，最后走出了实中信息竞赛的一条路，选择实中并没有错，我们始终坚定着，对于自己选择的路，就是跪着，也要走下去！ 以上 ————实中OI队.崔肇峰","link":"/2019/05/06/oi-e4-b9-8b-e8-b7-af-e5-b4-94-e8-82-87-e5-b3-b0/"},{"title":" P1799 数列_NOI导刊2010提高（06）\t\t","text":"[题目链接](https://www.luogu.org/problemnew/show/P1799 “题目链接”) 设计状态:$f\\[i\\]\\[j\\]$表示在前i个数字当中，删掉j个能得到符合$a_i=i$情况的最大值。 设计状态转移: 如果要删第$i$个，$f\\[i\\]\\[j\\]=f\\[i-1\\]\\[j-1\\]$ 如果不删第$i$个： 如果$a\\_i=i-j$(前面删掉$j$个刚好使$a\\_i$满足条件)，$f\\[i\\]\\[j\\]=max(f\\[i\\]\\[j\\],f\\[i-1\\]\\[j\\]+1)$。 否则，$f\\[i\\]\\[j\\]=max(f\\[i\\]\\[j\\],f\\[i-1\\]\\[j\\])$。 代码1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;int n,a[1009],f[1009][1009];int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; } for(int i=1;i&lt;=n;i++){ if(a[i]==i) f[i][0]=f[i-1][0]+1; else f[i][0]=f[i-1][0]; } for(int i=1;i&lt;=n;i++){ for(int j=0;j&lt;i;j++){ f[i][j]=f[i-1][j-1]; if(a[i]!=i-j) f[i][j]=max(f[i][j],f[i-1][j]); else f[i][j]=max(f[i][j],f[i-1][j]+1); } } int maxn=0; for(int i=1;i&lt;n;i++){ maxn=max(maxn,f[n][i]); } cout&lt;&lt;maxn; return 0;}","link":"/2019/03/17/p1799-e6-95-b0-e5-88-97-noi-e5-af-bc-e5-88-8a2010-e6-8f-90-e9-ab-98-ef-bc-8806-ef-bc-89/"},{"title":" Tarjan求割点\t\t","text":"Tarjan求割点 割点判定法则 若x不是搜索树的根节点，则x是割点当且仅当搜索树上存在一个x的子节点y，满足：$dfn\\[x\\]\\\\leq low\\[y\\]$。 特别的，若x是搜索树的根节点，则x是割点当且仅当搜索树上至少存在两个子节点$y\\_1,y\\_2$满足此条件。 证明方法与求桥雷同。 因为判定是小于等于，所以求割点时，无需考虑父节点和重边的问题，从x出发访问的所有时间戳均可更新$low\\[x\\]$。 代码如下：#include&lt;bits/stdc++.h&gt; using namespace std; const int SIZE=100010; struct Edge{ int to,next; }e[SIZE*2]; int head[SIZE],n,m,tot,dfn[SIZE],low[SIZE],num,root,cnnt=0; bool u[SIZE]; void add(int x,int y){ e[++tot].to=y; e[tot].next=head[x]; head[x]=tot; } void tarjan(int x){ dfn[x] = low[x] = ++num; int cnt = 0; for(int i=head[x];i;i=e[i].next){ int y=e[i].to; if(!dfn[y]){ tarjan(y); low[x] = min(low[x], low[y]); if (low[y] &gt;= dfn[x]) { cnt++; if (x != root || cnt &gt; 1) u[x]=true; } } else low[x] = min(low[x], dfn[y]); } } int main(){ cin&gt;&gt;n&gt;&gt;m; tot=1; for(int i=1;i&lt;=m;i++){ int x,y; cin&gt;&gt;x&gt;&gt;y; if(x==y) continue; add(x,y),add(y,x); } for(int i=1;i&lt;=n;i++){ if(!dfn[i]) { root=i; tarjan(i); } } cnnt=0; for(int i=1;i&lt;=n;i++){ if(u[i]) cnnt++; } cout&lt;&lt;cnnt&lt;&lt;endl; for(int i=1;i&lt;=n;i++){ if(u[i]) cout&lt;&lt;i&lt;&lt;&quot; &quot;; } return 0; }","link":"/2019/03/12/tarjan-e6-b1-82-e5-89-b2-e7-82-b9/"},{"title":" P2331 [SCOI2005]最大子矩阵\t\t","text":"P2331 [SCOI2005]最大子矩阵 题目描述这里有一个n*m的矩阵，请你选出其中k个子矩阵，使得这个k个子矩阵分值之和最大。注意：选出的k个子矩阵不能相互重叠。 输入输出格式输入格式：第一行为n,m,k（1≤n≤100,1≤m≤2,1≤k≤10），接下来n行描述矩阵每行中的每个元素的分值(每个元素的分值的绝对值不超过32767)。 输出格式：只有一行为k个子矩阵分值之和最大为多少。 [题目链接](https://www.luogu.org/problemnew/show/P2331 “题目链接”) 思路 首先，可以注意到，m只能为1或2，那不妨分情况讨论。 当m=1时，可以发现答案即最大连续字段和，设计状态$dp(i,j)$表示从前i个元素里选择j个矩形的最大和，因此状态转移方程： 若选，$dp(i,j)=max(dp(len,j-1)+sum\\[i\\]-sum\\[j-1\\])$ 若不选，$dp(i,j)=max(dp(i,j),dp(i-1,j))$ 当m=2时，$dp(i,j,k)$表示第一列前i个元素，第二列前j个元素，一共选择k个矩阵所得的最大值，因此状态转移方程分四种情况： 当两列均不选时：$dp(i,j,k)=max(dp(i,j-1,k),dp(i-1,j,k))$ 当只选择第一列时，$dp(i,j,k)=max(dp(len,j,k-1)+sum\\_1\\[i\\]-sum\\_1\\[len-1\\]),len\\\\in\\[1,i)$ 当只选择第二列时，$dp(i,j,k)=max(dp(i,len,k-1)+sum\\_2\\[j\\]-sum\\_2\\[len-1\\]),len\\\\in\\[1,j)$ 当$i=j$时，两列都选，$dp(i,j,k)=max(dp(len,len,k-1)+sum\\_1\\[i\\]-sum\\_1\\[len-1\\]+sum\\_2\\[j\\]-sum\\_2\\[len-1\\])$ **最后这四种情况取最大值。** 代码如下：#include&lt;bits/stdc++.h&gt; using namespace std; int n,m,k; int sum1[109],sum2[109],dp1[109][15],f[109][109][15]; int main(){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; if(m==1){ for(int i=1;i&lt;=n;i++){ int x; cin&gt;&gt;x; sum1[i]=sum1[i-1]+x; } for(int len=1;len&lt;=k;len++){ for(int i=1;i&lt;=n;i++){ dp1[i][len]=dp1[i-1][len]; for(int j=0;j&lt;i;j++){ dp1[i][len]=max(dp1[i][len],dp1[j][len-1]+sum1[i]-sum1[j]); } } } cout&lt;&lt;dp1[n][k]; } else{ for(int i=1;i&lt;=n;i++){ cin&gt;&gt;sum1[i]&gt;&gt;sum2[i]; sum1[i]+=sum1[i-1]; sum2[i]+=sum2[i-1]; } for(int len=1;len&lt;=k;len++){ for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ f[i][j][len]=max(f[i-1][j][len],f[i][j-1][len]); for(int l=0;l&lt;i;l++) f[i][j][len]=max(f[i][j][len],f[l][j][len-1]+sum1[i]-sum1[l]); for(int l=0;l&lt;j;l++) f[i][j][len]=max(f[i][j][len],f[i][l][len-1]+sum2[j]-sum2[l]); if(i==j) for(int l=0;l&lt;i;l++) f[i][j][len]=max(f[i][j][len],f[l][l][len-1]+sum1[i]-sum1[l]+sum2[j]-sum2[l]); } } } cout&lt;&lt;f[n][n][k]; } return 0; }","link":"/2019/03/11/p2331-scoi2005-e6-9c-80-e5-a4-a7-e5-ad-90-e7-9f-a9-e9-98-b5/"},{"title":" Tarjan求割边、桥\t\t","text":"Tarjan求割点、桥 割边判定法则 无向边$(x,y)$是桥，当且仅当搜索树上x的子节点y，满足$dfn\\[x\\] &lt; low\\[y\\]$。 **桥一定是搜索树上的边**，并且**一个简单环中的边一定不是桥！** 求出一个无向图中所有的桥： #include&lt;bits/stdc++.h&gt; using namespace std; const int SIZE=100009; struct Edge{ int to,next; }e[SIZE*2]; int head[SIZE],dfn[SIZE],low[SIZE],n,m,tot,num; bool bridge[SIZE*2]; void add(int x,int y){ e[++tot].to=y; e[tot].next=head[x]; head[x]=tot; } void tarjan(int x,int in_edge){ dfn[x]=low[x]=++num; for(int i=head[x];i;i=e[i].next){ int y=e[i].to; if(!dfn[y]){ tarjan(y,i); low[x]=min(low[x],low[y]); if(low[y]&gt;dfn[x]) bridge[i]=bridge[i^1]=1; } else if(i!=(in_edge^1)){ low[x]=min(low[x],dfn[y]); } } } int main(){ cin&gt;&gt;n&gt;&gt;m; tot=1;//一定要从2开始存边！！！ for(int i=1;i&lt;=m;i++){ int x,y; cin&gt;&gt;x&gt;&gt;y; add(x,y),add(y,x); } for(int i=1;i&lt;=n;i++){ if(!dfn[i]) tarjan(i,0);//因为不一定是连通图。 } for(int i=2;i&lt;tot;i+=2){ if(bridge[i]) cout&lt;&lt;e[i].to&lt;&lt;&quot; &quot;&lt;&lt;e[i^1].to&lt;&lt;endl; } return 0; }","link":"/2019/03/12/tarjan-e6-b1-82-e5-89-b2-e8-be-b9-e3-80-81-e6-a1-a5/"},{"title":"清北学堂noip2019-D0","text":"济南清北学堂游记 Day0 下午1:59的火车，火车上部署了一下hexo blog，搞了一下SEO，结果还是网太慢。。。没搞成 然后某位同学居然去了另外一个酒店。。。（貌似因为距离大明湖太远？或者我觉得可能只是个借口，反正都这样了，就自己住呗。 我嫌一个人住太贵，想找个人拼一个标间，于是碰到一位人大附的初二巨佬。。。吊打我八千里开外%%%，然后你们就有了这篇文章。 准备一会直接洗漱睡了，Day0就这样。","link":"/2019/07/12/清北学堂noip2019-D0/"},{"title":"数位DP 学习笔记","text":"数位dp基本模型，给定闭区间$[l,r]$，求这个闭区间中满足题目要求的数的个数。 我们可以从数字的每一位来枚举，从高位向低位枚举，我们可以用 dp[i][j] 来表示枚举到 i 位时，数字为 j 时的方案数（答案数）。但是我们需要考虑一些限制我们决策的条件，假设我们要求小于等于 243 的数字中符合条件的有几个： 当我们第一项为 1 时，我们后面一位可以枚举 0∼9 当我们第一项为 2 时，我们后面一项就只能枚举 0∼4 可见我们需要通过判断前一项来决定后一项最高可以取值的大小。同时我们也需要考虑一些数字前面一直是 0，并且会影响答案的情况（例如统计各个数字出现的次数）。以下是模板： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;#define N 20int dp[N][N], a[N], n, m;// 数位 dp 是需要深搜的，`dp` 数组只是做记忆化搜索用int dfs(int pos, int pre, bool limit, bool frontzero) { // `frontzero`: 前导 0 的判断 // `pre`: `pos` 前一位的数字 if (pos == 0) return 1; // 枚举完毕，退出 if (!frontzero &amp;&amp; !limit &amp;&amp; dp[pos][pre] != -1) return dp[pos][pre]; // 返回 `dp[pos][pre]` 的条件：前导非零 且 无上限限制 且 `dp` 数组的这一位有值 // 注意这里必须把 `!frontzero` 和 `!limit` 写在前面 来防止 `dp` 数组越界 // 因为后面需要在前导零的时候做一点操作 int p, ret = 0; int up = limit ? a[pos] : 9; for (int i = 0; i &lt;= up; ++i) { if () continue; // 当枚举到的这一位不符合条件时就忽略，继续枚举 p = i; if (frontzero &amp;&amp; i == 0) p = -INF; // 这里 `-INF` 只是一个前导 0 的标记，数值并没有太大意义。 ret += dfs(pos - 1, p, limit &amp; (i == up), (p == -INF)); // 这里 `p = -INF` 时也是会传进函数作为 `pre` 参数的， // 所以前面要把 `frontzero` 写前面 } if (!frontzero &amp;&amp; !limit) f[pos][pre] = ret; return ret;}int solve(int x) { // `solve(x)`: 处理不大于 `x` 的数的答案 int idx = 0; while (x) { a[++idx] = x % 10; x /= 10; } // 预处理 `x` 的每一位 memset(dp, -1, sizeof(dp)); return dfs(idx, -INF, 1, 1); // 注意初始化}int main() { cin &gt;&gt; n &gt;&gt; m; cout &lt;&lt; (solve(m) - solve(n - 1)); return 0;} [windy数](https://www.luogu.org/problem/P2657) 题意：给定一个区间$[l,r]$，求其中满足条件 不含前导$0$且相邻两个数字相差至少为$2$的数字个数。 按照模板写就行了 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;int dp[15][15], a[15];int dfs(int pos, int pre, bool limit, bool frontzero){ if(pos == 0) return 1; if(!limit &amp;&amp; !frontzero &amp;&amp; dp[pos][pre] != -1) return dp[pos][pre]; int ret = 0; int up = (limit ? a[pos] : 9); for(int i = 0; i &lt;= up; i++){ if(abs(i - pre) &lt; 2) continue; int p = i; if(frontzero &amp;&amp; i == 0) p = -INF; ret += dfs(pos - 1, p, limit &amp; (i == up), (p == -INF)); } if(!frontzero &amp;&amp; !limit) dp[pos][pre] = ret; return ret;}int solve(int x){ int idx = 0; while(x){ a[++idx] = x % 10; x /= 10; } memset(dp, -1, sizeof(dp)); return dfs(idx, -INF, 1, 1);}int main(){ int a, b; scanf(\"%d%d\", &amp;a, &amp;b); printf(\"%d\\n\", solve(b) - solve(a - 1)); return 0;} [杠杆数](https://www.luogu.org/problem/P1831) 我看到这道题的时候通过数据范围判断它应该是数位dp，但是我不知道以哪一位为支点计算那些怎么做，也是因为这道题才学的数位dp。 发现正常的模板搜索第二个变量保存了上一个数是几，但是这个题不能这么算，所以就对于一个1道n的统计，枚举一下支点，然后记录一下支点位置和到当前的和，额。。。我不知道自己说了什么，看注释吧。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll dp[20][20][3009], a[20];ll dfs(int pos, int x, ll s, bool limit, bool frontzero){ if(pos == 0) return (!frontzero &amp;&amp; s == 0); //然后返回1的条件就是和为0（满足平衡） //并且不能是0. if(!limit &amp;&amp; !frontzero &amp;&amp; dp[x][pos][s] != -1) return dp[x][pos][s]; int up = (limit ? a[pos] : 9); ll ret = 0; for(int i = 0; i &lt;= up; i++){ ret += dfs(pos-1, x, s+(1ll*i*(pos-x)), limit &amp; (i == up), frontzero&amp;(i==0)); //这里就是转移。。。 } if(!limit &amp;&amp; !frontzero) dp[x][pos][s] = ret; return ret;}ll solve(ll x){ int idx = 0; while(x){ a[++idx] = x % 10; x /= 10; } memset(dp, -1, sizeof(dp)); ll ans = 0; //就这个地方，枚举一下支点位置。 for(int i = 1; i &lt;= idx; i++){ ans += dfs(idx, i, 0ll, 1, 1); } return ans;}int main(){ ll a, b; scanf(\"%lld%lld\", &amp;a, &amp;b); printf(\"%lld\", solve(b) - solve(a - 1)); return 0;}","link":"/2019/07/29/数位dp-学习笔记/"},{"title":"数论 学习笔记","text":"OI Wiki了解一下 最大公约数1234int gcd(int a, int b){ if(b == 0) return a; return gcd(b, a % b);} 裴蜀定理（贝祖定理） 设$a,b$是不全为零的整数，则存在整数$x,y$, 使得$ax+by=gcd(a,b)$. 扩展欧几里得 用于求解方程$ax+by=gcd(a,b)$ 代码：123456789int exgcd(int a, int b, int &amp;x, int &amp;y){ if(b == 0){ y = 0, x = 1; return a; } int r = exgcd(b, a % b, y, x); y -= a / b * x; return r;} 乘法逆元如果一个线性同余方程$ax\\equiv 1(mod\\ b)$，则$x$称为$a\\mod b$的逆元，记作$a^{-1}$。 求解a的逆元扩展欧几里得法 扩展欧几里得法和求解线性同余方程是一个原理，在这里不展开解释。 快速幂法 因为$ax\\equiv 1(mod\\ b)$ 所以$ax\\equiv a^{b-1}(mod\\ b)$ 所以$x\\equiv a^{b-2}(mod\\ b)$ 然后就可以用快速幂求了 线性求任意n个数的逆元首先计算$n$个数的前缀积$s_i$，然后用快速幂法求$s_n$的逆元，记为$sv_n$。 因为$sv_n$是前$n$个数的积的逆元，所以这个数乘$a_i$，会和其逆元抵消，于是就得到了$a_1$到$a_{n-1}$的积逆元，记为$sv_{n-1}$。 然后就能计算出所有$sv_i$，$a_i$的逆元就可以由$s_{i-1}\\times sv_i$求得。 时间复杂度：$O(n+log\\ p)$ 123456s[0] = 1;for (int i = 1; i &lt;= n; ++i) s[i] = s[i - 1] * a[i] % p;sv[n] = qpow(s[n], p - 2);// 当然这里也可以用 exgcd 来求逆元,视个人喜好而定.for (int i = n; i &gt;= 1; --i) sv[i - 1] = sv[i] * a[i] % p;for (int i = 1; i &lt;= n; ++i) inv[i] = sv[i] * s[i - 1] % p; P.S.刚刚我做了两道例题，现在感觉。。。脑子一片浆糊。😭 中国剩余定理（孙子定理）「物不知数」问题 有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？ $$\\left\\{ \\begin{array}{ccc} x &amp;\\equiv&amp; a_1 \\pmod{m_1}\\\\\\ x &amp;\\equiv&amp; a_2 \\pmod{m_2}\\\\\\ &amp;\\vdots&amp;\\\\\\ x &amp;\\equiv&amp; a_n \\pmod{m_n} \\end{array}\\right.$$ 求解方法： 设$M=\\prod_{i=1}^{n}m_i$，并设$M_i=M/m_i$。 设$t_i=M_i^{-1}$为$M_i$模$m_i$的数论倒数。 方程组的通解形式在模$M$的意义下有唯一解$x=\\sum_{i=1}^na_it_iM_i$ 扩展中国剩余定理（exCRT） 考虑模数不互质的情况。 如果只有两个方程 设它们为$x\\equiv a_1\\pmod{m_1}$和$x\\equiv a_2\\pmod{m_2}$ 转化为$x=m_1p+a_1=m_2q+a_2$，其中$p,q$为整数，则有$m_1p-m_2q=a_2-a_1$ 由于裴蜀定理，若该式求出一组解$(p,q)$，则原来方程组解为$x\\equiv b\\pmod{M}$，其中$b=m_1p+a_1$，$M=lcm(m_1,m_2)$。 考虑多个方程：按照上述方法两两合并即可。 [【模板】扩展中国剩余定理](https://www.luogu.org/problemnew/show/P4777) [屠龙勇士](https://www.luogu.org/problemnew/show/P4774)","link":"/2019/07/30/数论-学习笔记/"},{"title":"清北学堂noip2019-Day4","text":"图论 Boruvka算法求最小生成树 每次对每个当前的连通分量都找到连出的最短边，尝试一同加入。 此算法的正确性证明与Prim 算法类似，可以看作并行的Prim. 而且更好的性质是，如果这些最短边两两不同，一定是 可以加入的（若有环，环上最大边根本不会被选！）。加入完后新一轮缩点即可。 边权相同的情况用一些方法破环，比如权相同时选序号最小的。 期望复杂度线性，优于普通Prim、堆优化Prim、Kruskal（注意是大大优于Kruskal，因为Kruskal 瓶颈是排序而不是并查集，后者可视作线性）。 最坏复杂度与Kruskal 同阶。 k短路，k小生成树 以上理论算法的拓展较多，如次小生成树、次短路乃至更一般的k 短路、k 小生成树，这方面可以详见俞鼎力的国家集训队论文，有比较系统的整理。 经典题型2-SAT 婚礼问题 n对未婚夫妻想举行婚礼，每对有两个可供选择的时间，一个司仪能否参与所有婚礼？ 本题甚至不需要利用时间的连续性质，直接把这道特殊题转化为一般情况，任意给定每两对夫妻的两个时段的冲突情况也可解决。 每一对未婚夫妻拆点，不妨记为i1 和i2，那么i1 和j1冲突就意味着i1 必选j2，j1 必选i2，因此由i1 向j2 连边，j1 向i2 连边。 每对必须选且仅选一个，且选了一个点必须选它的后继。 容易想到按照拓扑序贪心，但为了得到拓扑序必须先求强连通分量缩点。 若某对夫妻的两点在同一个强连通分量中显然无解。逆拓扑序选点即可，每选一个点立刻删除该对夫妻另一个点，并递归删除前驱。 由于原图的对称性，缩点后仍然对称，因此这种贪心的正确性易证。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;int n, m;struct Edge{ int to, nxt;}e[4000009];int head[2000009], tot;int dfn[2000009], low[2000009], Time, color[2000009], group;bool vis[2000009];void add(int x, int y){ e[++tot].to = y; e[tot].nxt = head[x]; head[x] = tot;}stack&lt;int&gt; st;void tarjan(int x){ low[x] = dfn[x] = ++Time; vis[x] = 1; st.push(x); for(int i = head[x]; i; i = e[i].nxt){ int y = e[i].to; if(!dfn[y]){ tarjan(y); low[x] = min(low[x], low[y]); } else if(vis[y]){ low[x] = min(low[x], dfn[y]); } } if(dfn[x] == low[x]){ group++; while(st.top() != x &amp;&amp; !st.empty()){ int q = st.top(); st.pop(); color[q] = group; vis[q] = 0; } color[st.top()] = group; vis[x] = 0; st.pop(); }}int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++){ int x, xv, y, yv; scanf(\"%d%d%d%d\", &amp;x, &amp;xv, &amp;y, &amp;yv); add(x + !xv * n, y + yv * n); add(y + !yv * n, x + xv * n); } for(int i = 1; i &lt;= 2 * n; i++){ if(!dfn[i]) tarjan(i); } for(int i = 1; i &lt;= n; i++){ if(color[i] == color[i + n]){ printf(\"IMPOSSIBLE\\n\"); return 0; } } printf(\"POSSIBLE\\n\"); for(int i = 1; i &lt;= n; i++){ printf(\"%d \", color[i] &gt; color[i + n]); } return 0;} 带锁最短路 钥匙路径 图的一些边上有锁，共有k 类锁（k 非常小，10 以内），一些边上有钥匙，每种钥匙对应一种锁，求最短路。 显然手上的钥匙不同能走的路径截然不同，应该把不同的手上钥匙状态视为不同状态。 用d[i][j] 表示钥匙状态为j 时走到点i 的最短距离，j 需要记录所有种类钥匙的有无。 此类问题容易遇到转移顺序的问题，所幸本题中钥匙只可能越来越多不可能变少，按钥匙数从少到多处理当前钥匙状态到所有点的距离即可，相同钥匙数更新顺序任意，注意计算时不仅要更新本层还要给钥匙数更多的状态提前更新“初始值”。","link":"/2019/07/16/清北学堂noip2019-Day4/"},{"title":"清北学堂noip2019-Day6","text":"数论 lcm，gcd性质 $gcd(a,b)=gcd(b,a mod b)$ $lcm(a,b)= \\frac{ab}{gcd(a,b)}$ $$lcm(S)=\\prod_{T\\subset S}gcd(T)^{(-1)^{|T|+1}}$$ $gcd(Fib(a),Fib(b))=Fib(gcd(a,b))$ $gcd(x^a-1,x^b-1)=x^{gcd(a,b)}-1$ problem 1 求$$\\sum_{i=1}^n(\\lfloor \\frac{n}{i} \\rfloor)^3 \\times i$$ $n\\leq 10^9$ problem 2 求$$\\sum_{1\\leq a,b\\leq n}gcd(x^a-1,x^b-1)$$$x,n\\leq 10^5,300组数据$ 推导 $$ans=\\sum_{1\\leq a,b\\leq n}(x^{gcda,b}-1)$$ $$=\\sum_{k=1}^n(x^k-1)]\\sum_{a\\leq a,b\\leq n}[gcd(a,b)=k]$$ $$=\\sum_{k=1}^n(x^k-1)(2\\sum_{i=1}^{\\lfloor n/k\\rfloor}\\varphi(i)-1)$$ 费马小定理 若p是一个","link":"/2019/07/18/清北学堂noip2019-Day6/"},{"title":"树链剖分 学习笔记","text":"这就是传说中的树链剖分？ 树链剖分可以将一棵树的任意一条路径划分成不超过$O(\\log n)$条链，并且满足dfs序，反正就很好啦，维护线段树什么的。。。 还可以$O(\\log n)$求$lca$，常数小什么的。 树链剖分定义 定义**重子节点**表示其子节点中子树最大的子结点。如果有相同的，任意取。如果没有子节点，就没有。 **轻子节点**就是剩余的其他子节点。 这个节点到重子节点的边叫做**重边**，其他叫做**轻边**。 把若干条首尾相连的重边称为**重链**。 把单独的节点也当成重链，就把整棵树分成了若干条链。如图：![树链剖分1](/img/树链剖分1.png) 实现 分两个dfs实现： 第一个dfs记录一下子树大小和深度。 记录重子节点，dfs序，当前节点的链顶。 代码实现12345678910111213141516171819202122void dfs1(int o, int fat) { son[o] = -1; siz[o] = 1; for (int j = h[o]; j; j = nxt[j]) if (!dep[p[j]]) { dep[p[j]] = dep[o] + 1; fa[p[j]] = o; dfs1(p[j], o); siz[o] += siz[p[j]]; if (son[o] == -1 || siz[p[j]] &gt; siz[son[o]]) son[o] = p[j]; }}void dfs2(int o, int t) { top[o] = t; cnt++; tid[o] = cnt; rnk[cnt] = o; if (son[o] == -1) return; dfs2(son[o], t); //优先对重儿子进行dfs，可以保证同一条重链上的点时间戳连续 for (int j = h[o]; j; j = nxt[j]) if (p[j] != son[o] &amp;&amp; p[j] != fa[o]) dfs2(p[j], p[j]);} 模板 [【模板】树链剖分](https://www.luogu.org/problem/P3384)(这应该算树套树了吧qwq) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include&lt;bits/stdc++.h&gt;using namespace std;int n, m, r, p;int v[200009];struct Edge{ int to, nxt;}e[400009];int head[200009], tot;int size[200009], dep[200009], fat[200009];int dfn[200009], top[200009], id[200009];int son[200009];//----------------------------------------------int tree[800009], tag[800009];//----------------------------------------------void add(int x, int y){ e[++tot].to = y; e[tot].nxt = head[x]; head[x] = tot;}void dfs1(int x, int fa, int d){ fat[x] = fa; dep[x] = d; size[x] = 1; int maxx = -1; for(int i = head[x]; i; i = e[i].nxt){ int y = e[i].to; if(y == fa) continue; dfs1(y, x, d + 1); size[x] += size[y]; if(size[y]&gt;maxx) son[x] = y, maxx = size[y]; }}int cnt = 0;void dfs2(int x, int topp){ dfn[x] = ++cnt; id[cnt] = x; top[x] = topp; if(!son[x]) return; dfs2(son[x], topp); for(int i = head[x]; i; i = e[i].nxt){ int y = e[i].to; if(y == son[x] || y == fat[x]) continue; dfs2(y, y); }}//-----------------------------------------void build(int k, int l, int r){ if(l == r){ tree[k] = v[id[l]] % p; return; } int mid = (l + r) / 2; build(k * 2, l, mid); build(k * 2 + 1, mid + 1, r); tree[k] = (tree[k * 2] + tree[k * 2 + 1]) % p; return;}void Add(int k, int l, int r, int w){ tag[k] += w; tree[k] += w * (r - l + 1); tree[k] %= p; return;}void pushdown(int k, int l, int r){ int mid = (l + r) / 2; Add(k * 2, l, mid, tag[k]); Add(k * 2 + 1, mid + 1, r, tag[k]); tag[k] = 0;}void modify(int k, int l, int r, int x, int y, int w){ if(l &gt;= x &amp;&amp; r &lt;= y){ Add(k, l, r, w); return; } pushdown(k, l, r); int mid = (l + r) / 2; if(mid &gt;= x) modify(k * 2, l, mid, x, y, w); if(mid &lt; y) modify(k * 2 + 1, mid + 1, r, x, y, w); tree[k] = (tree[k * 2] + tree[k * 2 + 1]) % p;}int query(int k, int l, int r, int x, int y){ if(l &gt;= x &amp;&amp; r &lt;= y){ return tree[k] % p; } pushdown(k, l, r); int mid = (l + r) / 2; int res = 0; if(mid &gt;= x) res = (res + query(k * 2, l, mid, x, y)) % p; if(mid &lt; y) res = (res + query(k * 2 + 1, mid + 1, r, x, y)) % p; return res;}//---------------------------------------------void modify_tree(int x, int y, int w){ w %= p; while(top[x] != top[y]){ if(dep[top[x]] &lt; dep[top[y]]) swap(x, y); modify(1, 1, n, dfn[top[x]], dfn[x], w); x = fat[top[x]]; } if(dep[x] &gt; dep[y]) swap(x, y); modify(1, 1, n, dfn[x], dfn[y], w); return;}int query_tree(int x, int y){ int res = 0; while(top[x] != top[y]){ if(dep[top[x]] &lt; dep[top[y]]) swap(x, y); res += query(1, 1, n, dfn[top[x]], dfn[x]); res %= p; x = fat[top[x]]; } if(dep[x] &gt; dep[y]) swap(x, y); res = (res + query(1, 1, n, dfn[x], dfn[y])) % p; return res;}int main(){ scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;r, &amp;p); for(int i = 1; i &lt;= n; i++){ scanf(\"%d\", &amp;v[i]); } for(int i = 1; i &lt;= n - 1; i++){ int x, y; scanf(\"%d%d\", &amp;x, &amp;y); add(x, y), add(y, x); } dfs1(r, -1, 1); dfs2(r, r); build(1, 1, n); for(int i = 1; i &lt;= m; i++){ int op, x, y, w; scanf(\"%d\", &amp;op); if(op == 1){ scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;w); modify_tree(x, y, w); } if(op == 2){ scanf(\"%d%d\", &amp;x, &amp;y); printf(\"%d\\n\", query_tree(x, y)); } if(op == 3){ scanf(\"%d%d\", &amp;x, &amp;w); modify(1, 1, n, dfn[x], dfn[x] + size[x] - 1, w); } if(op == 4){ scanf(\"%d\", &amp;x); printf(\"%d\\n\", query(1, 1, n, dfn[x], dfn[x] + size[x] - 1)); } } return 0;}","link":"/2019/08/02/树链剖分-学习笔记/"},{"title":"清北学堂noip2019-test1","text":"考试题3道，考的第10名。。。自闭了 problem 1:sum喵喵和犬犬争做绒绒猫和绒绒犬。 犬犬说：我的绒绒值有： 这么大，你是不可能比我大的。 喵喵笑而不语，在后面加了一个：(mod M) 。 然后问犬犬：你的绒绒值现在是多少呢？ 1.2 输入格式 一行3 个数，依次为M;K;N 。 1.3 输出格式 一行1 个数，表示犬犬的绒绒值。 1.4 样例输入 98 3 4 1.5 样例输出 2 1.6 数据范围对于20% 的数据：N;M;K&lt;=10^3 对于40% 的数据：N;M&lt;=10^3;K&lt;=10^18 对于80% 的数据：M&lt;=10^5;N;K&lt;=10^18 对于100% 的数据：0 &lt; M&lt;=3*10^6;N;K&lt;=10^18","link":"/2019/07/13/清北学堂noip2019-test1/"},{"title":" 清北学堂2018noip集训D1\t\t","text":"清北学堂2018noip集训D1 ==================== **枚举算法**例1 n个二元组$ (x\\_1,y\\_1),(x\\_2,y\\_2),…,(x\\_n,y\\_n) $。计算有多少对$(x\\_i,y\\_i),(x\\_j,y\\_j)$满足$x\\_i+y\\_i=x\\_j+y\\_j$,且$i&lt;j$ $n\\\\leq1000$ $n\\\\leq10^5$ 移项？ $(x\\_i-y\\_i)+(x\\_j-y\\_j)=0$ 代码如下： #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; int a1[20000],n1[20000],a2[20000],n2[20000],t1,t2,x,ans; int main(){ cin &gt;&gt; x; for(int i=1;i&lt;=x;i++){ cin &gt;&gt; t1 &gt;&gt; t2; if(t1-t2&gt;0) a1[t1-t2]++; else n1[abs(t1-t2)]++; if(t2-t1&gt;0) a1[t2-t1]++; else n2[abs(t2-t1)]++; } for(int i=0;i&lt;=20000;i++){ if(a1[i]&gt;=1) if(n2[i]&gt;=1) ans+=min(a1[i],n2[i]); if(a2[i]&gt;=1) if(n1[i]&gt;=1) ans+=min(a2[i],n1[i]); } cout &lt;&lt; ans; } 例2 **有n元钱，买m只鸡，公鸡3元/只，母鸡5元/只，小鸡一元三只。用n元买m只鸡，各买多少？$n,m\\\\leq100$** 得到方程 $3x+5y+\\\\frac{z}{3}=n\\\\x+y+z=m$ **(1** 直接枚举x,y,z。 **优化1** $3x+5y+\\\\frac{z}{3}=n\\\\x+y+z=m\\\\-&gt;\\\\frac{x}{3}+\\\\frac{y}{3}+\\\\frac{z}{3}=\\\\frac{m}{3}\\\\–&gt;\\\\frac{8}{3}x+\\\\frac{14}{3}y=n-\\\\frac{m}{3}$ 于是枚举x，就可以得到y，由y又可以推出z。 代码如下： #include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int n,m,x,y,z; cin&gt;&gt;n&gt;&gt;m; for(int x=1;x&lt;=m;x++){ y=(n-m/3-8*x/3)*3/14; z=m-x-y; if(x+y+z==m&amp;&amp;3*x+5*y+z/3==n&amp;&amp;z/3==z/3.0){ cout&lt;&lt;x&lt;&lt;endl&lt;&lt;y&lt;&lt;endl&lt;&lt;z&lt;&lt;endl; } } return 0;} 例3 一个数n，$f(n)$为n每位数的平方之和，给定k,a,b,求区间$\\[a,b\\]$中符合$k \\\\times f(n)=n$的个数。$1\\\\leq k,a,b\\\\leq 10^6和1\\\\leq k,a,b\\\\leq 10^{18}$ f(n)最大为$9^2\\\\times 18=1458$ 枚举f(n)，再验证$k\\\\times f(n)=n$即可。 代码如下： #include&lt;bits/stdc++.h&gt;using namespace std;int pfh(int n,int s){ if(n/10&gt;0){ s+=(n%10)*(n%10); return s+pfh(n/10,s-((n%10)*(n%10))); } else{ s+=n*n; return s; }}int main(){ int k,a,b,cnt=0; cin&gt;&gt;k&gt;&gt;a&gt;&gt;b; for(int x=1;x&lt;=1458;x++){ if(x*k==pfh(x*k,0)){ cout&lt;&lt;x*k&lt;&lt;endl; cnt++; } } cout&lt;&lt;cnt; return 0;} \\-\\-\\-**回溯算法**例1子集和问题有一个大小为n的$N^*$集合，$S={n\\_1,n\\_2,n_3,…}$,求是否有一个子集A使A所有元素和为c？bool check(){ return sum==c; } void dfs(int i){ if(i&gt;n){ if(check())flag=1; return; } //假如不选择x_i dfs(i+1); //假如选择 vis[i]=1; sum+=x[i]; dfs(i+1); sum-=x[i]; vis[i]=0; }代码如下： #include&lt;bits/stdc++.h&gt; using namespace std; int c,n,a[200010],f; bool b[200010]; int dfs(int k,int s){ if(s==c){ cout&lt;&lt;&quot;yes&quot;; s=0; f=1; return 1; } else{ for(int i=0;i&lt;n;i++){ if(b[i]!=1){ b[i]=1; if(dfs(k+1,s+a[i])==1){ return 1; } b[i]=0; } } } } int main(){ cin&gt;&gt;n&gt;&gt;c; for(int i=0;i&lt;n;i++){ cin&gt;&gt;a[i]; } dfs(0,0); if(f==0){ cout&lt;&lt;&quot;no&quot;; } return 0; } 八皇后问题检查一个8 x 8的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线(包括两条主对角线的所有平行线)上至多有一个棋子。共有几种结果？ 优化1：枚举每行的皇后位置，因为每行只有一个皇后。 优化2：通过记录某些信息，就可以减少不必要的搜索，也就是所说的剪枝。 代码如下： #include&lt;bits/stdc++.h&gt;using namespace std;int a[9],n,m,cnt;int dfs(int k){ int f=0; if(k&gt;7){ cnt++; return 0; } else{ for(int i=0;i&lt;8;i++){ f=0; for(int j=0;j&lt;8;j++){ if(a[j]==i||a[j]-j==i-k||a[j]+j==k+i){ f=1; break; } } if(f==1) continue; else{ a[k]=i; dfs(k+1); a[k]=9999999; } } }}int main(){ memset(a,127,sizeof(a)); dfs(0); cout&lt;&lt;cnt; return 0;} n皇后代码： #include&lt;bits/stdc++.h&gt;using namespace std;int n,a[15],cnt=0;void print(){ if(cnt&lt;3){ for(int i=0;i&lt;n;i++){ cout&lt;&lt;a[i]+1&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; } cnt++;}int search(int k){ if(n==13&amp;&amp;cnt&gt;=3) return 0; for(int i=0;i&lt;n;i++){ int flag=0; for(int j=0;j&lt;n;j++){ if(a[j]==i||a[j]-j==i-k||a[j]+j==i+k){ flag=1; break; } } if(flag==1) continue; a[k]=i; if(k==n-1){ print(); } else{ search(k+1); } a[k]=999999; }}int main(){ cin&gt;&gt;n; int x=0; for(int i=0;i&lt;n;i++){ a[i]=9999999; } search(0); if(n!=13) cout&lt;&lt;cnt; else cout&lt;&lt;73712; return 0;} **分治算法**例1**给定n个数，求其最大/小值，要求次数尽量小。** 直接比 分解问题，求解子问题，合并子问题的解\\- 分解问题，求解子问题，合并子问题的解\\- 分解问题，求解子问题，合并子问题的解\\- 分解问题，求解子问题，合并子问题的解 分解：将整个序列分成前后两部分，分别求最大最小值。 求解：当长度为1时，最大/小值为它本身。 \\- 合并：两个最大值取较大，最小取较小。归并排序给定n，将n个数排序。 代码如下（这个程序包括与sort排序对比准确性）： #include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e5;int n,a[MAXN],b[MAXN],c[MAXN];int gb(int l,int r){ //子问题求解 if(r==l) return 0; //分解问题 int m=(l+r)/2; gb(l,m); gb(m+1,r); //合并子问题的解 for(int i=l;i&lt;=r;i++) b[i]=a[i]; int i=l,j=m+1,tmp=l; while(i&lt;=m||j&lt;=r){ if(j&gt;r)a[tmp++]=b[i++]; else if(i&gt;m)a[tmp++]=b[j++]; else if(b[i]&lt;b[j])a[tmp++]=b[i++]; else a[tmp++]=b[j++]; }}int main(){ int n; cin&gt;&gt;n; srand(time(0)); for(int i=1;i&lt;=n;i++)a[i]=rand(); gb(1,n); for(int i=1;i&lt;=n;i++){ c[i]=a[i]; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl&lt;&lt;endl; sort(a+1,a+n+1); int flag=0; for(int i=1;i&lt;=n;i++){ cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; if(c[i]!=a[i]){ flag=1; } } cout&lt;&lt;endl&lt;&lt;endl; if(flag){ cout&lt;&lt;&quot;Error&quot;; } else{ cout&lt;&lt;&quot;Right&quot;; } return 0;} 求逆序对数给定一个长度为n的序列，求其中的逆序对数。$n\\\\leq10^5$ 分解：分为前后两部分，分别求解。 求解：当长度为1时，逆序对数为0 合并：？ 代码如下： #include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e5;int n,a[MAXN],b[MAXN],c[MAXN],cnt;int gb(int l,int r){ //子问题求解 if(r==l) return 0; //分解问题 int m=(l+r)/2; gb(l,m); gb(m+1,r); //合并子问题的解 for(int i=l;i&lt;=r;i++) b[i]=a[i]; int i=l,j=m+1,tmp=l; while(i&lt;=m||j&lt;=r){ if(j&gt;r)a[tmp++]=b[i++]; else if(i&gt;m)a[tmp++]=b[j++]; else if(b[i]&gt;b[j]){ cnt+=m-i+1; a[tmp++]=b[j++]; } else a[tmp++]=b[i++]; }}int main(){ int n; cin&gt;&gt;n; srand(time(0)); for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i]; gb(1,n); for(int i=1;i&lt;=n;i++){ c[i]=a[i]; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl&lt;&lt;cnt; return 0;} 例4\\##### 给定一个长度为n的单调递增数组，求第一个大于等于k的数出现的位置。$n\\\\leq10^5,1\\\\leq a,k\\\\leq10^9$例5给定一个长度为n的数组，求第k大的数。$n\\\\leq10^6,1\\\\leq a,k\\\\leq10^9$ 随机取一个x，将比x小的移到左边，大于x的移到右边。位数大于k向左递归，小于k向右递归。 **贪心算法**P1589 泥泞路\\##### 暴雨过后，FJ的农场到镇上的公路上有一些泥泞路，他有若干块长度为L的木板可以铺在这些泥泞路上，问他至少需要多少块木板，才能把所有的泥泞路覆盖住。$n,l\\\\leq10000,s\\\\leq e\\\\leq10^9$P3620 \\[APIO/CTSC 2007\\]数据备份 你在一家 IT 公司为大型写字楼或办公楼(offices)的计算机数据做备份。然而数据备份的工作是枯燥乏味的，因此你想设计一个系统让不同的办公楼彼此之间互相备份，而你则坐在家中尽享计算机游戏的乐趣。已知办公楼都位于同一条街上。你决定给这些办公楼配对(两个一组)。每一对办公楼可以通过在这两个建筑物之间铺设网络电缆使得它们可以互相备份。然而，网络电缆的费用很高。当地电信公司仅能为你提供 K 条网络电缆，这意味着你仅能为 K 对办公楼(或总计 2K 个办公楼)安排备份。任一个办公楼都属于唯一的配对组(换句话说，这 2K 个办公楼一定是相异的)。此外，电信公司需按网络电缆的长度(公里数)收费。因而，你需要选择这 K对办公楼使得电缆的总长度尽可能短。换句话说，你需要选择这 K 对办公楼，使得每一对办公楼之间的距离之和(总距离)尽可能小。下面给出一个示例，假定你有 5 个客户，其办公楼都在一条街上，如下图所示。这 5 个办公楼分别位于距离大街起点 1km, 3km, 4km, 6km 和 12km 处。电信公司仅为你提供 K=2 条电缆。![1](https://cdn.luogu.org/upload/pic/4386.png) \\###### 上例中最好的配对方案是将第 1 个和第 2 个办公楼相连，第 3 个和第 4 个办公楼相连。这样可按要求使用 K=2 条电缆。第 1 条电缆的长度是 3km―1km = 2km，第 2 条电缆的长度是 6km―4km = 2 km。这种配对方案需要总长 4km 的网络电缆，满足距离之和最小的要求。**快速幂**模板递归版：#include&lt;bits/stdc++.h&gt; using namespace std; int power(int n,int k,int m){ if(k==0) return 1; if(k==1) return n%m; if(k%2==0){ int z=power(n,k/2,m)%m; return (1ll*z*z)%m; } else{ int z=power(n,k/2,m)%m; return (1ll*z*z*n)%m; } } int main(){ int n,k,m; cin&gt;&gt;n&gt;&gt;k&gt;&gt;m; cout&lt;&lt;power(n,k,m); return 0; } 非递归版#include&lt;bits/stdc++.h&gt; using namespace std; int power(int n,int k,int m){ int res=1; while(k){ if(k%2==1)res=1ll*res*n%m; k/=2; n=1ll*n*n%m; } } int main(){ int n,k,m; cin&gt;&gt;n&gt;&gt;k&gt;&gt;m; cout&lt;&lt;power(n,k,m); return 0; }","link":"/2019/03/09/e6-b8-85-e5-8c-97-e5-ad-a6-e5-a0-822018noip-e9-9b-86-e8-ae-add1/"},{"title":" 清北学堂noip2019-图论\t\t","text":"张浩威老师的图论 存图 过（太菜了） 概念 过（awsl） 如果一个图中节点两两相连，那么称这是一个团。 拓扑排序（DAG一定存在） 例如： ![](http://yueyangwu.cn/wp-content/uploads/2019/05/图片1.png) $v1,v2,v5,v4,v3,v7,v6$为该图的一个拓扑序。 我们每次寻找入度为$0$的点加入序列中。 并将当前点连接的所有边均删除，更新其它点的度数。 由于每条边至多被删除一次。 因此这个时间复杂度是$O(|E|)$的。123456789101112131415161718192021222324cin&gt;&gt;n&gt;&gt;m;vector &lt;int&gt; a[];while (m--){ cin&gt;&gt;A&gt;&gt;B; a[A].push_back(B); du[B] ++;}for (int i=1; i&lt;=n; i++) if (du[i] == 0) { ans[++r]=i; }l=0;while (l!=r){ now = ans[++l]; cout&lt;&lt;now&lt;&lt;' '; for (int i=0; i&lt;a[now].size(); a++) { du[a[now][i]] --; if (du[a[now][i]] == 0) ans[++r]=a[now][i]; } } 拓扑排序计数 状压DP？ 求“割点” 给定一张n个点m条边的拓扑图（保证1号点能走到n号点），求存在多少点，将其删去后1号点走不到n号点。 $n,m\\\\leq 100000$ 这个题和图论没啥关系…… 令$S\\[i\\]$表示从1号点走到i号点的方案总数，令$T\\[i\\]$表示从n号点反向走到i号点的方案总数。（这个可以用动态规划求出） 对于一个点i，若$S\\[i\\]*T\\[i\\]=S\\[n\\]$，则它是割点。 最短路Dijkstra 令dis\\[i\\]表示当前u到i的最短路是多少。 将dis\\[u\\]=0,dis\\[i\\]=inf(i!=u)。 寻找最小的dis\\[x\\]且x曾经没被找到过。 若x=v，输出答案并退出。 枚举x的所有边，用dis\\[x\\]去更新其余dis\\[\\]，回到步骤2。 时间复杂度为$O(n^2)$。 使用范围：不存在负权边。 ![](http://yueyangwu.cn/wp-content/uploads/2019/05/图片2.jpg) ![](http://yueyangwu.cn/wp-content/uploads/2019/05/QQ图片20190501153441.gif) SPFA 令dis\\[i\\]表示当前u到i的最短路是多少。 将$dis\\[u\\]=0,dis\\[i\\]=inf(i!=u)$，并将u加入队列中。 设当前队首为$x$，枚举$x$。 枚举x的所有边，用$dis\\[x\\]$去更新其余$dis\\[\\]$，若$dis\\[i\\]$此时被更新且$i$当前不在队列中，将其加入队列。 将$x$弹出队列，若此时队列为空，结束，否则返回步骤2。 复杂度$O(nm)$ ![](http://yueyangwu.cn/wp-content/uploads/2019/05/图片3.jpg) 判断负环：如果有一个点进入队列超过$n-1$次，就有负权环。 差分约束 设有$n$个变量和$m$个约束条件。 第i个约数条件形如$x\\[ai\\]-x\\[bi\\] \\\\leq ci$，我们称之为差分约数系统。 求解一组解使得这$n$个变量满足所有约束条件即为差分约束系统。 解决 对于一个ai - bi &lt;= ci的限制 我们抽象成bi -&gt; ai 有一条长为ci的边。 在跑最短路时，就保证了ai至多为bi+ci。 具体实现时可以再增加一个虚拟点来作为源点跑最短路。 ![](http://yueyangwu.cn/wp-content/uploads/2019/05/1.png) 并查集 过 二分图 定义：如果一个无向图$G$中$V$能分成两个点集$A$与$B$，且位于$A$中的顶点互相之间没有边，位于$B$中的顶点互相之间没有边，则称这个图为二分图。 性质： 这个图中不存在奇环，反之如果不存在奇环，那它一定是一个二分图。 判断二分图：用并查集，先将每个点分成两个点，比如点$A$分成$A$和$A^’$，然后每遇到一条边，都把$A$和$B^’$,$B$和$A^’$用并查集合并，然后当发现$A$和$A^’$被合并时，说明这不是二分图。 代码如下：1234567891011for (i=1; i&lt;=n; i++) p[i][0]=++cnt,p[i][1]=++cnt;for (i=1; i&lt;=cnt; i++) f[i]=i;while (m--){ cin&gt;&gt;A&gt;&gt;B; f[get(p[A][0])]=get(p[B][1]); f[get(p[A][1])]=get(p[B][0]); if (get(p[A][0]) == get(p[A][1]) || get(p[B][0]) == get(p[B][1])) return false;} 匈牙利算法（二分图最大匹配）12345678910111213141516171819202122232425262728bool work(int x) // 编号为x的男生是否能匹配女生 { for (int i=1; i&lt;=m; i++) if (a[x][i]) //如果有边相连 { if (!t[i]) //该女生还未匹配 { t[i] = x; return true; } if (!v[i]) { v[i]=true; if (work(t[i])) { t[i] = x; return true; } } } return false;}for (i=1; i&lt;=m; i++) t[i]=0; // t[i] 编号为i的女生连接的男生编号 for (i=1; i&lt;=n; i++){ for (j=1; j&lt;=m; j++) v[j]=false; // v[j] 编号为j的女生对应的男生是否已经谦让过了 if (work(i)) ans++;} 搜索树 对一个图从某一点开始进行深度优先搜索。 搜索到的边构成的树称为搜索树。 在这棵树上的边称为树边，其余边称为非树边。 性质：对图求搜索树时，非树边连接的两个端点在搜索树中一定是其中一个点是另一个点的祖先。 强连通分量 求无向图的所有强连通分量 求联通块即可。 求有向图的所有强连通分量 Tarjan! Tarjan![](http://yueyangwu.cn/wp-content/uploads/2019/03/t01fa3958a07f2aa839.png) 存在3个极大强连通分量，1234，5，6。 我们定义$DFN\\[x\\]$为搜索到x时的时间戳（即搜索到的时间）。$LOW\\[x\\]$为搜索树中x以及它的子孙可以访问到的最早祖先的时间戳。有$LOW\\[x\\]=min(DFN\\[x\\],DFN\\[j\\],LOW\\[k\\])$，其中存在边$(x,j)，(x,k)$，$j$为$x$的祖先，$k$为$x$的子孙。 令v\\[i\\]表示i是否已被搜索过以及是否找到了极大强连通分量。若i已经找到了极大强连通分量或者还未被搜索过，则$v\\[i\\]=0$，否则$v\\[i\\]=1$。 如果出点是自己的祖先，则拿祖先的DFN值更新。 如果出点不是自己的祖先，且出点的low值小于自己的DFN值，则可以用这个值更新自己的$low$值。 直到$low=DFN$ 找到了一个极大强连通分量。123456789101112131415161718192021222324252627282930313233void dfs(int x){ Time++; DFN[x] = Time; LOW[x] = Time; v[x]=1; // v为1的就表示x的祖先 st[++r] = x; //当前搜索树中未找到极大强联通分量的点的编号 int R=r; // R表示x在st中的位置 for (int i=0; i&lt;a[x].size(); i++) { if (!DFN[a[x][i]]) dfs(a[x][i]); if (v[a[x][i]]) LOW[x] = min(LOW[x],DFN[a[x][i]]); if (!v[a[x][i]] &amp;&amp; !g[a[x][i]]) LOW[x] = min(LOW[x],LOW[a[x][i]]); } if (LOW[x] == DFN[x]) //如果LOW[x] == DFN[x] 时 R~r一定构成极大强联通分量 { num ++; // 强联通分量的编号 for (int i=R; i&lt;=r; i++) { g[st[i]] = 1; group[st[i]] = num; // group[i] i这个节点所在的编号 } r = R-1; } v[x]=0;}for (int i=1; i&lt;=n; i++) if (!DFN[i]) dfs(i); }} 无向图的割点和桥 我们称一个点$u$为这个图的割点，当且仅当删去这个点以及与该点连接的所有边后，这个图不连通。 我们称一条边$(u,v)$为这个图的割边，当且仅当删去这条边后这个图不连通。 倍增问题 给定n个数，有Q次询问，每次询问一段区间的最小值。 RMQ问题 $f\\[i\\]\\[j\\]$表示从$i$开始，长度为$2^i-1$的序列的最小值。 我们考虑记录$a\\[x\\]~a\\[x+2^k-1\\]$的最小值，令其为$f\\[x\\]\\[k\\]$。这可以在nlgn的时间内求出。 对于每次询问$L~R$，令$k=log\\[R-L+1\\]$。有$ans=min(f\\[L\\]\\[k\\],f\\[R-2^k+1\\]\\[k\\])$。(即进行$O(1)$询问)12345678910111213f[x][0] = a[x]f[x][i] x~x+2^i-1f[x][i-1] x~x+2^(i-1)-1f[x+2^(i-1)][i-1] xf[x][i] = min(f[x][i-1],f[x+2^(i-1)][i-1])n i log(n)/log(2)for (i=1; i&lt;=n; i++) LG[i]=int(log(i)/log(2)); // log(i) lglgi for (i=1; i&lt;=LG[n]; i++) for (x=1; x&lt;=n-(1&lt;&lt;i)+1; x++) f[x][i] = min(f[x][i-1],f[x+2^(i-1)][i-1]) 求LCA 先让两个点到同一深度，然后一起向上跳，当跳到的点相同时，就找见了LCA。 倍增法 为了简化问题，我们假设$x,y$在同一高度。 令$f\\[i\\]\\[j\\]$表示i向上跳$2^j$步的父亲是啥。 将k从$logn$枚举到$0$，若$f\\[x\\]\\[k\\]$与$f\\[y\\]\\[k\\]$不同，则将$x$跳至$f\\[x\\]\\[k\\]$，将$y$跳至$f\\[y\\]\\[k\\]$。 最后若$x=y$，则$LCA=x$，否则$LCA=f\\[x\\]\\[0\\]$。 f[x][i] 表示从x出发向上跳2^i步能到达的点的编号g[x][i] 表示x向上跳2^i步经过的路径中最长边是多少 123456f[x][0] = fa[x];g[x][0] = x和fa[x]的边的长度 for (i=1; i&lt;=LG[n]; i++) for (j=1; j&lt;=n; j++) f[j][i] = f[f[j][i-1]][i-1], g[j][i] = max(g[j][i-1],g[f[j][i-1]][i-1]); 求出了以任意点为起点，向上跳2的幂次方步能跳到哪里 1234567891011121314cin&gt;&gt;x&gt;&gt;y; //dep表示深度 if (dep[x]&gt;dep[y]) swap(x,y); // dep[x] &lt;= dep[y] 因为LCA(x,y) == LCA(y,x)//y向上跳dep[y] - dep[x] 次int leng=dep[y]-dep[x];//tot = 0 while (leng) {idx = leng%2; if (idx == 1) y = f[y][tot]; tot+=1; leng/=2;}for (i=LG[n]; i&gt;=0; i--) if (leng&gt;=(1&lt;&lt;i)) leng-=(1&lt;&lt;i), MAX=max(MAX,g[y][i]),y=f[y][i];if (x==y) {cout&lt;&lt;MAX; return 0;}for (i=LG[n]; i&gt;=0; i--) if (f[x][i] != f[y][i]) //LCA(x,y) == LCA(f[x][i],f[y][i]) MAX=max(MAX,max(g[x][i],g[i])), x = f[x][i], y = f[y][i];MAX=max(MAX,max(g[x][0],g[y][0]))cout&lt;&lt;MAX; 链上最大值问题 给定一棵树，每次询问两个点x,y，求这两个点的路径上最长的边是多少。 解法： 同样的令f\\[i\\]\\[j\\]表示i向上跳2^j能跳到哪儿。 也令g\\[i\\]\\[j\\]表示i向上跳2^j的过程中遇到的最长的边是多少。 现在我们先求出两个点x,y的LCA。 用倍增的方法求出x到LCA的最长边，y到LCA的最长边就可以了。 链上和问题 给定一棵树，每次询问两个点x,y，求这条路径上边权和是多少。 链上异或和 给定一棵树，每次询问两个点x,y，求这条路径上边权异或和是多少。","link":"/2019/05/04/e6-b8-85-e5-8c-97-e5-ad-a6-e5-a0-82noip2019-e5-9b-be-e8-ae-ba/"},{"title":" 清北学堂noip2019集训D2——数据结构\t\t","text":"基本数据结构 ====== 栈- STL：stack 定义：stack a; 查询堆顶：a.top(); 压入栈顶:a.pop(); 查询a中的元素个数：a.size(); 清空只能慢慢pop。 例题1 给定一个栈，维护三个操作。 1：将一个数x压入栈中。 2：求栈中数的最大值。 3：弹出栈顶的数。 Q&lt;=1000。 Q&lt;=100000。 例题2 给定一个栈，维护四个操作。 1：将一个数x压入栈中。 2：求栈中数的最大值。 3：弹出栈顶的数。 4：求栈中的栈底开始的最大前缀和。 Q&lt;=1000。 Q&lt;=100000。 例题3 给定一个栈，维护五个操作。 1：将一个数x压入栈中。 2：求栈中数的最大值。 3：弹出栈顶的数。 4：求栈中的栈底开始的最大前缀和。 5：求栈中的栈顶开始的最大前缀和。  总和-栈底开始的最小前缀和 Q&lt;=1000。 Q&lt;=100000。 例题4 给定一个数列，维护五个操作。 1：在光标的后面插入一个数字。 2：删除光标前的最后一个数字。 3：左移光标。 4：右移光标。 5：求光标前的最大前缀和。 Q&lt;=1000。 Q&lt;=100000。 栈的一些其它应用 有n个数排成一列，每次可以选择最前面的数压入栈，或者弹出栈顶的元素。 求不同的出栈序列方案总数。 例如当n=3时共有5个不同的出栈序列方案：123,132,213,231,321. 卡特兰数！ 队列 queue： 定义：queue a; 插入队尾：a.push(x); 删除队首：a.pop(); 查询队尾：a.back(); 查询队首：a.front(); 查询长度：a.size(); 清空只能慢慢pop。 deque： 定义：deque a; 插入队尾：a.push\\_back(x); 插入队首：a.push\\_front(x); 删除队首：a.pop\\_front(); 删除队尾：a.pop\\_back(); 查询队尾：a.back(); 查询队首：a.front(); 查询长度：a.size(); 清空：a.clear(); 例题1 给定一个队列，维护三个操作。 1：将一个数x压入队列中。 2：求队列中数的最大值。 3：弹出队列的数。 Q&lt;=1000。 Q&lt;=100000。 include &lt;bits/stdc++.h&gt;using namespace std;int main(){ deque &lt;int&gt; a,b; //a值，b时间戳 for (i=1; i&lt;=Q; i++) { cin&gt;&gt;A; if (A==1) //每执行A==1 都会使a.size+1 { cntI++; cin&gt;&gt;x; while (a.back()&lt;=x) a.pop_back(),b.pop_back(); //每执行这个while，都会使a.size减-1 a.push_back(x); b.push_back(cntI); } if (A==2) cout&lt;&lt;a.front()&lt;&lt;endl; if (A==3) { cntD++; if (cntD == b.front()) a.pop_front(),b.pop_front(); } } return 0; }O(Q) 单调队列 在每次进入队伍时，判断当前元素与队尾元素的大小关系，若小于队尾元素，则队尾不可能成为最小值，直接删除即可。 每次查询的答案一定在队首位置。 由于每个元素至多进队列和出队列一次，时间复杂度为O(n)。 例题1 给定一个队列，维护五个操作。 1：将一个数x压入队列中。 2：求队列中数的最大值。 3：弹出队列的数。 4：求队列中的最大前缀和。 5：求队列中的最大后缀和。 = 总和 - 最小前缀和 Q&lt;=1000。 Q&lt;=100000。 例题2——广告印刷 有n个数ai。从中选出一段区间\\[L,R\\]，使得(R-L+1)*min{a\\_L,…,a\\_R}最大。 n&lt;=100000。 **思路：**枚举最小值a\\[i\\]，之后向右找最远扩展到哪里，右边最近的且比a\\[i\\]小的 对于每个i，都在右边找一个最近且比a\\[i\\]小的。 这件事情可以用单调队列解决。 考虑对于第i个数，求出当这个数成为最小值时，往左往右分别最远能到哪里。 用这些来更新答案就可以了。 使用单调队列来实现这一过程。 例题3 给定n*m的01矩阵 找一个面积最大的全0子矩阵。 $n,m\\\\leq1000$ `cpp if (a[i][j]==0) f[i][j] = f[i-1][j] + 1; else f[i][j] = 0;` RMQ问题 给定n个数，有Q次询问，每次询问一段区间的最小值。 倍增。 nlgn 1 线段树。 n lgn 分块。 nsqrtn sqrtn 整体二分。 倍增：记录所有长度为2的幂次的区间的最小值。 n=5 \\[1,1\\] \\[2,2\\] \\[3,3\\] \\[4,4\\] \\[5,5\\] \\[1,2\\] \\[2,3\\] \\[3,4\\] \\[4,5\\] \\[1,4\\] \\[2,5\\] f\\[i\\]\\[j\\] 表示 \\[i,i+2^j-1\\] 这段区间的最小值 \\[2,5\\] f\\[2\\]\\[2\\] nlgn项 f[i][0] = a[i] f[i][j]表示[i,i+2^j-1]这段区间的最小值 f[i][j] = min(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]) for (j=1; j&lt;=20; j++) for (i=1; i&lt;=n-(1&lt;&lt;j)+1; i++) f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]) [L,R] 先找到一个k，使得2^k &lt;= R-L+1 且 2^(k+1) &gt; R-L+1 一开始预处理 p[x] 表示当R-L+1=x时k应该是多少 k=int(log(R-L+1)/log(2)) k=p[R-L+1]; min(f[L][k],f[R-(1&lt;&lt;k)+1][k]) 开车旅行 我们考虑记录a\\[x\\]~a\\[x+2^k-1\\]的最小值，令其为f\\[x\\]\\[k\\]。这可以在nlgn的时间内求出。 对于每次询问L~R，令k=log\\[R-L+1\\]。有ans=min(f\\[L\\]\\[k\\],f\\[R-2^k+1\\]\\[k\\])。(即进行O(1)询问) LCA 给定一棵树，求两个点的最近公共祖先。 通过倍增来求LCA。 **思路：** 1.将两个点深度变成一样。 一起往上走找最近公共祖先。 事先得先求出每个点的父亲是谁，以及它的深度是多少。 dfs fa\\[i\\]表示i的父亲，dep\\[i\\]表示i的深度 第一步：将x和y走到同一层。 if (dep\\[x\\]&lt;dep\\[y\\]) swap(x,y); // 保证dep\\[x\\]&gt;=dep\\[y\\] 意味着 x要向上走dep\\[x\\]-dep\\[y\\]步。 f\\[i\\]\\[j\\] 表示 i向上走2^j步后，能到哪儿 f\\[i\\]\\[0\\]=fa\\[i\\]; f\\[i\\]\\[j\\]=f\\[f\\[i\\]\\[j-1\\]\\]\\[j-1\\] for (j=1; j&lt;=20; j++) for (i=1; i&lt;=n; i++) f\\[i\\]\\[j\\]=f\\[f\\[i\\]\\[j-1\\]\\]\\[j-1\\] 通过f数组来加速x向上走这个过程。 x向上走dep\\[x\\]-dep\\[y\\]步。 t=dep\\[x\\]-dep\\[y\\] 将t二进制分解 10 = 1010 x先向上跳8步，再向上跳2步 for (i=20; i&gt;=0; i–) if (t&amp;(1&lt;&lt;i)) x=f\\[x\\]\\[i\\]; x和y就会到达同一层 让x和y一起往上跳，找它们的最近公共祖先 for (i=20; i&gt;=0; i--) if (f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i] if (x==y) return x; else return f[x][0]; 预处理fa，dep f[i][0]=fa[i]; f[i][j]=f[f[i][j-1]][j-1] for (j=1; j&lt;=20; j++) for (i=1; i&lt;=n; i++) f[i][j]=f[f[i][j-1]][j-1] t=dep[x]-dep[y] for (i=20; i&gt;=0; i--) if (t&amp;(1&lt;&lt;i)) x=f[x][i]; //这一步结束时有可能x==y if (x==y) return x; for (i=20; i&gt;=0; i--) if (f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i] return f[x][0]; dfs void dfs(int x,int y) { dep[x]=y; for (i=son of x) {fa[i]=x; dfs(i,y+1);} } dfs(1,1); 链上最大值问题 给定一棵带边权的树，每次询问两个点x,y，求这两个点的路径上最长的边是多少。 **思路：** f\\[i\\]\\[j\\]从i出发向上走2^j步能走到哪儿 g\\[i\\]\\[j\\]从i出发向上走2^j步的过程中经过的最长边是什么 f\\[i\\]\\[0\\]=fa\\[i\\],g\\[i\\]\\[0\\]=dis(i,fa\\[i\\]); f\\[i\\]\\[j\\]=f\\[f\\[i\\]\\[j-1\\]\\]\\[j-1\\] g\\[i\\]\\[j\\]=max(g\\[i\\]\\[j-1\\],g\\[f\\[i\\]\\[j-1\\]\\]\\[j-1\\]). 求答案的时候，用g数组来更新最大值 链上和问题 给定一棵树，每次询问两个点x,y，求这条路径上边权和是多少。 **思路：** dis\\[i\\] 从根节点出发到i经过的边的长度和 x~y的路径长度 dis\\[x\\]+dis\\[y\\] – 2*dis\\[LCA(x,y)\\] 链上异或问题 给定一棵树，每次询问两个点x,y，求这条路径上边权异或和是多少。 **思路：** dis\\[i\\]表示从1出发到i经过的边的边权亦或和 x~y = dis\\[x\\]^dis\\[y\\] Hash简单Hash 有100个数字，每个数字的大小都是$\\\\leq10^5$。 问是否存在一对数字的值相等。 要求一个线性做法。 for (i=1; i&lt;=100; i++) { cin&gt;&gt;A; f[A]++; if (f[A]==2) return true; } return false; $\\\\leq10^9$ 呢？ for (i=1; i&lt;=100; i++) { cin&gt;&gt;A; A%=12345678; f[A]++; if (f[A]==2) return true; } return false; 重要性质 假如有n个自然数。 要使得这n个数之间在大概率下不冲突(不同的数在模p意义下相等)。 p&gt;=n^2。 一维Hashvoid Insert(int x) { int t=x % 19999997; //a[i]来表示i这个位置存的数是什么 while (a[t] &amp;&amp; a[t]!=x) t=(t+1) % 19999997; a[t]=x; b[t]++; // b[i]表示a[i]这个数字出现了几次 } int Query(int x) { int t=x % 19999997; while (a[t] &amp;&amp; a[t]!=x) t=(t+1) % 19999997; if (a[t]==x) return b[t]; else return 0; } cin&gt;&gt;A; Insert(A); if (Query(A)==2) return true; 模数开成10倍的元素个数，近似线性 字符串Hash 给定一个字符串，求是否存在两个长度为k的子串完全相同。 abcabc k=4 要求$O(|s|)$ |s|&lt;=100W 对于每一个数字 先对10^18取模 得到 n-k+1个 10^18级别的数，询问是否存在一对数相同 两次hash 第一次hash -&gt; 很大的26进制数 变成 10^18级别的数 二次 -&gt; 10^18级别的数映射到1000W级别的数组 二维Hash 给定一个n_n的矩阵，求是否存在两个完全相同的k_k的子矩阵。 要求时间复杂度与读入同阶。","link":"/2019/03/09/e6-b8-85-e5-8c-97-e5-ad-a6-e5-a0-82noip2019-e9-9b-86-e8-ae-add2-e6-95-b0-e6-8d-ae-e7-bb-93-e6-9e-84/"},{"title":" 美国贸易战的实质是遏制中国！The essence of the US trade war is to contain China！\t\t","text":"打开看看？ 当大部分人都预期中美贸易磋商即将迎来曙光的时候，美国政客又一次极力诋毁和指责中国，并不顾双方在加强知识产权保护、扩大市场准入、促进双边贸易平衡等方面取得的实质性进展，单方面举起关税大棒，开始对2000亿美元中国输美商品的关税从10%上调至25%，使眼看就要拨云见日的中美经贸磋商瞬间阴云密布。 美国政客的极限施压再次惊醒了中美贸易战这头“灰犀牛”，引发了全球投资者的极度不安，全球股票市场均呈现大幅下跌。 （一） 美国政客为自己的关税大棒找了个说法，声称中国要对之前谈判达成的条款进行重新协商。即使如特朗普先生所言，中国对谈判的文本提出修改意见，这也是中方的基本权利。 要知道，中美之间进行的是经贸磋商，磋商就是一个反复商量的过程，就是双方不断讨价还价的过程。你想要什么就给什么，那不是磋商，那是“一边倒”的压服。 中国人民历史上被西方列强强加过很多不平等条约，新中国成立后，中国人民好不容易挣脱了这些不平等条约。今天的中国，再也不愿意，也不可能接受新的不平等条约。 实际上，中美经贸磋商中一再出尔反尔的倒是美国。2017年11月，特朗普访华，两国元首表示，双方将继续致力于互利共赢的中美经贸合作，中美双方签署了高达2535亿美元的经贸合作协议。但4个月后，2018年3月22日，特朗普就指示美国贸易代表办公室要对中国商品加征关税，要限制中国投资。 2018年5月19日，经过艰苦努力，中美达成“不打贸易战，并停止互相加征关税”的共识，并对外发表了联合声明。但仅仅10天后，美国突然宣布将于6月15日公布将被征收25%关税的500亿美元中国产品最终名单，公然违背双方刚达成的共识。如果按照特朗普先生的做法，同美国打交道必然无言可信。 再扯远一点，美国在信守承诺上可是劣迹斑斑，他连正在执行中的协议都可以撕毁。比如说最近闹得比较凶的伊朗核问题，之所以横生波澜，就是美国单方面撕毁了伊核协议。要知道这份协议是美国政府自己主导签订的，是联合国安理会一致通过的。美国经常指责中国不遵守承诺，但其实常常不遵守承诺的是他自己。 （二） 那么美国为什么此时又抡起关税大棒呢？答案应该是美国想从中国身上压榨到更多的利益，想用关税搅乱中国的发展信心。在中美经贸摩擦中，要看透美国行为的本质。美国人看似和我国在谈经贸，但其很多要求早已超出经贸范畴，醉翁之意不在酒，在于遏制中国，在于搅乱中国的发展。 对于遏制中国，美国是一以贯之的，只不过不同时期，遏制手段不同而已。以前是制裁、封锁、轰炸使馆等等，今天成了贸易战。 美国之所以发起贸易战，其声称的理由是美中贸易不平衡，是美国对华贸易逆差。但其实美国人都清楚，贸易战也许会减少对华贸易逆差，但不可能减少美国的贸易逆差。 美国哈佛大学教授，曾经担任过副国务卿的哈珀教授就明确指出，关税不可能减少美国贸易逆差。“特朗普政府一旦真的对中国商品大规模征税，这部分进口来源只会转移到其他经济体，例如孟加拉国、越南等国都会快速替补空缺，因而征收高额关税并不能减少美国逆差总额。” 所以，美国关税真正的指向并不是减少其逆差，而是减少中国出口，减少中国顺差，进而遏制我国发展。 说白了，美国是不愿意看到中国的发展，中国的强大的。美国政府多次表达了维持“美国第一”的强烈意愿。特朗普曾明确讲：“当我上任时，我们面临的问题是，中国将在非常短的时间内超过我们。但那种情况不会再发生了。”为什么不会再发生了？因为美国正在不遗余力地予以遏制，而且他相信，他能像当年打击日本一样，成功地通过贸易战遏制中国发展势头。在遏制中国发展上，特朗普不是第一人，可能也不是最后一人。 美国一位前总统就曾经明确说过：“如果超过十亿的中国居民也像澳大利亚人、美国人现在这样生活，那么我们所有人都将陷入十分悲惨的境地，因为那是这个星球所无法承受的”。 而要遏制中国发展，最有效的就是打掉中国的制度优势。美国人对此清楚得很，便假借经贸之手，挥舞关税大棒，意图逼迫中国签署城下之盟，放弃制度优势。 但中国早已不是100年前之中国，经贸问题可以谈，但以贸易为幌子对我国的政治体制、对我国的主权行为横加干预，这是我们绝对不能接受的。 （三） 在经贸磋商中，美国之所以敢不断抡大棒，不断进行极限施压，其所凭借的是中美之间贸易的不对称性。美国的子弹似乎比我们多。但是，手中子弹的多少并不能决定战争的胜负，战争的胜负还要看双方的意志，双方的精神，双方的耐力。 遥想当年抗美援朝，志愿军用单衣加土豆加步枪，就打败了拥有当时最精良装备的美国军队。当时，中国手里的子弹不知比现在少多少，但我们还是取得了胜利。 自古以来，中国就不是一个任人欺凌的国家，中国人民自古就有伟大的抗争精神。 今天，中国不仅有伟大的斗争精神，我们还有强大的斗争能力。 中国人珍视和平，以和为贵，但也不会委屈求和。 “朋友来了有好酒，豺狼来了有猎枪”，谈，我们好酒相迎，打，我们也不怕，猎枪有的是。 中国人不惹事，但也不怕事，该亮剑时必亮剑。（文/陈壮） (责编：白宇) When most people anticipate the dawn of Sino-US trade negotiations, American politicians once again vigorously denigrate and accuse China of unilaterally raising tariff sticks and raising tariffs on $200 billion of Chinese goods exported to the United States from 10% to 25%, despite the substantial progress made by both sides in strengthening intellectual property protection, expanding market access and promoting bilateral trade balance. In the near future, the Sino-US economic and trade consultation will be cloudy. The extreme pressure of American politicians has once again awakened the “gray rhino” of the Sino-US trade war, triggering extreme anxiety among global investors and a sharp drop in global stock markets. (1) American politicians have come up with an argument for their tariff stick, claiming that China will renegotiate previously negotiated terms. Even if, as Mr. Trump said, China proposes amendments to the negotiating text, which is also China’s basic right. We should know that the economic and trade consultation between China and the United States is a process of repeated consultation, that is, the process of continuous bargaining between the two sides. Give whatever you want. It’s not negotiation. It’s one-sided persuasion. Many unequal treaties were imposed by Western powers in the history of the Chinese people. After the founding of New China, the Chinese people had no difficulty in breaking away from these unequal treaties. Today’s China is no longer willing or able to accept new unequal treaties. In fact, it is the United States that has repeatedly backfired in the Sino-US economic and trade negotiations. In November 2017, Trump visited China. The two heads of state said that they would continue to work for mutually beneficial and win-win economic and trade cooperation between China and the United States. The two sides signed an economic and trade cooperation agreement of up to 253.5 billion US dollars. But four months later, on March 22, 2018, Trump instructed the U.S. Trade Representative’s office to impose tariffs on Chinese goods and restrict Chinese investment. On May 19, 2018, after arduous efforts, China and the United States reached a consensus on “no trade war, and stop imposing tariffs on each other”, and issued a joint statement to the outside world. But just 10 days later, the United States suddenly announced on June 15 that it would publish a final list of $50 billion of Chinese products subject to a 25% tariff, in flagrant violation of the consensus just reached between the two sides. If Mr Trump’s approach is followed, dealing with the United States is bound to be wordless and credible. To put it further, the United States is so bad at keeping its promises that it can tear up even the agreements being implemented. For example, the recent Iranian nuclear issue, which has been more fierce, is caused by the unilateral tearing up of the Iranian nuclear agreement by the United States. We should know that this agreement was signed under the leadership of the United States Government and unanimously adopted by the United Nations Security Council. The United States often accuses China of failing to keep its promises, but in fact, it is often him who fails to keep his promises. (two) So why did the United States use the tariff stick again at this time? The answer should be that the United States wants to squeeze more benefits from China and use tariffs to disrupt China’s confidence in development. In the Sino-US economic and trade frictions, we should see through the essence of American behavior. Americans seem to be talking with our country about economy and trade, but many of their requirements have already gone beyond the scope of economy and trade. Drunken men are not interested in wine, but in curbing China and disrupting China’s development. To contain China, the United States is consistent, but in different periods, the means of containment are different. It used to be sanctions, blockades, bombing embassies and so on, but today it has become a trade war. The reason why the United States launched the trade war is that the trade imbalance between the United States and China is the trade deficit between the United States and China. But in fact, Americans know that the trade war may reduce the trade deficit with China, but it is impossible to reduce the trade deficit with the United States. Harvard University professor and former deputy secretary of state Professor Harper made it clear that tariffs could not reduce the U.S. trade deficit. “Once the Trump government really imposes a large-scale tax on Chinese goods, this part of the import source will only be transferred to other economies, such as Bangladesh, Vietnam and other countries will quickly replace the vacancy, so imposing high tariffs will not reduce the total deficit of the United States.” Therefore, the real direction of US tariffs is not to reduce its deficit, but to reduce China’s exports, reduce China’s surplus, and then curb China’s development. To put it bluntly, the United States is unwilling to see the development of China, China’s strong. The U.S. government has repeatedly expressed its strong willingness to maintain “America First”. Trump made it clear: “When I took office, the problem we faced was that China would surpass us in a very short time. But that won’t happen again.” Why won’t it happen again? Because the United States is doing its utmost to curb it, and he believes that he can successfully curb China’s momentum of development through trade wars, just as he did against Japan. Trump is not the first and probably not the last person to curb China’s development. A former president of the United States once said clearly: “If more than one billion Chinese residents live like Australians and Americans now, then all of us will be in a very tragic situation, because that is beyond the capacity of the planet.” To curb China’s development, the most effective way is to eliminate China’s institutional advantages. Americans know this very well, so they use the hand of trade and economy to wave tariff sticks, intending to force China to sign an alliance under the city and abandon its institutional advantages. But China is not China 100 years ago. Economic and trade issues can be discussed. However, it is absolutely unacceptable for us to interfere with our political system and sovereignty under the guise of trade. (three) In the economic and trade negotiations, the reason why the United States dares to continue to make big sticks and exert extreme pressure is the asymmetry of trade between China and the United States. America seems to have more bullets than us. However, the number of hand neutron bombs does not determine the victory or defeat of the war. The victory or defeat of the war depends on the will of both sides, the spirit of both sides and the endurance of both sides. Looking back on the war of resistance against the United States and aid to the DPRK, the volunteer military with single clothes and potatoes and rifles defeated the American army, which had the most sophisticated equipment at that time. At that time, China had fewer bullets than it does now, but we still won. Since ancient times, China has not been a bullying country. The Chinese people have a great spirit of resistance since ancient times. Today, China has not only a great spirit of struggle, but also a strong ability to fight. The Chinese cherish peace and value peace, but they will not compromise and seek peace. “Friends come with good wine, jackals come with shotguns.” Talk about it, we welcome each other with good wine, fight, we are not afraid, there are shotguns. Chinese people are not troublesome, but they are not afraid of things. When they shine their sword, they must shine their sword. (Wen/Chen Zhuang) (Responsibility: Bai Yu) 转载：人民网 Reprint: people.cn","link":"/2019/05/16/e7-be-8e-e5-9b-bd-e8-b4-b8-e6-98-93-e6-88-98-e7-9a-84-e5-ae-9e-e8-b4-a8-e6-98-af-e9-81-8f-e5-88-b6-e4-b8-ad-e5-9b-bd-ef-bc-81the-essence-of-the-us-trade-war-is-to-contain-china-ef-bc-81/"},{"title":"清北学堂noip2019-Day1","text":"清北学堂noip2019-Day1 贪心算法 P.S. 每道题的代码我之后补加。。。 problem 1：Chocolate[Chocolate](https://www.luogu.org/problemnew/show/P3173)一块$n\\times m$的巧克力， 切成$n\\times m$块。 巧克力上共有$n-1$条横线和$m-1$条竖线，每次沿着一条线将巧克力切开。 无论切割长短，横线切一次的代价是$y_1,y_2,y_3,…,y_{n-1}$，竖线是$x_1,x_2,x_3,…,x_{m-1}$。 求最小总代价。 $n,m\\leq 10^5$ [题解](https://www.luogu.org/problemnew/solution/P3173)横向切会使纵向次数+1，纵向同理。 所以肯定先切大的，再切小的。 于是把横纵放到一起排序，依次取最大值统计答案即可。 problem 2[USACO Allowance](https://www.luogu.org/problemnew/show/P2376) John决定每个星期给b一点零花钱 j有一些硬币， 共n种面额。每一个面额都能整除比他大的所有面额。 他想用给定的硬币集合（给出硬币种类及数量），每个星期至少给b某个零花钱的数目C。 请计算他最多能给多少星期零花钱。 [题解](https://www.luogu.org/problemnew/solution/P2376) 阶段一：尽快接近C，用大面额的凑。 阶段二：超过C尽量少，用小面额的凑。 开始能用大面额就用大面额，直到凑到的$sum + a_i&gt;C$，然后尽量用小的凑，直到$sum+a_i&gt;C$。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;int n, c;struct node{ int v, b;}a[30];int k;int ans;bool cmp(const node &amp;a, const node &amp;b){ return a.v &lt; b.v;}int main(){ scanf(\"%d%d\", &amp;n, &amp;c); for(int i = 1; i &lt;= n; i++){ int v, b; scanf(\"%d%d\", &amp;v, &amp;b); if(v &gt;= c) ans += b; else a[++k].v = v, a[k].b = b; } sort(a + 1, a + k + 1, cmp); printf(\"%d\\n\", ans); for(int i = 1; i &lt;= k; i++){ printf(\"%d %d\\n\", a[i].v, a[i].b); } while(true){ int x = c; for(int i = k; i &gt;= 1; i--){ while(a[i].b &gt; 0 &amp;&amp; x &gt;= a[i].v){ x -= a[i].v; a[i].b--; } } if(x &gt; 0){ for(int i = 1; i &lt;= k; i++){ if(a[i].b &gt; 0 &amp;&amp; x &lt;= a[i].v){ x -= a[i].v; a[i].b--; } } } if(x &gt; 0) break; ans++; } printf(\"%d\", ans); return 0;} problem 3[Face the Right Way](https://www.luogu.org/problemnew/show/P2882)给出一个长为n的F/B序列，n&lt;=5000。 你可以每次选择连续长度为k的一段，进行FB转换。 使得最后整个序列全为F。 求最少的操作次数和对应的最小长度。 [题解](https://www.luogu.org/problemnew/solution/P2882?page=2) 因为同一个点翻转两次就与没有翻转的效果相同了，因此我们有一个贪心策略为： 左到右对于出现的每一个B翻转一次从当前点开始的区间，就能保证是最优解。 但是我们会发现这样是$n^2$的，再枚举长度，就变为了$n^3$。 因此，需要对区间翻转差分一下，总时间复杂度就是$n^2$的了。![p3](/img/p3.png) 然后下面是我的代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;int n, a[5009], dif[5009];int mincnt = 0x3f3f3f3f, minlen;int main(){ scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; i++){ char c; cin&gt;&gt;c; a[i] = (c == 'F'); } for(int len = 1; len &lt;= n; len++){ int now = 0, cnt = 0; bool flag = true; for(int i = 1; i &lt;= n; i++) dif[i] = 0; for(int i = 1; i &lt;= n; i++){ now ^= dif[i]; if(!(a[i] ^ now)){ if(i + len - 1 &gt; n){ flag = false; break; } now ^= 1; dif[i] ^= 1; dif[i + len] ^= 1; cnt++; } } if(flag){ if(cnt &lt; mincnt){ minlen = len; mincnt = cnt; } } } printf(\"%d %d\\n\", minlen, mincnt); return 0;} problem 4[旅行家的预算](https://www.luogu.org/problemnew/show/P1016)一个旅行家想驾驶汽车以最少的费用从一个城市到另一个城市（假设出发时油箱是空的）。 给定两个城市之间的距离D1、汽车油箱的容量C（以升为单位）、每升汽油能行驶的距离D2、出发点每升汽油价格P和沿途油站数N（N可以为零），油站i离出发点的距离Di、每升汽油价格Pi（i=1,2,…,N）。 求最少的总费用，如果无法到达目的地，则输出“No Solution”。 [题解](https://www.luogu.org/problemnew/solution/P1016)枚举途中经过的加油站，每经过一个加油站，计算一次花费 在一个加油站所需要加的油，就是能够支持它到达下一个油价比它低的加油站的量 如果在这个加油站即使加满油，都不能到达一个比它油价低的加油站，就把油箱加满，前往能够到达的加油站中油价最低的那个 如果在这个加油站即使加满油，都不能到达任意一个加油站，也不能到达终点城市，说明无解 problem 5[The Minima Game](https://www.luogu.org/problemnew/show/P3507)给出N个正整数，AB两个人轮流取数，A先取。每次可以取任意多个数，直到N个数都被取走。每次获得的得分为取的数中的最小值，A和B的策略都是尽可能使得自己的得分减去对手的得分更大。在这样的情况下，最终A的得分减去B的得分为多少。 $n\\leq 10^5$ [题解](https://www.luogu.org/problemnew/solution/P3507) 身临其境的分析： 一方面要让自己取的数中的最小值尽量大， 一方面要让剩下数中的最大值尽量小。 故先手肯定会从大到小的取数， 并且取出的数是连续的一段。 **证明：** 从大到小取数显然，若不是连续取数，则留下的数更多，大的数更多，会给对方更多的机会。所以必然是连续取数。 所以我们倒着来考虑一下，将所有的数从小到大排列之后，f[i]表示两人取完前i个数，先手减去后手的最大值。(这里先手后手是相对的，因为我们是倒序的，和实际取法是完全相反的，它实际上是处理出了1~i个数的情况下的最优解，A先从i开始往左边取，所以说考虑先手减后手最大值） problem 6[[ZJOI2005]午餐](https://www.luogu.org/problemnew/show/P2577)N人来到了食堂，每个人由自己的打饭时间和吃饭时间。 食堂有两个打饭窗口，我们要把所有的人分成两队，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口。每个人打完饭后立刻开始吃。 现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。 两个窗口是并行操作互不影响的，要求输出最佳方案下所有人吃完饭的时刻。 [题解](https://www.luogu.org/problemnew/solution/P2577)贪心的理解，如果所有人都要早点走 那么吃饭时间长的就先吃，吃饭时间短的就晚点吃 所以，按照吃饭时间排序 每个人吃完饭的时间之和前面所有人的打饭的时间和有关 $f[i][j][k]$表示当前做到第i个人，第一列，第二列前面的人的打饭时间之和分别为$j,k$，最后一个人吃完饭的最小时间. 但直接三维状态会炸？ 所以，状态是f[i][j]表示当前做到第i个人， 第一列队伍前面所有人打饭的时间和是j时最后一个人吃完饭的最小时间 如果把这个人放在第一列$f[i][j]=min(f[i][j],max(f[i−1][j−Get[i]],j+eat[i]))$ 另外把这个人放在第二列$f[i][j]=max(f[i−1][j],sum[i]−j+eat[i])$ problem 7Water Tanks给你一棵树，k升水，p块钱，进行一次游戏。 在游戏进行前，可以在任意个节点上放置1升水（总数不超过k） 游戏进行若干轮，每轮游戏开放所有节点，可以选择若干个节点关闭，代价为该节点的水数量。然后所有未关闭节点的水流向它的父亲(不会连续移动)。 最后，根节点中的水会被取走，水的数量为该轮游戏的盈利。 求最大盈利-代价。 题解在放置水的选择上，应该尽量选择深度相邻的节点，即将所有节点按照深度排序后，所选择放水的节点应该是连续的一段。 考虑选择某段区间后，所需要花费的钱。 假设深度范围[l , r] ，某个深度的点为 a[i] ，则花费钱为sigma(a[i]*(r-i)) 用两个指针进行扫描即可。","link":"/2019/07/13/清北学堂noip2019-Day1/"},{"title":"清北学堂noip2019-Day3","text":"数据结构 并查集problem 1[UVA1329 Corporative Network](https://www.luogu.org/problemnew/show/UVA1329)![d3p1](/img/d3p1.png) 题解 注意I操作与并查集的加边操作类似 只需在维护父亲节点时，同时维护到父亲节点的距离即可 ![d3p2](/img/d3p2.png) 简单滴很 线段树problem 1poj2892题目描述： 有一个长度为n的链，初始每个点都是完好的 需要支持m个操作 (1) D x：表示将第x个点摧毁 (2) Q x：表示询问包含x的未被摧毁的最长子链长度 (3) R ：表示撤销上一个D操作 注意每个点可能被摧毁多次 题解 显然，每次直接修改，使用for循环判断会超时。 这时就需要使用数据结构维护。 考虑使用线段树。 在每个节点保存的信息 区间里的点是否全都是完好的 从区间左端点开始向右延伸最长完好子链 从区间右端点开始向左延伸最长完好子链 修改时修改每个受影响的线段树节点 查询时拆分区间查询 ![](/img/d3p3.png)![](/img/d3p4.png)![](/img/d3p5.png)![](/img/d3p6.png) problem 2[线段树2](https://www.luogu.org/problemnew/show/P3373)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=100000;ll tree[4*MAXN+10],add[4*MAXN+10],mul[4*MAXN+10],a[MAXN+10],p;void build(int k,int l,int r){ add[k]=0;mul[k]=1; if(l==r){ tree[k]=a[r]; return; } int mid=(l+r)&gt;&gt;1; build(k&lt;&lt;1,l,mid); build(k&lt;&lt;1|1,mid+1,r); tree[k]=(tree[k&lt;&lt;1]+tree[k&lt;&lt;1|1])%p;}void pushdown(int k,int l,int r){ int mid=(l+r)&gt;&gt;1; tree[k&lt;&lt;1]=(tree[k&lt;&lt;1]*mul[k]+add[k]*(mid-l+1))%p; tree[k&lt;&lt;1|1]=(tree[k&lt;&lt;1|1]*mul[k]+add[k]*(r-mid))%p; mul[k&lt;&lt;1]=(mul[k]*mul[k&lt;&lt;1])%p; mul[k&lt;&lt;1|1]=(mul[k]*mul[k&lt;&lt;1|1])%p; add[k&lt;&lt;1]=(add[k&lt;&lt;1]*mul[k]+add[k])%p; add[k&lt;&lt;1|1]=(add[k&lt;&lt;1|1]*mul[k]+add[k])%p; mul[k]=1; add[k]=0;}void m_1(int k,int l,int r,int x,int y,ll v){ if(y&lt;l||x&gt;r) return; if(x&lt;=l&amp;&amp;y&gt;=r){ mul[k]=mul[k]*v%p; add[k]=add[k]*v%p; tree[k]=tree[k]*v%p; return; } pushdown(k,l,r); int mid=(l+r)&gt;&gt;1; m_1(k&lt;&lt;1,l,mid,x,y,v); m_1(k&lt;&lt;1|1,mid+1,r,x,y,v); tree[k]=(tree[k&lt;&lt;1]+tree[k&lt;&lt;1|1])%p;}void m_2(int k,int l,int r,int x,int y,ll v){ if(y&lt;l||x&gt;r) return; if(x&lt;=l&amp;&amp;y&gt;=r){ add[k]=(add[k]+v)%p; tree[k]=(tree[k]+v*(r-l+1)%p)%p; return; } pushdown(k,l,r); int mid=(l+r)&gt;&gt;1; m_2(k&lt;&lt;1,l,mid,x,y,v); m_2(k&lt;&lt;1|1,mid+1,r,x,y,v); tree[k]=(tree[k&lt;&lt;1]+tree[k&lt;&lt;1|1])%p;}ll query(int k,int l,int r,int x,int y){ if(y&lt;l||x&gt;r) return 0; if(x&lt;=l&amp;&amp;y&gt;=r){ return tree[k]%p; } pushdown(k,l,r); int mid=(l+r)&gt;&gt;1; return (query(k&lt;&lt;1,l,mid,x,y)+query(k&lt;&lt;1|1,mid+1,r,x,y))%p;}int main(){ int n,m; cin&gt;&gt;n&gt;&gt;m&gt;&gt;p; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; } build(1,1,n); for(int i=1;i&lt;=m;i++){ int op,x,y; ll z; cin&gt;&gt;op; if(op==1){ cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; m_1(1,1,n,x,y,z); } else if(op==2){ cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; m_2(1,1,n,x,y,z); } else{ cin&gt;&gt;x&gt;&gt;y; cout&lt;&lt;query(1,1,n,x,y)&lt;&lt;endl; } } return 0;} 启发式合并并查集按秩合并123456789101112131415161718192021222324int find(int x){ while(x!=fa[x]) x=fa[x]; return x;}int main(){ int n,m; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) fa[i]=i,siz[i]=1; while(m--) { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); x=find(x);y=find(y); if(x!=y) { if(siz[x]&gt;siz[y]) swap(x,y); fa[x]=y; siz[y]+=siz[x]; } } return 0;} problem 1[[USACO14MAR] The Lazy Cow_Gold 懒惰的牛(金)](https://www.luogu.org/problemnew/show/P4876)我没听懂。。。代码如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#define N 210000using namespace std;struct node{int id1,id2,d;}A[N],B[N];struct node1{int l,r,lc,rc,d,lz;}lt[4*N];struct node2{int x,next;}e[N*2];int n,m,num1,num2,a[N][5],l1,l2,tl,first[2*N],len;int cmp(node x,node y){ return x.d &lt; y.d;} int getint(){ int num = 0; char c = 0; while (c &lt; '0' || c &gt; '9') c = getchar(); while (c &gt;= '0' &amp;&amp; c &lt;= '9') { num = num * 10 + c - '0'; c = getchar(); } return num;}void bt(int l,int r){ int now=++tl; lt[now].l=l;lt[now].r=r; lt[now].lc=lt[now].rc=lt[now].d=lt[now].lz=0; if(l&lt;r) { int mid=(l+r)/2; lt[now].lc=tl+1;bt(l,mid); lt[now].rc=tl+1;bt(mid+1,r); }}void down(int now){ int lc=lt[now].lc,rc=lt[now].rc; if(lc) lt[lc].lz+=lt[now].lz; if(rc) lt[rc].lz+=lt[now].lz; lt[now].d+=lt[now].lz; lt[now].lz=0;}void upd(int now){ int lc=lt[now].lc,rc=lt[now].rc; if(lc &amp;&amp; lt[lc].lz) down(lc); if(rc &amp;&amp; lt[rc].lz) down(rc); lt[now].d=max(lt[lc].d,lt[rc].d);}void change(int now,int l,int r,int d){ int lc=lt[now].lc,rc=lt[now].rc,mid=(lt[now].l+lt[now].r)/2; if(lt[now].lz) down(now); if(lt[now].l==l &amp;&amp; lt[now].r==r) {lt[now].lz+=d;return;} if(mid&gt;=r) change(lc,l,r,d); else if(l&gt;mid) change(rc,l,r,d); else change(lc,l,mid,d),change(rc,mid+1,r,d); upd(now);}int find(int now){ if(lt[now].lz) down(now); return lt[now].d;}void ins(int x,int y){ len++; e[len].x=y; e[len].next=first[x]; first[x]=len;}int main(){ n = getint(); m = getint(); num1=num2=0; m*=2; for(int i=1;i&lt;=n;i++) { for (int j = 0; j &lt;= 2; j++) a[i][j] = getint(); int x=a[i][1]*2,y=a[i][2]*2; a[i][1]=(x+y)/2;a[i][2]=(y-x)/2; a[i][3]=a[i][1]-m;a[i][4]=a[i][2]-m; A[++num1].id1=i;A[num1].id2=1;A[num1].d=a[i][1]; B[++num2].id1=i;B[num2].id2=2;B[num2].d=a[i][2]; A[++num1].id1=i;A[num1].id2=3;A[num1].d=a[i][1]-m; B[++num2].id1=i;B[num2].id2=4;B[num2].d=a[i][2]-m; } //for(int i=1;i&lt;=n;i++) printf(\"%d %d %d %d\\n\",a[i][1],a[i][2],a[i][3],a[i][4]); sort(A+1,A+num1+1,cmp); sort(B+1,B+num2+1,cmp); int k=1; a[A[1].id1][A[1].id2]=k; for(int i=2;i&lt;=num1;i++) { if(A[i].d!=A[i-1].d) k++; a[A[i].id1][A[i].id2]=k; } l1=k; k=1; a[B[1].id1][B[1].id2]=k; for(int i=2;i&lt;=num2;i++) { if(B[i].d!=B[i-1].d) k++; a[B[i].id1][B[i].id2]=k; } l2=k; len=0; for(int i=1;i&lt;=n;i++) { ins(a[i][3],i); ins(a[i][1]+1,-i); } //for(int i=1;i&lt;=n;i++) printf(\"%d %d %d %d\\n\",a[i][1],a[i][2],a[i][3],a[i][4]); tl=0; bt(1,l2); int ans=0; for(int i=1;i&lt;=l1;i++) { for(k=first[i];k;k=e[k].next) { int x=e[k].x,d; if(x&gt;0) d=a[x][0]; else {x=abs(x);d=-a[x][0];} int l=a[x][4],r=a[x][2]; change(1,l,r,d); } ans=max(ans,find(1)); } printf(\"%d\\n\",ans); return 0;} problem 2UVALive7141无穷大的地图上有n个兵，现在给一个W*H的炸弹，一次能炸死它所在行列上所有的士兵。不能放在士兵上面。 问：一次能最多干掉多少小兵？ 题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#define N 110000using namespace std;struct node{int d,id1,id2;}A[N*2],B[N*2];struct node1{int l,r,lc,rc;long long d,maxd;}lt[N*4];vector&lt;int&gt; v[2*N];int len,n,w,h,num1,num2,tot1,tot2,a[N][4];long long ans,sx[2*N],sy[2*N];int tl,inf=N;int cmp(void const *xx,void const *yy){ node x=*(node*)xx,y=*(node*)yy; if(x.d&lt;y.d) return -1; return 1;}void bt(int l,int r){ int now=++tl; lt[now].l=l;lt[now].r=r; lt[now].d=lt[now].maxd=lt[now].lc=lt[now].rc=0; if(l&lt;r) { int mid=(l+r)/2; lt[now].lc=tl+1;bt(l,mid); lt[now].rc=tl+1;bt(mid+1,r); lt[now].maxd=max(lt[lt[now].lc].maxd,lt[lt[now].rc].maxd); } else lt[now].maxd=sy[l];}void down(int now){ int lc=lt[now].lc,rc=lt[now].rc; if(lc) lt[lc].d+=lt[now].d; if(rc) lt[rc].d+=lt[now].d; lt[now].maxd+=lt[now].d; lt[now].d=0;}int find(int now){ if(lt[now].d) down(now); return lt[now].maxd;}void upd(int now){ int lc=lt[now].lc,rc=lt[now].rc; if(lc &amp;&amp; lt[lc].d) down(lc); if(rc &amp;&amp; lt[rc].d) down(rc); lt[now].maxd=max(lt[lc].maxd,lt[rc].maxd);}void change(int now,int l,int r,int d){ int lc=lt[now].lc,rc=lt[now].rc,mid=(lt[now].l+lt[now].r)/2; if(lt[now].d) down(now); if(lt[now].l==l &amp;&amp; lt[now].r==r) {lt[now].d+=d;return;} if(mid&gt;=r) change(lc,l,r,d); else if(l&gt;mid) change(rc,l,r,d); else change(lc,l,mid,d),change(rc,mid+1,r,d); upd(now);}int main(){ int z,zu=0; scanf(\"%d\",&amp;z); while(z--) { zu++; scanf(\"%d%d%d\",&amp;n,&amp;w,&amp;h); tot1=tot2=0; for(int i=1;i&lt;=n;i++) { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); A[++tot1].d=x;A[tot1].id1=i;A[tot1].id2=0; B[++tot2].d=y;B[tot2].id1=i;B[tot2].id2=1; A[++tot1].d=x-w+1;A[tot1].id1=i;A[tot1].id2=2; B[++tot2].d=y-h+1;B[tot2].id1=i;B[tot2].id2=3; } qsort(A+1,tot1,sizeof(node),cmp); qsort(B+1,tot2,sizeof(node),cmp); a[A[1].id1][A[1].id2]=1; num1=1; for(int i=2;i&lt;=tot1;i++) { if(A[i].d!=A[i-1].d) num1++; a[A[i].id1][A[i].id2]=num1; } a[B[1].id1][B[1].id2]=1; num2=1; for(int i=2;i&lt;=tot2;i++) { if(B[i].d!=B[i-1].d) num2++; a[B[i].id1][B[i].id2]=num2; } for(int i=1;i&lt;=num1;i++) sx[i]=0; for(int i=1;i&lt;=num2;i++) sy[i]=0; for(int i=1;i&lt;=num1;i++) v[i].clear(); for(int i=1;i&lt;=n;i++) { int x1=a[i][0],y1=a[i][1],x2=a[i][2],y2=a[i][3]; sx[x2]++;sx[x1+1]--; sy[y2]++;sy[y1+1]--; v[x2].push_back(i); v[x1+1].push_back(-i); } ans=0; for(int i=1;i&lt;=num1;i++) { sx[i]+=sx[i-1]; ans=max(ans,sx[i]); } for(int i=1;i&lt;=num2;i++) { sy[i]+=sy[i-1]; ans=max(ans,sy[i]); } tl=0; bt(1,num2); for(int i=1;i&lt;=num1;i++) { for(int j=0;j&lt;v[i].size();j++) { int k=v[i][j],l,r; l=a[abs(k)][3];r=a[abs(k)][1]; if(k&gt;0) change(1,l,r,-inf); else change(1,l,r,inf); } int tt=find(1); if(tt&gt;0) ans=max(ans,tt+sx[i]); } printf(\"Case #%d: %lld\\n\",zu,ans); } return 0;}","link":"/2019/07/15/清北学堂noip2019-Day3/"},{"title":"清北学堂noip2019-Day2","text":"分治算法（持续更新） 最小值最大，二分 problem 1[愤怒的牛](https://www.luogu.org/problemnew/show/P2678)n个点，取出m个点使得相邻的点的最小距离最大 $n\\leq 10^5, m\\leq n$ 最小距离最大 如果太大了，会选不出m个点 限制的最小距离越大，选出的点越少 符合二分性质题解 二分最小距离k，然后贪心验证。 首先第一个点必须取，然后后面的点超过k就取。 最后看能不能取完m个点。 复杂度$O(nlog_2n)$ 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;int n, m, d, a[50010];bool judge(int x){ int tot = 0; int i = 0; int now = 0; while (i &lt; n+1){ i++; if (a[i] - a[now] &lt; x) tot++; else now = i; } if (tot &gt; m) return false; else return true;}int main(){ cin&gt;&gt;d&gt;&gt;n&gt;&gt;m; for(int i = 1; i &lt;= n; i++){ cin&gt;&gt;a[i]; } a[n + 1] = d; int l = 1,r = d,res = 0; while(l &lt;= r){ int mid=(l + r) / 2; if(judge(mid)){ res = mid; l = mid + 1; } else{ r = mid - 1; } } cout&lt;&lt;res; return 0;} problem 2[Slicing](https://www.luogu.org/problemnew/show/P3017)给定$n\\times m$的数字矩阵，要求横着切$A - 1$刀，对每块再竖着切$B-1$刀。 使得最小子矩阵最大。 $n,m\\leq 500$ 题解 二分，然后贪心切 每次扫一行，看这行和上次切割的行之间能否满足二分条件k，如果能就横切+1，最后看可行条能否到n。 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;int r, c, aa, bb;int a[509][509], sum[509][509];int ans;bool check(int x){ int num = 0, now = 0; for(int i = 1; i &lt;= r; i++){ int s = 0, cnt = 0; for(int j = 1; j &lt;= c; j++){ if(s + sum[i][j] - sum[i][j-1] - sum[now][j] + sum[now][j-1] &lt; x) s += sum[i][j] - sum[i][j-1] - sum[now][j] + sum[now][j-1]; else{ cnt++; s = 0; } } if(cnt &gt;= bb){ num++; now = i; } } if(num &gt;= aa) return 1; else return 0;}int main(){ scanf(\"%d%d%d%d\", &amp;r, &amp;c, &amp;aa, &amp;bb); for(int i = 1; i &lt;= r; i++){ for(int j = 1; j &lt;= c; j++){ scanf(\"%d\", &amp;a[i][j]); sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + a[i][j]; } } int ll = 0, rr = sum[r][c]; while(ll &lt;= rr){ int mid = (ll + rr) / 2; if(check(mid)){ ll = mid + 1; } else rr = mid - 1; } printf(\"%d\\n\", ll - 1); return 0;} problem 4[花盆](https://www.luogu.org/problemnew/show/P2698)给出n个点坐标，根据x轴选定区间$[L,R]$，使得其中的点的y值的最大和最小之差&gt;=D。求$min\\{R-L\\}$ $n\\leq 10^5$ 题解二分枚举区间大小，然后通过单调队列求出每个区间最大值和最小值，最后得出答案即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;int n, d;struct node{ int x, y;}a[100009];bool cmp(const node &amp;a, const node &amp;b){ return a.x &lt; b.x;}int qmin[100009], qmini[100009], qmax[100009], qmaxi[100009];int headmin, tailmin, headmax, tailmax;bool check(int x){ headmin = headmax = 1; tailmin = tailmax = 0; for(int i = 1; i &lt;= n; i++){ while(headmin &lt;= tailmin &amp;&amp; qmin[tailmin] &gt;= a[i].y) tailmin--; qmin[++tailmin] = a[i].y; qmini[tailmin] = a[i].x; while(headmin &lt;= tailmin &amp;&amp; qmini[headmin] &lt; qmini[tailmin] - x) headmin++; while(headmax &lt;= tailmax &amp;&amp; qmax[tailmax] &lt;= a[i].y) tailmax--; qmax[++tailmax] = a[i].y; qmaxi[tailmax] = a[i].x; while(headmax &lt;= tailmax &amp;&amp; qmaxi[headmax] &lt; qmaxi[tailmax] - x) headmax++; int cz = qmax[headmax] - qmin[headmin]; if(cz &gt;= d) return true; } return false;}int main(){ scanf(\"%d%d\", &amp;n, &amp;d); for(int i = 1; i &lt;= n; i++){ scanf(\"%d%d\", &amp;a[i].x, &amp;a[i].y); } sort(a + 1, a + n + 1, cmp); int l = 1, r = a[n].x + 5; while(l &lt; r){ int mid = (l + r) / 2; if(check(mid)){ r = mid; } else l = mid + 1; } if(l &gt; a[n].x) printf(\"%d\\n\", -1); else printf(\"%d\\n\", l); return 0;} problem 5[组题](https://www.luogu.org/problemnew/show/UVA1451) 给出一个长度为n的序列，求一段长度大于等于k的字串。 使得它们的平均值最大。 $n\\leq 10^5, k\\leq n$题解 分数规划，二分答案（平均值） 让每个数减去平均值，检测是否有一个长度大于等于k的字串，使其和为非负。 平均值问题转化为求和问题。 把区间和转化为前缀和相减的形式。 枚举右端点i，判定的就是$sum[i]-min\\{sum[j]\\}(0\\leq j\\leq i-k)$是否大于等于0。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;int T, n, len;double a[100009], a1[100009], sum[100009];const double jd = 1e-5;bool check(double x, bool op){ int ansl, ansr; double ans = -0x3f3f3f3f; for(int i = 1; i &lt;= n; i++) a1[i] = a[i] - x; for(int i = 1; i &lt;= n; i++) sum[i] = sum[i - 1] + a1[i]; double minx = 0x3f3f3f3f, l; for(int i = len; i &lt;= n; i++){ if(sum[i - len] &lt;= minx) l = i - len + 1; minx = min(minx, sum[i - len]); if(sum[i] - minx &gt; ans + jd){ ans = sum[i] - minx; ansl = l; ansr = i; } } if(op == 1) printf(\"%d %d\\n\", ansl, ansr); return ans &gt;= 0;}int main(){ scanf(\"%d\", &amp;T); while(T--){ scanf(\"%d%d\", &amp;n, &amp;len); string s; cin&gt;&gt;s; for(int i = 1; i &lt;= n; i++){ a[i] = s[i - 1] - '0'; } double l = 0, r = 1; while(l &lt; r - jd){ double mid = (l + r) / 2; if(check(mid, 0)) l = mid; else r = mid; } check(l + jd, 1); } return 0;} problem 6猜数 给一个长度为n的数列，但不知道这个数列。 有q条限制条件$l_i,r_i,x_i$，表示$(l,r)$所有数的最小值为x。 问从第几个限制条件开始出现矛盾，无矛盾输出0。 $n\\leq 10^6,q\\leq 25000$ 例如：$(3,5)$最小值为2，$(1,7)$最小值为4，矛盾。题解 会矛盾的情况就是出现了包含关系，并且被包含的区间最小值更小。 先对区间按x排序 处理某个区间时，发现已经被之前的某个区间$(l,r)$包含了。矛盾。 problem 7Tree 给一个无向带权连通图，每条边是黑色或者白色。求一颗最小权的恰好有need条白色边的生成树。 题目保证有解，$n,m\\leq 10^5$分析及题解 生成树权值变化时，白边数目可能变大或者变小。 不能直接二分。 problem 8[电话线](https://www.luogu.org/problemnew/show/P1948) 给出n个点m条边的DAG 可以选择k条边，使其权值变为0 需要让1-n的最长路径最短 $n,m\\leq 50000$ problem 9[Dynamite](https://www.luogu.org/problemnew/show/P3523) 给出一颗n个节点的树，上面有k个关键节点。 树上选m个点，求最小化关键节点到选择点的最大距离。 $n\\leq 10^5$分析 二分一个数L表示答案 问题转化为一个判定问题，判定能否用m个点覆盖（范围为L）整个树上的关键点。 树形DP，考虑子树情况： 子树内关键点都覆盖完了，并且子树内有选择点的贡献可以向上。 子树内有不被覆盖的点，没有节点可以继续贡献。 子树内都被覆盖，但没有对上面的贡献 搜索算法problem 1装箱 n个物品，每个物品大小为$w_i$。箱子大小为m，求最少箱子数目，能装下所有物品。分析，题解 搜索每一个物品，装入到之前能装的箱子中，或者开一个新的箱子，$dfs(x)$代表搜到了第几个物品。 物品从大到小排序，再依次搜索。 当前搜到了最优解已经为$m$，那么当前步数$&gt;=m$可以直接return，因为不会最优。 进一步剪枝。 考虑没有搜的物品的总和减去没有被填满的空间/m就是至少要新开的箱子的空间。然后新箱子数+已有箱子数&gt;=m就可以剪掉。 排序和预估下界都是常见剪枝技巧。 另外一种方法： 先贪心一遍，求出较优解，然后进行搜索-最优性剪枝。 problem 2天平 有n个砝码$(n\\leq 1000)$，重量为$w[i]$. 从中选择一些砝码，使得这些砝码总重量最大，但不超过c。 $w[i]$按照递增顺序给出并且保证$w[i]&gt;=w[i-1]+w[i-2]$ 分析题解 因为$w[i]&gt;=w[i-1]+w[i-2]$,所以n实际上是45左右（斐波那契）。 dfs(int k, int tot)//搜到第k个数，当前总和是tot。 剪枝： 优化选砝码（不跳过），并且优先选择重量大的砝码，尽早更新ans。 如果当前tot + 剩下砝码的总重（前缀和） &lt; ans，return。可行性剪枝。 折半搜索：n=40的一类子集问题， $40=2\\times 20$ $n=20$类问题，二进制枚举即可。 把40拆成两个20算。 要求$n=40$时，有多少个子集的权值和大于等于L。 物品分成前一半和后一半1 2 3 4|5 6 7 8 $2^{20}\\{A\\},2^{20}\\{B\\}$ 合并左右两子集，得到完整的子集和。 具体。。。没有懂，百度吧。。。 problem 3虫食算如果这个算式是$N$进制的，我们就取英文字母表午的前N个大写字母来表示这个算式中的$0$到$N-1$这$N$个不同的数字：但是这$N$个字母并不一定顺序地代表$0$到$N-1$。输入数据保证$N$个字母分别至少出现一次。 1234 BADC+CBDA—————— DCCC 上面的算式是一个4进制的算式。很显然，我们只要让$ABCDABCD$分别代表$01230123$，便可以让这个式子成立了。你的任务是，对于给定的$N$进制加法算式，求出$N$个不同的字母分别代表的数字，使得该加法算式成立。输入数据保证有且仅有一组解。 分析&amp;题解 从右往左依次尝试填充数字 剪枝 在尝试放新的数字的时候，从n-1道0放会快很多。 每次搜的时候，看自己左边的列如果三行都确定了的话，就检查是否合法。 problem 4[循环赛](https://www.luogu.org/problemnew/show/P3154) n个队伍进行循环赛，胜者得3分，平得1分，负得0分，现在给出各队分数，求可能的胜负情况数。 $n\\leq 8$[分析](https://www.luogu.org/problemnew/solution/P3154)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n;int a[9], tmp[9];int totwin, totfl;bool cmp(const int &amp;a, const int &amp;b){ return a &gt; b;}map&lt;ll, ll&gt; mapx;ll dfs(ll x, ll y){ ll sum = 0; if(x &gt;= n) return 1; if(y &gt; n){ if(tmp[x] != a[x]) return 0; int f[9]; for(int i = x + 1; i &lt;= n; i++){ f[i] = a[i] - tmp[i]; } ll hash = 0; sort(f + x + 1, f + n + 1); for(int i = x + 1; i &lt;= n; i++){ hash = hash * 27 + f[i]; } if(mapx[hash] != 0) return mapx[hash]; else return mapx[hash] = dfs(x + 1, x + 2); } if(tmp[x] + 3 &lt;= a[x] &amp;&amp; totwin){ tmp[x] += 3; totwin--; sum += dfs(x, y + 1); tmp[x] -= 3; totwin++; } if(tmp[y] + 3 &lt;= a[y] &amp;&amp; totwin){ tmp[y] += 3; totwin--; sum += dfs(x, y + 1); tmp[y] -= 3; totwin++; } if(tmp[x] + 1 &lt;= a[x] &amp;&amp; tmp[y] + 1 &lt;= a[y] &amp;&amp; totfl){ tmp[x]++, tmp[y]++, totfl--; sum += dfs(x, y + 1); tmp[x]--, tmp[y]--, totfl++; } return sum;}int main(){ int s = 0; scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; i++){ scanf(\"%d\", &amp;a[i]); s += a[i]; } sort(a + 1, a + n + 1, cmp); totwin = s - n * n + n; totfl = (n * n - n) / 2 - totwin; ll ans = dfs(1, 2); printf(\"%lld\\n\", ans); return 0;} 迭代加深搜索problem 1[埃及分数](https://www.luogu.org/problemnew/show/UVA12558)太难了吧。。。 problem 2 P.S.其实刚刚打洛谷月赛去了，还是回来听听。 骑士精神在一个5×5的棋盘上有12个白色的骑士和12个黑色的骑士， 且有一个空位。在任何时候一个骑士都能按照骑士的走法（它可以走到和它横坐标相差为1，纵坐标相差为2或者横坐标相差为2，纵坐标相差为1的格子）移动到空位上。 给定一个初始的棋盘，怎样才能经过移动变成如下目标棋盘： 为了体现出骑士精神，他们必须以最少的步数完成任务。 ![骑士](/img/骑士.png) 分析&amp;题解最小步数这类，适合用迭代加深搜索。 用空格走代替骑士。搜索时记录上一步防止来回走。 不需要每次判断是否都在位置，可以计算出不在对应位置的骑士有多少个。而且每次复原一个骑士至少需要一步。 启发式搜索（A*） $f[x]=g[x]+h[x]$problem 1k短路问题 给出一个图，和s，t，求s到t的第k短路。 考虑用搜索的遍历，搜出1-k短路。[分析](https://www.luogu.org/problemnew/show/P2483) $f[x] = g[x] + h[x]$ $g[x]$就是遍历过程中，s走到x的距离。 $h[x]$就是x到t的最短距离 预处理建反向图，求出t为起点的最短路。也就能得到每个点的$h[x]$ 算法流程： 维护一个优先队列，因为我们要取的是$f[x]$最优的点。 最开始加入s到队列中。 从队列中弹出$f[x]$最小的点。 把和x相邻的点y，$g[y]=g[x]+w(x,y)$，$f[y]=g[y]+h[y]$，然后放入优先队列。 如果弹出的点就是t，那我们就找到了一个解，并且tot++。 当tot为k，即找到了第k小的路径。","link":"/2019/07/14/清北学堂noip2019-Day2/"},{"title":"清北学堂noip2019-Day5","text":"动态规划 背包问题01背包 正常01背包 必须装满？ 初始化$f[i] = 0, f[other] = -\\infty$ 多重背包 二进制拆分 热身题数字三角形+ 给出一个数字三角形，从第一行走到最后一行，每次只能往正下或者正右下走。每次累积经过的数，要求和最大。 第X行第Y列这个点必须经过。 $O(n^2)$ 题解：先从第一层到第x层跑一遍数字三角形，然后把第x行除第y列所有数赋为负无穷，然后再在下边跑一次数字三角形即可。 花店橱窗问题 给定一个n*m的矩阵A(n&lt;=m)，求一个序列a1,a2,…,an满足$1&lt;=a_1&lt;a_2&lt;…&lt;a_n\\leq m$。使得$A[1][a_1]+A[2][a_2]+…+A[n][a_n]$最大。 A可能有负数。 $O(nm^2)$ 题解：$f[i,j]$表示第i行最后选到了第j列的最大值。 $f[i,j]=max\\{f[i-1,k]\\}+a[i,j](1\\leq k&lt;j)$ 烽火问题 给定n个非负整数，选择其中若干数字，使得每连续k个数中至少有一个数被选出。 要求选择的数字之和尽可能小。 $O(n^2)$ $f[i]$表示上一个数选择的是第i个数。 $f[i]=max(f[j])+a[i]$ 0/1背包进阶0/1背包+ 有n个任务，在一台机器上完成，机器一次只能做一个任务，第i个任务需要ti个连续的时刻完成，截止日期在第di个时刻。在截止日期前完成能得到收益vi。 安排顺序，使得收益最大。 $n&lt;=1000，max{di}&lt;=10000$ 0/1背包++ 有n个物品，体积为m的背包，每个物品有一个价值vi，和体积ti，选择若干物品，使得体积之和不超过m的情况下价值之和最大。 对于任意第i个物品，求第i个物品一定不在背包时的最大价值。 $n&lt;=1000，m&lt;=10000$ $f[i][j]$表示i从1到n取。 $g[i][j]$表示i从n到1取。 然后对于不取第p个，即为$f[p-1][j]+f[p+1][v-j]$ DP基础优化 减少状态数 减少状态转移时间 problem 1 在河上有一座独木桥，一只青蛙想沿着独木桥从河的一侧跳到另一侧。在桥上有一些石子，青蛙很讨厌踩在这些石子上。由于桥的长度和青蛙一次跳过的距离都是正整数，我们可以把独木桥上青蛙可能到达的点看成数轴上的一串整点：0，1，……，L（其中L是桥的长度）。坐标为0的点表示桥的起点，坐标为L的点表示桥的终点。青蛙从桥的起点开始，不停的向终点方向跳跃。一次跳跃的距离是S到T之间的任意正整数（包括S,T）。当青蛙跳到或跳过坐标为L的点时，就算青蛙已经跳出了独木桥。 题目给出独木桥的长度L，青蛙跳跃的距离范围S,T，桥上石子的位置。你的任务是确定青蛙要想过河，最少需要踩到的石子数。 $1&lt;=s&lt;=t&lt;=10，L&lt;=10^9$，石头个数&lt;=100 $f[x] = min( f[x-j] + stone[x] ), (s\\leq j\\leq t)$ 但是，x高达10^9，难以计算 但也容易发现，最多100个石子，所以很多时候两个石子距离隔得很远，这时后一石子坐标前的若干个连续的点都可达。 稍微证明一下： 当 s != t 时，存在 p 使得 s &lt;= p &lt; p+1 &lt;= t 显然有 gcd(p, p+1) = 1 当Q &gt;= p*(p-1)时，p*x + (p+1)*y = Q 一定有非负整数解 也即，当Q足够大时，可以仅通过走若干个p步和p+1步，从而走长度恰好为Q的距离 [传纸条](https://www.luogu.org/problemnew/show/P1006) 你有一个n*m的矩阵，第i行第j列有ai,j个金币，有两个人都从(1,1)出发向右或者向下走到(n,m)，并拿到经过的金币，要求获得金币个数最多。 $n,m\\leq 200$ 前缀和优化DP[花店橱窗问题](https://www.luogu.org/problemnew/show/P1854) 给定一个n*m的矩阵A(n&lt;=m)，求一个序列$a_1,a_2,…,a_n$满足$1\\leq a1&lt;a2&lt;…&lt;an\\leq m$。使得$A[1][a_1]+A[2][a_2]+…+A[n][a_n]$最大。 A可能有负数。 $O(nm)$ 预处理$s(i,j)$为第i行前j个的最大值，每行转移时求最大值直接$O(1)$更新。 poj3046 T种数，第i种数有a[i]个，总共有A个数。问取其中X个数作为子集，有多少种不同的子集。计算L&lt;=X&lt;=H的子集数之和，结果mod 1000000 $1\\leq T\\leq 1000, 1\\leq a[i]\\leq 100$，即$1 \\leq A \\leq 100000, L\\leq H\\leq A$ 基本想法：可以类比为把求max改为求sum的多重背包，所以基本的递推关系很好写，dp(i,j) = sum dp(i-1)(j-k) 其中k = 0~a[i] ，dp(i,j)表示前i种数，其中j个数作为子集的取法。 很明显，这样做会超时、超空间，超空间好说，是基本的滚动数组。我们主要解决超时的问题。 单调性优化最长上升子序列问题 有n个数，找到一个子序列，使得这些数单调递增，且这个子序列长度最大。 $O(nlogn)$ 普通方法，$f[i]=max\\{f[j]\\}+1(a_j&lt;a_i且j&lt;i)$ 优化，对于最长上升子序列长度为i的，一定有结尾最低高度$h_i$并且这个高度一定是单调递增的，所以： 枚举i从1道n 对于当前$a_i$在$h_i$上做一个二分。 更新f数组 通过f的更新来更新长度为$f[i]$的末尾最低高度 经典问题 给定一个队列，维护三个操作。 将一个数x压入队列中。 求队列中数的最大值。 弹出队列尾的数。 $Q&lt;=1000$。 $Q&lt;=100000$。 烽火传递 给定n个非负整数，选择其中若干数字，使得每连续k个数中至少有一个数被选出。 要求选择的数字之和尽可能小。 $O(n)$ 令$f[i]$表示只考虑前i个数，并且第i个数也选择了，并且此时$1$到$i$是满足条件的这个最小总和是多少。 有$f[i]=min{f[j]}+a[i]$，其中j-i不超过k。 时间复杂度$O(nk)$。 考虑优化 最大字段和 有n个数，连成一个环，求最大子段和。（即对于所有区间的和求最大值） 数字可以为负。 $n&lt;=1000000$。 k背包问题(多重背包) 一个容量为m的背包，有n个物品，第i个物品的体积为wi，价值为ci，有ki个。 选择若干物品，使得体积总和不超过m的情况下价值总和最大。 能否利用单调队列进行优化？ $O(nm)$ 树形DP没有上司的舞会 给定一棵有点权的树，选择若干点，使得选出的点任意两个点都不相连，且选出的点权和最大。 $n\\leq 100000$。 没有上司的舞会+ 给定一个树套环，选择若干点，使得选出的点任意两个点都不相连，且选出的点权和最大。（基环树） $n&lt;=100000$。分析 有环怎么办？ 基环树一般先把树上的情况处理。 先找到环，把每个环上的点为根，进行计算。 这样可以把基环树变成环，进行破环成链。 $f(i,0/1,0/1)$记录前i个，第i个是否被选，和第一个是否被选。 $f(i,1,0/1)=f(i-1,0,0/1)+a(i,1)$ $f(i,0,0/1)=max(f(i-1,0,0/1),f(i-1,1,0/1))+a(i,0)$ 那么答案就是$f(k,1,0)$或者$f(k,0,0/1)$ 最远距离 给定一棵带边权的树，求最远的两个点距离是多少。分析 对于每一个点，求其子树上的最长链a和次长链b，然后求$a_i+b_i$的最大值。 快餐店 给定一棵带边权有n个点的树，要求以每个点出发，最远能走到哪里，距离是多少。 $n\\leq 100000$。分析 计算每个点能向下走的最远距离$f(x)$ 对于每一个节点，维护$g(x)$表示这个点向上走的最长距离。所以$g(x)=max(g(fa),f(bro)+len(bro,fa))+len(x,fa)$ 状态压缩DP 状态压缩，一般用一个表示状态的数字来表征一堆元素的状态，如用2^10以内的二进制数表示10个元素的有无（0/1） 最大特征：某一个重要数据的规模特别小 常见优化：预处理哪些状态是合法的，以及状态转移的可行性，减少状态数和状态转移数。互不侵犯+ 在N×N的棋盘里面放若干国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。 N&lt;=15。","link":"/2019/07/17/清北学堂noip2019-Day5/"},{"title":" 清北学堂noip2018集训D2\t\t","text":"清北学堂noip2018集训D2 P.S.**今天讲数据结构，大概包括了二叉堆，二叉搜索树，线段树，树状数组，并查集，st表，RMQ，LCA。** 二叉堆 基本功能 O(log n)插入元素 O(1)查最大（最小）元素 O(log n)删除最大（最小）元素 O(log n)删除任意元素 基本结构 最为常用的堆结构就是完全二叉堆。 在逻辑形式上，结构必须等同于完全二叉树，同时，堆顶以外的每个节点都不大于（小于）其父亲，即堆有序。 如果堆顶最大，称为最大二叉堆（大根堆），反之称为最小二叉堆（小根堆）。 因为完全二叉堆等同于完全二叉树的结构，故高度相当。为O(log n). 一般为了实现方便，根节点编号为1，节点n左节点为2n，右节点为2n+1. 查询操作 最大（最小），直接返回堆顶即可。 插入操作 首先把新元素插入向量末尾，为了维持堆的有序性，逐层检查是否有序并调整，过程通常称为上滤。 建堆 O(n log n)插入每个元素即可。 O(n)? 先随机放入一个完全二叉树。 从倒数第二个深度开始检索，使堆有序。 ##### 删除最大（最小）元素 首先将堆顶元素与堆尾元素交换。 删除堆尾元素。 一步一步将这个换上去的元素下移。 直到堆有序。 ##### 删除任意元素 \\- 新建一个堆，将删除的元素放入新堆里。即可实现删除。二叉搜索树 基本功能 排序 查询元素大小排名 插入元素 二叉平衡树的基础 结构 若左子树不为空，则左子树上所有节点小于根节点。 若右子树不为空，则右子树上所有节点大于根节点。 左右子树也分别称二叉排序树。 排序 中序遍历 查询元素大小排次 从根开始向左、右是唯一的，如果向右，那么将左边的节点数加起来，反之不加。 插入 与查询方法类似。 \\- 查询到节点后向上更新其他节点。线段树 基本功能 建树 单点查询 单点修改 区间查询 区间修改 结构 是一棵二叉搜索树，每个节点代表一个区间。 每个节点需要维护 区间左右端点 区间要维护的信息 基本思想：二分 特殊性质 左子节点区间为\\[l,mid\\],右为\\[mid+1,r\\]. 对于一个节点k，左子节点为2k，右子节点为2k+1. 建树 对于二分的每一个节点，确定其代表的区间。 如果为叶子结点，存需要维护的信息。 对于非叶子结点，将两个子节点状态合并。 单点查询 在左右节点搜索是确定的，由节点的mid决定，如果要查询的点大于mid，则在右子树搜索，反之在左子树搜索。代码如下： `cpp #include&lt;bits/stdc++.h&gt; using namespace std; #define LL long long const int MAXN = 100000; struct tree{ int l,r,s; }mi[4*MAXN+20]; void build(int k,int l,int r){ mi[k].l=l; mi[k].r=r; if(l==r){ mi[k].s=r; return; } int mid=(l+r)/2; build(2*k,l,mid); build(2*k+1,mid+1,r); mi[k].s=mi[k*2].s+mi[k*2+1].s; } int search(int k,int n){ if(mi[k].l==mi[k].r&amp;&amp;mi[k].r==n){ return k; } int mid=(mi[k].l+mi[k].r)/2; if(n&lt;=mid) return search(k*2,n); else return search(k*2+1,n); } int main(){ build(1,1,6); cout&lt;&lt;search(1,5); return 0; }` 单点修改 先执行单点搜索，然后执行修改操作，再向上更新状态。 代码如下```cpp int insert(int k,int n,int v){ int now=search(k,n); mi[now].s+=v; while(now!=1){ now/=2; mi[now].s=mi[2*now].s+mi[2*now+1].s; } }``` 区间查询 令\\[l,r\\]为当前节点代表的区间，mid代表区间中点，\\[x,y\\]代表要查询的区间。 若\\[l,r\\]=\\[x,y\\]直接返回即可。 如果$y\\\\leq mid$,\\[l,r\\]-&gt;\\[l,mid\\],\\[x,y\\]不变，递归查询。 如果$x &gt; mid$,\\[l,r\\]-&gt;\\[mid+1,r\\],\\[x,y\\]不变，递归查询。 否则，\\[x,y\\]跨过了mid的两端，将其分成了两个子问题，$\\[l,mid\\]$中查$\\[x,mid\\]$.$\\[mid+1,r\\]$中查$\\[mid+1,y\\]$. 代码如下： `cpp int query_sum(int k,int x,int y){ if(y&lt;mi[k].l||x&gt;mi[k].r) return 0; if(x==mi[k].l&amp;&amp;mi[k].r==y) return mi[k].s; int mid=(mi[k].l+mi[k].r)/2; return query_sum(k*2,x,mid)+query_sum(k*2+1,mid+1,y); }` 区间修改 关键：懒标记 经过节点的集合与区间查询相同 更新这些区间的答案并打上一个标记，来表示这个区间中的数要进行哪些修改。 只有当查询或者修改经过一个节点时，才将其节点上的懒标记放到两个孩子节点，下放的同时修改两个孩子节点的答案。 模板（无区间修改）/*求和线段树*/ #include&lt;bits/stdc++.h&gt; using namespace std; #define LL long long #define inf 2147483647 const int MAXN = 100000; struct tree{ int l,r,s; }mi[4*MAXN+20]; void build(int k,int l,int r){ mi[k].l=l; mi[k].r=r; if(l==r){ mi[k].s=r; return; } int mid=(l+r)/2; build(2*k,l,mid); build(2*k+1,mid+1,r); mi[k].s=mi[k*2].s+mi[k*2+1].s; } int search(int k,int n){ if(mi[k].l==mi[k].r&amp;&amp;mi[k].r==n){ return k; } int mid=(mi[k].l+mi[k].r)/2; if(n&lt;=mid) return search(k*2,n); else return search(k*2+1,n); } int query_sum(int k,int x,int y){ if(y&lt;mi[k].l||x&gt;mi[k].r) return 0; if(x==mi[k].l&amp;&amp;mi[k].r==y) return mi[k].s; int mid=(mi[k].l+mi[k].r)/2; return query_sum(k*2,x,mid)+query_sum(k*2+1,mid+1,y); } int insert(int k,int n,int v){ int now=search(k,n); mi[now].s+=v; while(now!=1){ now/=2; mi[now].s=mi[2*now].s+mi[2*now+1].s; } } int main(){ int n,m,x,v; cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;v; build(1,n,m); cout&lt;&lt;query_sum(1,x,v); return 0; } 树状数组 基本功能 单点修改，前缀信息查询。 区间修改可减信息（前缀和），单点查询。 lowbit函数 含义：一个数，二进制表示中的最后一个1。 计算机中负数的表示？ 怎么求lowbit呢？ $x and (-x)$ 结构 我们定义c\\[i\\]为区间$\\[i-lowbit(i)+1,i\\]$。 怎么直观的看一看呢？ ![树状数组](https://img-blog.csdn.net/20181002141812320?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNDQwNDg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) ![在这里插入图片描述](https://img-blog.csdn.net/20181002165151143?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNDQwNDg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) $S\\_n=S\\_{(n-lowbit(n))}+C_n$ 查询代码 int sum(int x){ int ans=0; for(;x;x-=lowbit(x)) ans+=c[x]; return ans;} 修改代码 void update(int x,int v){ for(;x&lt;=n;x+=lowbit(x)) c[x]+=v;} 代码示例： #include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=100010;int a[maxn],c[maxn];int n;int lowbit(int x){ return x&amp;(-x);}int sum(int x){ int ans=0; for(;x;x-=lowbit(x)) ans+=c[x]; return ans;}void update(int x,int v){ for(;x&lt;=n;x+=lowbit(x)) c[x]+=v;}int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; update(i,a[i]); } cout&lt;&lt;sum(n); return 0;} 区间修改，单点查询 且以修改为加法，查询为求和为例。 \\- 对于将$\\[l,r\\]$加$x$的操作，可以将点$l$加$x$，将点$r+1$减$x$，这时候求点$n$的前缀和就能得到点$n$真实的值。并查集 基本功能 合并两个集合 查询某一个元素属于哪个集合 结构 并查集S由若干子集合$S_i$构成，并查集的逻辑结构是一个森林。 $S_i$表示森林中的一颗子树。 一般以子树的根作为该子树的代表。 而对于并查集的存储结构，可用一维数组来实现。 查询某个元素属于哪个集合 通常而言都是以根作为这个集合的代表元。 因此只需要不断向父亲节点走，直到走到根为止返回即可。 合并集合 ![在这里插入图片描述](http://images.cnitblog.com/blog/277239/201310/03213536-c6b449badcc643578a9c4c65ed8a5f23.jpg) 路径压缩优化 ![在这里插入图片描述](data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAkGBw8QEBUQEBMVEBIQFRYVFhYVFRUVFRUTFxgWFxcWFRYYHSggGRslHBYXITEhJSkrMS4uFyAzRDMsQygtLisBCgoKBQUFDgUFDisZExkrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrK//AABEIAJsBRQMBIgACEQEDEQH/xAAbAAEAAgMBAQAAAAAAAAAAAAAABAUBAgMGB//EAD8QAAICAQIEAwUFBQYGAwAAAAECAAMRBCEFEjFBE1FhBiIycYEUUmJykRYzQpKhI1WCk6KxBxUkQ1PBNGNz/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/APuMREBERAREQEREBERASHxHV+EBgc72HlRQcFnwT17AAEk9gD8jMlTV7+usz0oorC+jWtYXP6VIP1gBwjxPe1TtaT/AGKUr+EIpHMPVyfp0BfZ3Rj4KUrP3q81t/MmDLRzgZlTwTiLXu5wRWyU2VhuXPLYH328+UHB3GflAyWs0u9jm2jIyzYNlWehYge/XnAyd1zkkjJW2zNbKwwIYZDAgg9CCMESv9nHY6ZAxyai9JJ3LeDY1XMT5nkz9YFnERAREQEREBERAREQEREBERAREQEREBERAREQEREBERAREQEREBERAREQEREBKnVf2OqW4/Bei0ueyurM1RPkCbHXPmyiWpM8h/wAReOarTaZzoqq9VaozbU4d8UkEcxVe3XYkZGcdIHsJG0vD6KiTVWlZbGSqhSQOgOPKUnAtNxKvTVmx6rLSgL1uGVUY78ldg5m5RnHvBjt9BP59edvD06fi8ayzHyXwlz/MIEriOsFNZbHM3RFHV3PwqPU/+iexmvB9IaaK6ieZlX3j96w7u31Yk/Wa6ThxDeJa5ut7NjlVAeorQfD8zlj3OMAT4CIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiJgmBmas2Bk9BKxtbdcSNKFC9PGsyUyOvhoCDZ88qPUyPrOC33KBZqmbG5Twq/Cf0dOrD05v1gdzqrNRtR7lXQ343bzFIPX85GPINJuj0aVLyoMZOSTuzN3ZmO5PqZCXWXU7alUKf+asEIPz1kk1j1DMO5xLVYDEzEQEREBERAREQEREBERAREQEREBERARKy3iFjsU0yhipw1jkipSOoGN7GB6gYHUcwIxMLo9WRltV734aUCD/CSTj/ABQLSJUfa9TR+/C3VjrbUrKV9XqJbb8Sk/IS0qcMAQQQRkEdCD3EDeIiAiIgIiICIiAiIgIiICIiAlXxxy3hacEj7TZysR1FSq1j4+YXkz2589paSp40eSzT3fw12FX9FtUop+XOUHyMC0rQKAAMADAA6ADtOK62o2GoODYNyudxsD+uGU48mHmJ3Eg6XhgrtexWPLYxcrgbOyqre915fcBx5/QAJrqCMEZB7HoR5GVnBSUNun6ihwEycnwmUOg+mSvyWWhMq+Ee/dqLh0axax6ipeU/6y4+kC1iIgIiICIiAiIgIiICIiAiIgIiICVvG7HFfLWSr3OtQYdVDnDMPUKGI9QJnW8RAY1VKbrcbqpwEz3sfog7+fkDPD8K9nOIaW63Wa/VPqa6bkalediqUn97Yw7lQ5G46IT3ED6Jp6VrUIo5UUYA8gJC13FUruqp2Z7m5cc2CoK2MGI8j4ZHb+hlgDmVl3BFbUC8Oy++jsuAQzIj1jc9Byudh3A9chadpV8LHhXW6cfAAtqD7q2FgyD051Yjy5sdAJaTwntrwbV67xm0F76fUaUVpWyOUV3957K37EYdN+xHzED3kSg4VqH0dKUaxmcoAPtJPMlh87Cf3beh93cYJ6C9DQNoiICIiAiIgIiICIiAiIgJS+2PGadFo7NRqK2tqUAOqAE4YhdwSNskD6yfrtctWBgu7/Ai7s3nt2HmTgCRqOHGw+JqeWx98J8VVYIwQoI95sEguRkgnYA4gUvsn7Q336RNSaLW09mTWfda8VDYNYgPv9NiuSRjbO5t/wBotN52Z+79n1HN/L4ef6Sy0unSpFrrUIlahFVRgKqjCqB2AAAnWBUm6/UbKjaeo9Xfa1h/9adUJ+82CPu9xY6ehK0VEAVUGAB0AHadYgIiICIiAiIgImrOB1OM7D5+UzmBmIiAiIgImCwlXZxFrTyaUCzGxtbPgoe+CP3hH3V7jBYQJus1ldK81jBR0HUknyVRux9ACZAxqNR8XNpqfIfv3HqRtUPQZbpuvSSNJw1UbxXJutxjxGxkDuqDoi+g64Gc9ZPgcNHpa6k5EUKo3wPM7knuTnfJ3zOrKCDkZzNogVCrdptkQ30j4QpHi1j7o5iA6jtuCAMbzVvaXSg8rNYrfdai8OcdcKUycZHTzHnLgzwvtFwHX28Z0mqq1K110I/LUVYhl93xuYg9WDgenIIHpftl9+1NbUoettq8px38Oo+9zfnAAyNm6SdotMtSCtRgLnruSSSSxPckkknuSZIiBgqMYxtKo8Oek82lIC96Xz4R/wDzI3qPyyv4d8y2iBA0XElsbw2DVWgb1vgN81I2dfVSfodpPkbWaGu5eWxQwByD0ZT2ZWG6t6ggyEx1Gn89VV5jHjoPUdLR8sHbo0C2icNHrK7V5q2DDocdQR1Vgd1YdwdxO2YGYiICIiAgxOGt1K1Vva+eWtSxx1wBnb1gaa3X10gGw45jhQAWZm68qqN2Ox6eUr9VxTVFT4GksJ6A2PUg/Ny8/N9Dj6dZK4ZpT++uAN9g949QincVofujb5nJko3pz+Hkc/LzcvflzjPyzApuH6muo/2y21XWnBe4L77fwqHRiijyQEfrub5ZrdUrqVZQysMEEAgg9QQeolbw92qtOmY5Xl8SpicnkB5WRj3Kkrg/dcDsSQtYiICIiBgz5zxj2x49VfZXTwg21oxCP4nxr2bbzn0eIHy39ufaP+5T/mGP259o/wC5T/mGfUogfLf259o/7lP+YY/bn2j/ALlP+YZ9SiB8D/4k+1fGr9AU1XDjoqxZW3jCwkq6tlceRz3j/hV7ecducUCluJUrgF2wjVDbrdjB+TZM+18e4Jp9dV4GpTxaudXK5IBKHI5sdRnt3krR6SulBXUi1ouyqoCqB6AQOynYZ2Pl5TMTBga22BQWYhVUZJJwAB1JPYSt/wCc8+9FFt6n+MBEQ+oNjLkeoBmoX7Tc3N71OnYKq9Q9wwWZvMLkADz5jvgYtoHmGtvsOddRbXV2rq5bKyB3tatvEf8ALyhfnPQ6Syt0VqiprIHKVxy49MTtKnXgaZxegwljqtwHT3yFW30IYjJ7qT5CBbxAiAiJC4prDTWWA5mJVEXoGschUBPYcxGT2GTAzrOJV1EK2S7fCigs7Y6kKN8DI3O28q7tVqWuqtXSW8la2Ahn04fL8mML4mP4e5EtNBoxUCT71j7u5G7t/wClGdh2E616hGZkBBavHMO65GRn5iBF0vF0dhW6vTY3RLRgtjqFYEq2B90mWAM5arTJahSxQynz8xuCPIg7g9pE4Te+XosPM9JGG+/W26MfXYqfMqTtnECxiIgYJldqtc5c1UKGdcc7Nnw68jIBxuzYIPKOx3I2z24xrPA09t2MmutmA8yASB9TgTPDNH4NS155iN2buzseZ2PqWJP1gVv/ACB2s8dtTatmOtS01qR5MCjFx5cxOJ38LV1brZ9qUdVsVK7CPwugCk+QKgHzHWStZr6qseI3LzehIxkDfA2GWHXzksQOGj1a2rzpnqQQRhlYbFWHYiJ532qOrpsWzRcoNwxbzDYlMBGHrhiCfJV8ogeqiIgJW+0f/wAWw9lAZvyqwZv6AyymlqgqQwBUggg9CD1B9IGwMoeNcNvsvW2olcVhAwcryt4qPlgPiXlU7b+WN5y4d7QaWp/sjaiuzwwArixXKp0VbyCSjDpzNgNtvkkT0SsDuN/lvAyTK3UkHWUgdRXcSfwk1D/f/adtbxKurAY5dvhrX3rGPoo3+Z6DuRNOHaVuZ77f3tuBjIIrrXJWsHzySSe5PkBAsBERAREQEREBERAREQEREBMGZiBU+zm1dinZl1Op5v8AFfY6n6qyn5ESRxim16iKThuZCd8EoHBdQ3YlcgH1nHUVtRY16KXSzHiooywKjAtQdWOMAr1IAx0wZml1lVq81bq6+akHfuD5EeRgNDWVQA5GM/E3O2MnGW77SH7UH/o7x3epkX1scclYHqWZQJO1OpStS9jLWo6sxCgfU7SuUnVOjlStFbB15hg2uPhblO4RfiGdycHbAyFuIiICVfGzjwWPwrqK8/4sov8AqZZaThrdKt1bVv8AC4wcbEeRB7EHBB7ECB2zKG7ht/2w3ISqu1RJDnl5ESwOrJ0JJZcfr2kvT8R8MirUnkfornau3yKt0DkdU69cZAzLLMDMraMHW2YHSioE+pe0gfp/vN9XxREbw1/tbSNq0ILfN+yL+I/1O034ZpDWGLHmstYvY3YtsAB+FQAo9B6mBNiIgQuN6Q3aa2pdmsrZVPkxB5T+uJ04fqxdUtg25huO6t0ZT6ggj6STKvUaS2tjZp+U8271MeVXP3lYA8j+exBx26wM8W4LXqSC7MMKy+7y9GIORzA4OVG4lioxKxuNcvx6fUKfIVGz+tfMJh9dqLfdppNWf+5dhQB5rWDzMfQ8o9YFX7W6nVl0r0aeKyAtYOYLyhscn68rRPQaHRrWpAJZmOXc/E7feY/IAAdAAAMARAlRMZkPWcX01JxbdXWfJmAP6dYE2VV+ra4tTp8NjKvYw5q07FQP43/D0Hc9jE03EU1xIrsC0jqFYC6wdNwDzVp/qP4R1utPSqKFQBVUYUAYAHYADoIHnPY72H0nDDqDQCftTAnmA91AuOQYGMcxc9B8WOwls/AdIf8AtKv5coP0UgSziBG0mgppz4VaJnqVUAn5nvJMRAREQEREBERAREQEREBERAREQEg6rhOntbmepSx/iAw38wwZOiBA0/BtMjBlqXmXoze8w+RbJEnYmYgIiICIiBpbUrgqyhlPUEAg/MGV54BpP/EBjsCwX+UHEs4gcNJpKql5akWsdcKoGT5nHUzvEQEREBGIiBjEzEQERECqsdtRY1aMyVVHlsdThnfAJRG/hABGWG+dgRgyZpOH00jlrrVAdzgDLHzY9WPqdzIXsuc6Spv4rFNjfndizf1JnTj3ETp61ZcZZuUc3w/CzbnIA+HuR/sCHfV8NptA8RAxXdW6Op80cYZT6giRtLc1NgosYuHz4VhxzEgZat8dWA3B7gH7pJkcI1nj0V3YA8RAxAOQCRuAe+DIntHtSrj4q7qCvzNqKcfNWYfJjAtgZmYEzAREQEREBERAREQEREBERAREQEREBERAREQEREBERAREQEREBERAREQEREBERAqeHN4DnTvsGdnpPZlbLsn5lJbb7uD54tDvOOp0yWKUccynt6jcEEbgggEEbjE8r7J8Uvs1Woody9dLlUBwSBju2OY/UmB7HMqtR/1FyVqc10OHtPY2LulY9Q2HPlyqO8oeOcSvPEKdLzlabc8yr7pO2fjXDD6Geu09CVqERQiqMAAYAEDtERAREQEREBERAREQEREBERAREQEREBERAREQEREBERAREQEREBERAREQEREBERA//9k=) 示例代码 \\`\\`\\`cpp #include&lt;bits/stdc++.h&gt; using namespace std; int fa\\[200010\\]; int n; int find(int x) { if(fa\\[x\\] == 0) return x; return fa\\[x\\] = find(fa\\[x\\]); } void add(int x,int y){ int xx=find(x),yy=find(y); fa\\[yy\\]=xx; } int main(){ cin&gt;&gt;n; int x,y,m,z; for(int i=0;i&lt;n;i++){ cin&gt;&gt;x&gt;&gt;y; add(x,y); } cin&gt;&gt;m&gt;&gt;z; cout&lt;&lt;find(m)&lt;&lt;” “&lt;&lt;find(z); return 0; } \\`\\`\\` RMQ问题 R——Range M——Minimum/Maximum Q——Query 即区间最值问题 例题![例题](https://img-blog.csdn.net/20181002170826284?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNDQwNDg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) \\- 方法1：使用线段树 - 方法2：st表 ST表 基本功能 $O(nlogn)$预处理，$O(1)$查询区间最值。 结构 $f\\[i\\]\\[j\\]$表示区间$\\[i,i+2^j-1\\]$的信息。 整个$f$数组就是ST表。 ![ST表](https://img-blog.csdn.net/20181002171349563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNDQwNDg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 建表 $f\\[i\\]\\[0\\]$就是单点i的信息 当$j&gt;0$时，$f\\[i\\]\\[j\\]$为$f\\[i\\]\\[j-1\\],f\\[i+2^{j-1}-1\\]\\[j-1\\]$两个区间信息的并集。 查询 比方说我们要查询区间$\\[x,y\\]$的信息。 令t为最大的正整数使得$2^t\\\\leq y-x+1$ 那么答案就是$\\[x,x+2^t-1\\]\\\\cup\\[y-2^t+1,y\\]$ 代码如下： #include&lt;bits/stdc++.h&gt;#define maxn 111100#define logN 25//因为cmath中的log函数效率差，不如直接设定一个永远到不了的值using namespace std; int f[maxn][logN],a[maxn],n,m; void pre_st(){ //制表 for(int i=1;i&lt;=n;i++) f[i][0]=a[i]; //因为第二个框框中存的j是用来计算 i+2^j-1（既该f保存的值） //服务于动态规划的结果 for(int j=1;j&lt;=logN;j++){ for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]); //注释1 （1&lt;&lt;j）是计算出 2^j 把一一直右移即可得到 //注释2 使用刚才得到的动态规划方程 }} int main(){ cin &gt;&gt; n;cin &gt;&gt; m; for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); pre_st(); //制表 int x,y; for(int i=1;i&lt;=m;i++){ cin &gt;&gt; x &gt;&gt; y; int s=log(y-x+1)/log(2); //计算出这一段距离之中最大的2的倍数，以查表 cout &lt;&lt; max(f[x][s],f[y-(1&lt;&lt;s)+1][s]) &lt;&lt; endl;; //合并左右不分的解 } return 0;} * * * 查询树上两点的最近公共祖先（LCA） ------------------ * L——Lowest * C——Common * A——Ancestor * 即最近公共祖先 ### 欧拉序 * 一种特殊的dfs序，每到达一个点就加入序列。 * 记录每个点第一次出现的时间$S\\[u\\]$，欧拉序中第i个点为$Q\\[i\\]$。 * $LCA(x,y)$是$Q\\[S\\[x\\]...S\\[y\\]\\]$中层数最低的点。 * 区间最值？ * ST表！","link":"/2019/03/09/e6-b8-85-e5-8c-97-e5-ad-a6-e5-a0-82noip2018-e9-9b-86-e8-ae-add2/"},{"title":" 清北学堂noip2018集训D4\t\t","text":"P.S.最小生成树，最短路问题，SPFA算法，强连通分量。 图的读入 n m m行，u，v 例如： 6 8 1 2 1 3 2 4 3 4 3 5 4 1 4 6 5 6 ![在这里插入图片描述](https://img-blog.csdn.net/20181004080841828?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNDQwNDg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 6 8 1 1 1 2 1 5 2 5 2 3 3 4 4 5 4 6 ![在这里插入图片描述](https://img-blog.csdn.net/20181004081027337?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNDQwNDg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 一些术语 简单图：无重边，无自环。 路径：一组首尾相连的边的集合 度数（入度，出度）：连接一个点的边的数量。 连通图：图中任意两点都有路径连接。 连通分量（联通块）：极大的联通子图。 完全图：任意两点有边相连。n个点的完全图有$n(n-1)/2$。 有向无环图（DAG） 图的存储 用的方便？ 检查两点之间是否有边。 遍历（枚举）一个点的所有出边。 \\#### 邻接矩阵 检查两点之间是否有边。 ![在这里插入图片描述](https://img-blog.csdn.net/20181004082507397?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNDQwNDg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 注意空间 256 MB 256\\*1024\\*1024 B bool 1B int 4B long long 8B double 8B 时间 1s $10^7$ O(n) 代码如下 `cpp #include&lt;bits/stdc++.h&gt; using namespace std; int n,m; // n*n int graph[105][105]; int main(){ scanf(“%d%d”,&amp;m,&amp;n); int x,y; for(int i=0;i&lt;n;i++){ scanf(“%d%d”,&amp;x,&amp;y); x–;y–; graph[x][y]=1; graph[y][x]=1; //重边：graph[x][y]++; //graph[x][y]++; //权值：graph[x][y]=z; //graph[y][x]=z; } for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;n;j++){ cout&lt;&lt;graph[i][j]&lt;&lt;” “; } cout&lt;&lt;endl; } return 0; }` 邻接表 遍历（枚举）一个点的所有出边。 n个链表 对于每个点，开一个链表，链表存储当前这个点的所有出边。 1 .vector存图 STL 可变长数组 2 . 数组链表 代码如下： #include&lt;bits/stdc++.h&gt; using namespace std; int n,m; vector&lt;int&gt; a[10005]; int graph[105][105]; int main(){ scanf(&quot;%d%d&quot;,&amp;m,&amp;n); int x,y; for(int i=0;i&lt;n;i++){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); a[x].push_back(y); a[y].push_back(x);//无向图 } int w=3; for(int i=0;i&lt;a[w].size();i++){ cout&lt;&lt;a[w][i]&lt;&lt;&quot; &quot;; } return 0; } * 链表存储 * 代码如下： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; int n,m; // 数组链表 邻接表 // 链表头 链表节点的下一个节点 这条边指向图中的点 int head[10005],nxt[30005], ver[30005]; int tot;// 记录链表节点用了多少个 void add(int x,int y){ // 在x的链表中 加一条指向y的边 ++tot; // 当前链表节点就是编号为tot ver[tot]=y; nxt[tot]=head[x]; head[x]=tot; } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0,x,y;i&lt;m;i++){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y); add(y,x);//无向图 } // 遍历一个点的所有出边 int x=5; for(int i=head[x];i;i=nxt[i]){ int y=ver[i]; printf(&quot;%d &quot;,y); } return 0; } * 带权值： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; int n,m; // 数组链表 邻接表 // 链表头 链表节点的下一个节点 这条边指向图中的点 边的权值 int head[10005],nxt[30005], ver[30005] , w[30005]; int tot;// 记录链表节点用了多少个 void add(int x,int y,int z){ // 在x的链表中 加一条指向y的边 权值为z ++tot; // 当前链表节点就是编号为tot ver[tot]=y; w[tot]=z; nxt[tot]=head[x]; head[x]=tot; } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0,x,y;i&lt;m;i++){ scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); add(x,y,z); add(y,x,z);//无向图 } // 遍历一个点的所有出边 int x=5; for(int i=head[x];i;i=nxt[i]){ int y=ver[i]; printf(&quot;%d %d &quot;,y,w[i]); } return 0; } * #### 遍历图 * dfs * 代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; int n,m; // 数组链表 邻接表 // 链表头 链表节点的下一个节点 这条边指向图中的点 int head[10005],nxt[30005], ver[30005]; int tot;// 记录链表节点用了多少个 void add(int x,int y){ // 在x的链表中 加一条指向y的边 ++tot; // 当前链表节点就是编号为tot ver[tot]=y; nxt[tot]=head[x]; head[x]=tot; } bool vis[10005]; void dfs(int x){ printf(&quot;%d &quot;,x); vis[x]=1; for(int i=head[x];i;i=nxt[i]){ if(!vis[ver[i]]){ dfs(ver[i]); } } } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0,x,y;i&lt;m;i++){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y); add(y,x);//无向图 } dfs(1); return 0; } * bfs * 代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; using namespace std; int n,m; // 数组链表 邻接表 // 链表头 链表节点的下一个链表节点 这条边指向图中的点 int head[10005],nxt[30005], ver[30005]; int tot;// 记录链表节点用了多少个 void add(int x,int y){ // 在x的链表中 加一条指向y的边 ++tot; // 当前链表节点就是编号为tot ver[tot]=y; nxt[tot]=head[x]; head[x]=tot; } bool vis[10005]; // 是否已经入队 int d[10005]; // 到起点的距离 queue&lt;int&gt; q; // 队列 // q.front() 队列的第一个元素 // q.push(x) 把x加入到队列中 // q.pop()弹出第一个数字 // q.empty()返回队列是否为空 // q.size()队列里还有多少元素 int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0,x,y;i&lt;m;i++){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y); add(y,x);//无向图 } // 遍历一个点的所有出边 // int x=5; // for(int i=head[x];i;i=nxt[i]){ // int y=ver[i]; // printf(&quot;%d &quot;,y); // } // // 重复入队 // while(!q.empty()) { // int x=q.front();q.pop(); // vis[x] = 1; // // do something // // for(int i=head[x];i;i=nxt[i]){ // if(!vis[ver[i]]){ // q.push(ver[i]); // } // } // } q.push(1);vis[1]=1; /// !!!! while(!q.empty()) { int x=q.front();q.pop(); // do something for(int i=head[x];i;i=nxt[i]){ int y=ver[i]; if(!vis[y]){ vis[y] = 1; d[y] = d[x] + 1 ; q.push(y); } } } for(int i=1;i&lt;=n;i++){ printf(&quot;%d &quot;,d[i]); } return 0; } * #### 最短路 * 多源最短路 * Floyd * 考虑用dp解决这个问题； * $dp\\[i\\]\\[j\\]\\[k\\]=min(dp\\[i-1\\]\\[j\\]\\[i\\]+dp\\[i-1\\]\\[i\\]\\[k\\],dp\\[i-1\\]\\[j\\]\\[k\\])$ * $dp\\[j\\]\\[k\\]=min(dp\\[j\\]\\[i\\]+dp\\[i\\]\\[k\\],dp\\[j\\]\\[k\\])$ * 代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; int n,m; // n*n // 100000 200000 int graph[105][105]; // 边权&gt;0 int floyd[105][105]; int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0,x,y,z;i&lt;m;i++){ scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); graph[x][y]=z; } memset(floyd,0x3F,sizeof(floyd)); for(int i=1;i&lt;=n;i++) floyd[i][i] = 0; // 初始值 for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ if(graph[i][j]) floyd[i][j]=graph[i][j]; } } // floyd O(n^3) for(int k=1;k&lt;=n;k++){ // 循环顺序注意 for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ floyd[i][j]=min(floyd[i][j],floyd[i][k]+floyd[k][j]); } } } int xx,yy; scanf(&quot;%d%d&quot;,&amp;xx,&amp;yy); printf(&quot;%d&quot;,floyd[xx][yy]); return 0; } * 单源最短路 * 求一个点到每个点的最短路 * Dijkstra 迪杰斯特拉算法 * SFPA算法 * Dijkstra 迪杰斯特拉算法 1. 从所有点中选择未标记的$dis\\[i\\]$值最小的顶点$i$，将$i$标记； 2. 松弛节点$i$的相邻节点 3. 若所有点都被标记，结束。否则回到1 4. 代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; using namespace std; int n,m; // 数组链表 邻接表 // 链表头 链表节点的下一个节点 这条边指向图中的点 边的权值 int head[10005],nxt[30005], ver[30005] , w[30005]; int tot;// 记录链表节点用了多少个 void add(int x,int y,int z){ // 在x的链表中 加一条指向y的边 权值为z ++tot; // 当前链表节点就是编号为tot ver[tot]=y; w[tot]=z; nxt[tot]=head[x]; head[x]=tot; } struct N{ int x,w; // x节点，w 当前d[x]的值 friend bool operator &lt; (N a,N b){ // C++重载运算符 return a.w&gt;b.w; } N(int a=0,int b=0){ // 构造函数 x=a,w=b; } }; priority_queue&lt;N&gt; pq; int d[10005]; bool vis[10005] int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0,x,y;i&lt;m;i++){ scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); add(x,y,z); add(y,x,z);//无向图 } int s=1; memset(d,0x3f,sizeof d); // 0x3f3f3f3f d[s]=0; pq.push(N(s,d[s]); // pq.push((N){s,d[s]}); while(!pq.empty()){ int x=pq.top().x;pq.pop(); if(vis[x]) continue; else vis[x]=1; for(int i=head[x];i;i=nxt[i]){ int y=ver[i]; if(d[y]&gt;d[x]+w[i]){ d[y]=d[x]+w[i]; pq.push(N(y,d[y])); } } } // d[] // d[x] == 0x3f3f3f3f 不连通 return 0; } * 带计数的算法（多个最短路） #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; using namespace std; int n,m; // 数组链表 邻接表 // 链表头 链表节点的下一个节点 这条边指向图中的点 边的权值 int head[10005],nxt[30005], ver[30005] , w[30005]; int tot;// 记录链表节点用了多少个 void add(int x,int y,int z){ // 在x的链表中 加一条指向y的边 权值为z ++tot; // 当前链表节点就是编号为tot ver[tot]=y; w[tot]=z; nxt[tot]=head[x]; head[x]=tot; } struct N{ int x,w; // x节点，w 当前d[x]的值 friend bool operator &lt; (N a,N b){ // C++重载运算符 return a.w&gt;b.w; } N(int a=0,int b=0){ // 构造函数 x=a,w=b; } }; priority_queue&lt;N&gt; pq; int d[10005]; // 最短路的权值 int cnt[10005]; // 最短路的条数 bool vis[10005] int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0,x,y;i&lt;m;i++){ scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); add(x,y,z); add(y,x,z);//无向图 } int s=1; memset(d,0x3f,sizeof d); // 0x3f3f3f3f d[s]=0; cnt[s] = 1; pq.push(N(s,d[s]); // pq.push((N){s,d[s]}); while(!pq.empty()){ int x=pq.top().x;pq.pop(); if(vis[x]) continue; else vis[x]=1; for(int i=head[x];i;i=nxt[i]){ int y=ver[i]; if(d[y]&gt;d[x]+w[i]){ d[y]=d[x]+w[i]; cnt[y]=cnt[x]; pq.push(N(y,d[y])); }else if(d[y] == d[x]+w[i]){ cnt[y]+=cnt[x]; } } } // d[] // d[x] == 0x3f3f3f3f 不连通 return 0; } * POJ 2387 * SPFA * 流程： 1. 将源点S出队。 2. 从队列里取出头的点v，用原点到v的**当前最短距离**来更新源点到与v相邻的点的最短距离（松弛操作） 3. 将最短距离更新过且不在队列中的点入队。 4. 回到第二步，直到队列为空为止。 * 最坏情况$O(nm)$，大多数$O(m)/O(km)$ * 可以处理负权。 * 在稀疏图效率较高。 * 示例代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; using namespace std; int n,m; // 数组链表 邻接表 // 链表头 链表节点的下一个节点 这条边指向图中的点 边的权值 int head[10005],nxt[30005], ver[30005] , w[30005]; int tot;// 记录链表节点用了多少个 void add(int x,int y,int z){ // 在x的链表中 加一条指向y的边 权值为z ++tot; // 当前链表节点就是编号为tot ver[tot]=y; w[tot]=z; nxt[tot]=head[x]; head[x]=tot; } queue&lt;int&gt; q; int d[10005]; bool inq[10005]; int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0,x,y;i&lt;m;i++){ scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); add(x,y,z); add(y,x,z);//无向图 } int s=1; memset(d,0x3f,sizeof d); // 0x3f3f3f3f d[s]=0; q.push(s); inq[s]=1; while(!q.empty()){ int x=q.front();q.pop(); inq[x]=0; for(int i=head[x];i;i=nxt[i]){ int y=ver[i]; if(d[y]&gt;d[x]+w[i]){ d[y]=d[x]+w[i]; if(!inq[y]) inq[y]=1,q.push(y); } } } // d[] // d[x] == 0x3f3f3f3f 不连通 return 0; } * #### 最小生成树 * 生成树：选出一个图的$n-1$条边，使其构成一棵树。 * 最小生成树（MST）：边权和最小的那个生成树。 ![最小生成树](https://img-blog.csdn.net/20181004164451428?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNDQwNDg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) * Prim * Prim算法是通过先获取一个点，然后不断加入点的一个过程。 * 初始化：$V^’=x,E^’=\\\\varnothing$，x是随便一个节点。 * 重复下列操作，直到$V^’=V$ * 在E集合当中选择最小的边&lt;u,v&gt;使得$u\\\\in V^’但是v\\\\notin V^’$; * $V^’$加入节点v，$E^’$加入&lt;u,v&gt; * $(V^’,E^’)$为最小生成树。 * 类似Dijkstra. * 示例代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; using namespace std; int n,m; // 数组链表 邻接表 // 链表头 链表节点的下一个节点 这条边指向图中的点 边的权值 int head[10005],nxt[30005], ver[30005] , w[30005]; int tot;// 记录链表节点用了多少个 void add(int x,int y,int z){ // 在x的链表中 加一条指向y的边 权值为z ++tot; // 当前链表节点就是编号为tot ver[tot]=y; w[tot]=z; nxt[tot]=head[x]; head[x]=tot; } struct N{ int x,w; // x节点，w 当前d[x]的值 friend bool operator &lt; (N a,N b){ // C++重载运算符 return a.w&gt;b.w; } N(int a=0,int b=0){ // 构造函数 x=a,w=b; } }; priority_queue&lt;N&gt; pq; bool vis[10005] int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0,x,y;i&lt;m;i++){ scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); add(x,y,z); add(y,x,z);//无向图 } int s=1; d[s]=0; pq.push(N(s,0); int sum = 0; // pq.push((N){s,d[s]}); while(!pq.empty()){ int x=pq.top().x; sum+=pq.top().w; pq.pop(); if(vis[x]) continue; else vis[x]=1; for(int i=head[x];i;i=nxt[i]){ int y=ver[i]; if(!vis[y]){ pq.push(N(y,w[i])); } } } // sum 最小生成树的权值和 return 0; } * Kruskal * 给所有边按照边权从小到大的顺序排序； * 从小到大依次考虑每条边(u,v)（最开始没有任何的边）: * 如果u 与v 已经连通了，那么加入(u,v) 后会出现环，不添加 * 如果u 与v 没有连通，那么加入(u,v) 使其连通 * 并查集维护连通性。 * 代码如下： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; using namespace std; int n,m; int fa[1000005]; // fa[x] x在并查集树上的父亲是谁 int get(int x){ // 返回x在并查集树上的根 if(fa[x] == x) return x; return fa[x]=get(fa[x]); // 路径压缩 } void merge(int x,int y){ // 合并x所在集合 和 y所在集合 x=get(x); y=get(y); fa[x]=y; } struct Edge{ int x,y,z; }edge[1000005]; bool cmp(Edge&amp;a,Edge&amp;b){ return a.z&lt;b.z; } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); // 并查集初始化 for(int i=1;i&lt;=n;i++) fa[i]=i; for(int i=1;i&lt;=m;i++){ scanf(&quot;%d%d%d&quot;,&amp;edge[i].x,&amp;edge[i].y,&amp;edge[i].z); } sort(edge+1,edge+m+1,cmp); int sum = 0; for(int i=1;i&lt;=m;i++){ int u=edge[i].x,v=edge[i].y; if(get(u)!=get(v)){ merge(u,v); sum+=edge[i].z; } } printf(&quot;%d&quot;,sum); // 货车运输 /* for(int i=1;i&lt;=m;i++){ // 相同边权的边 int u=edge[i].x,v=edge[i].y; if(get(u)!=get(v)){ // i sum+=edge[i].z; } } for(int i=1;i&lt;=m;i++){ // 相同边权的边 int u=edge[i].x,v=edge[i].y; if(get(u)!=get(v)){ merge(u,v); // i之前是可以 加进MST， 现在不行 sum+=edge[i].z; } } */ return 0; } * POJ 2421 constructing roads * POJ 1789 Truck History * POJ1679 判断最小生成树的唯一性 * 拓扑排序 ---- * 有向无环图 ![有向无环图](https://img-blog.csdn.net/20181004165952791?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNDQwNDg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) * 拓扑序指的是可以把所有点写成一个序列，使得所有边都是从前面的点连向后面的点。 * DAG 可以进行拓扑排序。 * 维护一个入度为0 的顶点的集合，每次从该集合中任意取出一个顶点，将该顶点放入保存结果的List 中。紧接着循环遍历由该顶点引出的所有边，从图中移除这条边，同时获取该边的另外一个顶点，如果该顶点的入度在减去本条边之后为0，那么也将这个顶点放到入度为0 的集合中。然后继续从集合中取出一个顶点，重复操作。 * 当集合为空之后，检查图中是否还存在任何边，如果存在的话，说明图中至少存在一条环路。不存在的话则返回结果List，此List 中的顺序就是对图进行拓扑排序的结果。 * $O(n + m)$ * 代码如下： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; using namespace std; int n,m; // 数组链表 邻接表 // 链表头 链表节点的下一个节点 这条边指向图中的点 int head[10005],nxt[30005], ver[30005]; int tot;// 记录链表节点用了多少个 void add(int x,int y){ // 在x的链表中 加一条指向y的边 ++tot; // 当前链表节点就是编号为tot ver[tot]=y; nxt[tot]=head[x]; head[x]=tot; } int indegree[10005]; int a[10005]; queue&lt;int&gt; q; int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0,x,y;i&lt;m;i++){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y); indegree[y]++; } for(int i=1;i&lt;=n;i++){ if(indegree[i] == 0) q.push(i); } int cnt=0; while(!q.empty()){ int x=q.front();q.pop(); a[++cnt] = x; for(int i=head[x];i;i=nxt[i]){ indegree[ver[i]] -- ; if(indegree[ver[i]]==0){ q.push(ver[i]); } } } for(int i=1;i&lt;=n;i++){ printf(&quot;%d &quot;,a[i]); } return 0; }","link":"/2019/03/09/e6-b8-85-e5-8c-97-e5-ad-a6-e5-a0-82noip2018-e9-9b-86-e8-ae-add4/"}],"tags":[{"name":"树形结构","slug":"树形结构","link":"/tags/树形结构/"},{"name":"dp","slug":"dp","link":"/tags/dp/"},{"name":"LCA","slug":"LCA","link":"/tags/LCA/"},{"name":"图论","slug":"图论","link":"/tags/图论/"},{"name":"Tarjan","slug":"Tarjan","link":"/tags/Tarjan/"},{"name":"精","slug":"精","link":"/tags/精/"},{"name":"数论","slug":"数论","link":"/tags/数论/"},{"name":"优","slug":"优","link":"/tags/优/"},{"name":"字符串","slug":"字符串","link":"/tags/字符串/"},{"name":"floyd","slug":"floyd","link":"/tags/floyd/"},{"name":"搜索","slug":"搜索","link":"/tags/搜索/"},{"name":"最小生成树","slug":"最小生成树","link":"/tags/最小生成树/"},{"name":"背包问题","slug":"背包问题","link":"/tags/背包问题/"},{"name":"区间dp","slug":"区间dp","link":"/tags/区间dp/"},{"name":"状态压缩，状压","slug":"状态压缩，状压","link":"/tags/状态压缩，状压/"},{"name":"拓扑排序","slug":"拓扑排序","link":"/tags/拓扑排序/"},{"name":"并查集","slug":"并查集","link":"/tags/并查集/"},{"name":"枚举","slug":"枚举","link":"/tags/枚举/"},{"name":"前缀和","slug":"前缀和","link":"/tags/前缀和/"},{"name":"数位dp","slug":"数位dp","link":"/tags/数位dp/"},{"name":"树链剖分","slug":"树链剖分","link":"/tags/树链剖分/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"}],"categories":[{"name":"OI","slug":"OI","link":"/categories/OI/"},{"name":"题目","slug":"OI/题目","link":"/categories/OI/题目/"},{"name":"随笔","slug":"随笔","link":"/categories/随笔/"},{"name":"知识点","slug":"OI/知识点","link":"/categories/OI/知识点/"},{"name":"集训","slug":"OI/集训","link":"/categories/OI/集训/"},{"name":"Contest","slug":"Contest","link":"/categories/Contest/"},{"name":"政治","slug":"政治","link":"/categories/政治/"}]}