{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":" CodeForces 484 B. Maximum Value","text":"题目链接 题目翻译：给定序列$a_n$，求$a_i \\% a_j$的最大值，$1 \\leq i,j \\leq n$且$a_i&gt;a_j$。 可以先将输入的数据由小到大排序，如果有相同的数据就去重，然后枚举除数，对于一个除数，从它的二倍开始，直到它大于数列中的最大值。 。。。好不通顺。。。看代码吧。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;bool cmp(const int&amp; a,const int&amp; b){ return a&gt;b;}struct Solution{ int n,ans,maxn,q; vector&lt;int&gt; a; void Solve(){ scanf(\"%d\",&amp;n); a.resize(n); for(int i=0;i&lt;n;i++){ scanf(\"%d\",&amp;a[i]); maxn=max(maxn,a[i]); } sort(a.begin(),a.end()); n=unique(a.begin(),a.end())-a.begin(); a.resize(n); for(int i=0;i&lt;n;i++){ int k=2*a[i]; while(k&lt;maxn+a[i]){ int x=lower_bound(a.begin(),a.end(),k)-a.begin()-1; if(x==-1){ k+=a[i]; continue; } //printf(\"k=%d a[%d]=%d a[x] mod a[i]=%d\\n\",k,x,a[x],a[x]%a[i]); ans=max(ans,a[x]%a[i]); k+=a[i]; } } printf(\"%d\\n\",ans); }};int main(){ Solution().Solve(); return 0;}","link":"/2019/06/06/codeforces-484-b-maximum-value/"},{"title":" 你好，初次见面。\t\t","text":"你好 按说这篇文章应该是第一篇，但是前几天因为博客搬过来点东西，耽搁了时间。 你好，朋友，我是吴越洋，虽然不知道你是谁，但是你来了，就是我们之间的缘分。 我第一次知道OI，是我初三上学期的时候，初中同学ssk带我入门了Python，那可能算是我第一次接触了真正的计算机，也从他的口中得知了OI。 那时，刚学习Python，还在简单的输入输出上徘徊，经常因为一个非常简单的字典问题思考数个小时，那时已经听说有人学OI了，我想或许我也可以尝试一下，但快中考了，所以也只是想想罢了。 不知不觉，中考已经结束了，我也如愿考上了想去的高中，虽然分数不是很高，但也算是圆了我初中的目标了吧。中考完，就开始疯玩了，也不知道什么时候看到一篇文章，上面写道一些关于信息学竞赛的故事，于是便想要学学试试。不久领完录取通知书后，正值七月中旬，学校让学竞赛，我考虑了一下，最后选择了OI。没想到碰到了asdfczf，于是就拉上他一起学了OI，成为了OIer。 暑假的竞赛班选拔一共持续了20天左右的时间，有四次考试，其间遇到了另外一位同学，qwerdkr，当时并没有想到他会成为和我们并肩学习的唯一的同学。最终，我们通过了最后的面试，进入了G1801班。 开学之后，我们认识了1702班的lzk，1703的njl，1602的hhm，mzy，znt，zhl，wxz，还有几个外校的神仙dky，yrt，ACCEPT，和小学同学jdx等OIers。再来看我们这一届，虽然比上一届学的人还少，但是每个人都在努力，我相信会有很大的收获。 不知道NOIp2019会有一个什么样的结果，可能能拿到省一？亦或什么也没有。但即使这样，我也不会后悔，因为它已经教给了我足够多的东西，我不会忘记。 差不多了，文笔很差，甚至有些逻辑不通，多多包涵。最后， 初次见面，请多关照。:bowtie:","link":"/2019/03/10/e4-bd-a0-e5-a5-bd-ef-bc-8c-e5-88-9d-e6-ac-a1-e8-a7-81-e9-9d-a2-e3-80-82/"},{"title":" 图论——Tarjan算法求lca\t\t","text":"Tarjan算法 tarjan算法本质是使用并查集对“向上标记法”的一种优化。它是一个离线算法。理论时间复杂度为$O(n+m)$。 在dfs当中，树中的节点一共可以分为3类： 已经访问完毕并且回溯的节点。在这些节点标记2。 已经开始递归，但是尚未回溯的节点。这些节点就是当前正在访问的节点$x$以及$x$的祖先。在这些节点标记1。 尚未访问的节点。不标记。 对于正在访问的节点$x$，它到根节点的路径以及标记为1。若$y$是以及访问完回溯的节点，那么$lca(x,y)$就是从y节点向上走，直到遇到第一个标记为1的节点。 可以使用并查集对此进行优化，即每次回溯时，把它所在的集合合并到它父亲所在的集合当中，这样，$lca(x,y)$只需查询$get(y)$，就等价于从y向上找到第一个标记为1的节点。 每当dfs回溯时，扫描有关x的所有讯问，若y的标记为2，则$lca(x,y)$就是$get(y)$。 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;const int SIZE=500009;struct Edge{ int to,next;}e[SIZE*2];int deep[SIZE],fa[SIZE],tot,head[SIZE],tag[SIZE],lca[SIZE];int n,m,s;vector&lt;int&gt; ask[SIZE],ask_id[SIZE];void add(int x,int y){ e[++tot].to=y; e[tot].next=head[x]; head[x]=tot;}int get(int x){ return x==fa[x]?x:fa[x]=get(fa[x]);}void tarjan(int x){ tag[x]=1; for(int i=head[x];i;i=e[i].next){ int y=e[i].to; if(tag[y]) continue; deep[y]=deep[x]+1; tarjan(y); fa[y]=x; } for(int i=0;i&lt;ask[x].size();i++){ if(tag[ask[x][i]]==2){ lca[ask_id[x][i]]=get(ask[x][i]); } } tag[x]=2;}int main(){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; for(int i=1;i&lt;=n;i++) fa[i]=i; for(int i=1;i&lt;n;i++){ int x,y; scanf(\"%d%d\",&amp;x,&amp;y); add(x,y),add(y,x); } for(int i=1;i&lt;=m;i++){ int x,y; scanf(\"%d%d\",&amp;x,&amp;y); ask[x].push_back(y); ask[y].push_back(x); ask_id[x].push_back(i); ask_id[y].push_back(i); } tarjan(s); for(int i=1;i&lt;=m;i++){ printf(\"%d\\n\",lca[i]); } return 0;}","link":"/2019/03/11/e5-9b-be-e8-ae-ba-tarjan-e7-ae-97-e6-b3-95-e6-b1-82lca/"},{"title":" 无向图的双连通分量\t\t","text":"双连通分量又分点双连通分量和边双连通分量两种。若一个无向图中的去掉任意一个节点(一条边)都不会改变此图的连通性，即不存在割点(桥)，则称作点(边)双连通图。一个无向图中的每一个极大点(边)双连通子图称作此无向图的点(边)双连通分量。——来自360百科 边双联通分量（e-DCC）的求法计算e-DCC只需要把原无向图中所有的桥删去后，会分成若干连通块，每一个连通块都是一个边双联通分量。 一般可以先使用Tarjan求出所有桥，再执行一次dfs，划分出每个连通块。 c[x]代表x点所处的边连通分量编号。 e-DCC的缩点把每个e-DCC看做一个节点，把桥看做连接$c[x]$和$c[y]$的无向边，产生一棵树。 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188 #include&lt;bits/stdc++.h&gt; using namespace std; const int SIZE=100009; struct Edge{ int to,next; }e[SIZE*2],ec[SIZE*2]; int head[SIZE],dfn[SIZE],low[SIZE],num,tot,dcc,c[SIZE]; int headc[SIZE],totc; bool bridge[SIZE]; int n,m; void add(int x,int y){ e[++tot].to=y; e[tot].next=head[x]; head[x]=tot; } void add_c(int x,int y){ ec[++totc].to=y; ec[totc].next=head[x]; headc[x]=totc; } void tarjan(int x,int in_edge){ dfn[x]=low[x]=++num; for(int i=head[x];i;i=e[i].next){ int y=e[i].to; if(!dfn[y]){ tarjan(y,i); low[x]=min(low[x],low[y]); if(dfn[x]&lt;low[y]) bridge[i]=bridge[i^1]=1; } else if(i!=(in_edge^1)){ low[x]=min(low[x],dfn[y]); } } } void dfs(int x){ c[x]=dcc; for(int i=head[x];i;i=e[i].next){ int y=e[i].to; if(c[y]||bridge[i]) continue; dfs(y); } } int main(){ cin&gt;&gt;n&gt;&gt;m; tot=1; for(int i=1;i&lt;=m;i++){ int x,y; cin&gt;&gt;x&gt;&gt;y; add(x,y),add(y,x); } for(int i=1;i&lt;=n;i++){ if(!dfn[i]) tarjan(i,0); } cout&lt;&lt;\"桥：\"&lt;&lt;endl; for(int i=2;i&lt;tot;i+=2){ if(bridge[i]) cout&lt;&lt;e[i].to&lt;&lt;\" \"&lt;&lt;e[i^1].to&lt;&lt;endl; } for(int i=1;i&lt;=n;i++){ if(!c[i]) dcc++,dfs(i); } for(int i=1;i&lt;=n;i++){ printf(\"%d属于第%d个dcc\\n\",i,c[i]); } //缩点 totc=1; for(int i=2;i&lt;=tot;i++){ int x=e[i^1].to,y=e[i].to; if(c[x]==c[y]) continue; add_c(c[x],c[y]); } printf(\"缩点后共%d个节点，%d条边\\n\",dcc,totc/2); for(int i=2;i&lt;totc;i+=2){ cout&lt;&lt;ec[i^1].to&lt;&lt;\" \"&lt;&lt;ec[i].to&lt;&lt;endl; } return 0; } ``` * * *#### 点双连通分量（v-DCC）的求法求出v-DCC，需要维护一个栈，按照如下方法维护栈： 1. 当一个节点被访问时，将它压入栈。 2. 当判定条件$dfn\\[x\\]\\\\leq low\\[y\\]$成立时，无论x是否为根，都需要： 1. 从栈顶不断弹出点，直至y被弹出。 2. 弹出的所有节点与x构成一个v-DCC。 $vector dcc\\[i\\]$表示第$i$个v-DCC的所有节点#### v-DCC的缩点设图中有n个v-DCC,m个割点，这样缩点后形成一张n+m的树。把每个割点与和它相邻的v-DCC相连接。#### 代码如下```cpp #include&lt;bits/stdc++.h&gt; using namespace std; const int SIZE=100010; struct Edge{ int to,next; }e[SIZE*2]; int head[SIZE],dfn[SIZE],low[SIZE],strck[SIZE],num,tot,sta,cnt; int n,m,root; bool cut[SIZE]; vector&lt;int&gt; dcc[SIZE]; Edge ec[SIZE*2]; int headc[SIZE],totc,tree_id[SIZE]; void add(int x,int y){ e[++tot].to=y; e[tot].next=head[x]; head[x]=tot; } void add_c(int x,int y){ ec[++totc].to=y; ec[totc].next=headc[x]; headc[x]=totc; } void tarjan(int x){ strck[++sta]=x; dfn[x]=low[x]=++num; int flag=0; for(int i=head[x];i;i=e[i].next){ int y=e[i].to; if(!dfn[y]){ tarjan(y); low[x]=min(low[x],low[y]); if(dfn[x]&lt;=low[y]){ flag++; if(x!=root||flag&gt;1) cut[x]=1; int z; cnt++; do{ z=strck[sta--]; dcc[cnt].push_back(z); }while(z!=y); dcc[cnt].push_back(x); } } else low[x]=min(low[x],dfn[y]); } } int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++){ int x,y; cin&gt;&gt;x&gt;&gt;y; add(x,y),add(y,x); } for(int i=1;i&lt;=n;i++){ if(!dfn[i]) root=i,tarjan(i); } printf(\"有%d个DCC\\n\",cnt); for(int i=1;i&lt;=cnt;i++){ printf(\"v-DCC #%d:\",i); //cout&lt;&lt;dcc[i].size(); for(int j=0;j&lt;dcc[i].size();j++){ printf(\"%d \",dcc[i][j]); } cout&lt;&lt;endl; } int treec=cnt; for(int i=1;i&lt;=n;i++){ if(cut[i]) tree_id[i]=++treec; } totc=1; for(int i=1;i&lt;=cnt;i++){ for(int j=0;j&lt;dcc[i].size();j++){ if(!cut[dcc[i][j]]) continue; add_c(i,tree_id[dcc[i][j]]); add_c(tree_id[dcc[i][j]],i); } } printf(\"缩点后共有%d个点，%d条边\\n\",treec,totc/2); printf(\"编号在[1,%d]的为原图v-DCC,编号大于%d的为原图割点。\\n\",cnt,cnt); for(int i=2;i&lt;totc;i+=2){ printf(\"%d %d\\n\",ec[i^1].to,ec[i].to); } return 0; }","link":"/2019/03/13/e6-97-a0-e5-90-91-e5-9b-be-e7-9a-84-e5-8f-8c-e8-bf-9e-e9-80-9a-e5-88-86-e9-87-8f/"},{"title":" 最短路算法——SPFA\t\t","text":"emmmm。。。我不得不承认。。。学OI这么长时间，并不会写SPFA。。。 好吧。。直接上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,s,dis[10009];bool flag,vis[10009];int cnt[10009];//环 struct Edge{ int to,nxt,w;}e[500009];int head[10009],tot;void add(int x,int y,int w){ e[++tot].to=y; e[tot].nxt=head[x]; e[tot].w=w; head[x]=tot;}void spfa(int st){ queue&lt;int&gt; q; q.push(st); dis[st]=0; while(!q.empty()){ int x=q.front(); q.pop(); vis[x]=1; for(int i=head[x];i;i=e[i].nxt){ int y=e[i].to; if(dis[y]&gt;dis[x]+e[i].w){ dis[y]=dis[x]+e[i].w; cnt[y]++; if(cnt[y]&gt;n){ flag=1; return; }//判环 if(!vis[y]){ q.push(y); vis[y]=1; } } } vis[x]=0; }}int main(){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; for(int i=1;i&lt;=m;i++){ int x,y,w; cin&gt;&gt;x&gt;&gt;y&gt;&gt;w; add(x,y,w); } memset(dis,0x3f,sizeof(dis)); spfa(s); for(int i=1;i&lt;=n;i++){ if(dis[i]==0x3f3f3f3f) cout&lt;&lt;2147483647&lt;&lt;\" \"; else cout&lt;&lt;dis[i]&lt;&lt;\" \"; } return 0;}","link":"/2019/05/15/e6-9c-80-e7-9f-ad-e8-b7-af-e7-ae-97-e6-b3-95-spfa/"},{"title":" 清北学堂noip2018集训D3\t\t","text":"高精度算法 大数的存储 思路大概就是把数以字符串的形式读入，然后将它们一位一位倒叙存进一个整形数组。 高精度加法 把每一位相加，若有进位就将下一位加一。 高精度乘法 与高精度加法类似。 示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;string s1,s2;int input(string &amp;s,int a[],int &amp;len){ cin&gt;&gt;s; len=s.length(); for(int i=0;i&lt;len;i++){ a[i]=s[len-i-1]-'0'; } return len;}int plus_(int a[],int b[],int lena,int lenb,int c[]){//O(n) int lenc=0; while(lenc&lt;lena||lenc&lt;lenb){ c[lenc]=a[lenc]+b[lenc]; if(c[lenc]&gt;=10){ c[lenc]-=10; c[lenc+1]++; } lenc++; } if(c[lenc]==0){ lenc--; } return lenc;}int time_(int a[],int b[],int lena,int lenb,int c[]){//O(n^2) int lenc; for(int i=0;i&lt;lenb;i++){ for(int j=0;j&lt;lena;j++){ c[i+j]+=a[j]*b[i]; lenc=i+j; } } lenc+=20; for(int i=0;i&lt;2000;i++){ c[i+1]+=c[i]/10; c[i]%=10; } while(c[lenc]==0){ lenc--; } return lenc;}int main(){ int a[2000],lena,b[2000],lenb,c[2000],lenc; memset(a,0,sizeof(a)); memset(b,0,sizeof(a)); memset(c,0,sizeof(a)); input(s1,a,lena); input(s2,b,lenb); lenc=time_(a,b,lena,lenb,c); for(int i=lenc;i&gt;=0;i--){ cout&lt;&lt;c[i]; } cout&lt;&lt;endl; memset(c,0,sizeof(c)); lenc=plus_(a,b,lena,lenb,c); for(int i=lenc;i&gt;=0;i--){ cout&lt;&lt;c[i]; }} 快速幂 $a^bmodc;a,b,c\\le 10^9$ 代码见Day1 进制转换 从10进制转其他进制 代码： 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;char s[100];int tot;int main(){ int a[20000]; int b=121; int tobase=2; cin&gt;&gt;b&gt;&gt;tobase; while(b&gt;0){ a[tot++]=b%tobase; b/=tobase; } for(int i=tot-1;i&gt;=0;i--){ printf(\"%d\",a[i]); } return 0;} 从其它进制转10进制 代码： 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;char s[100];int main(){ int base; cin&gt;&gt;base; scanf(\"%s\",s); int x=1; int num=0; int l=strlen(s); for(int i=l-1;i&gt;=0;i--){ int a = s[i]-'0'; if(a&gt;=base){ cout&lt;&lt;\"Error!\"; return 0; } num += a*x; x *= base; } cout&lt;&lt;num; return 0;} 素数 大于一且因数只有1和它本身。 算数基本定理 任何一个大于1的自然数 N,如果N不为质数，那么N可以唯一分解成有限个质数的乘积$N=P_1^{a_1}\\times P_2^{a_2}\\times P_3^{a_3}\\times ……\\times P_n^{a_n}$，这里$P_1&lt;P_2&lt;P_3……&lt;P_n$均为质数，其中指数$a_i$是正整数。 判断一个数是不是素数 一般算法 cpp #include&lt;bits/stdc++.h&gt; using namespace std; bool is_prime(int x){ for(int i=2;i*i&lt;=x;i++){ if(x%i==0) return 0; } return 1; } int main(){ int n; cin&gt;&gt;n; cout&lt;&lt;is_prime(i); return 0; } $O(nloglogn)$算法 cpp #include&lt;bits/stdc++.h&gt; using namespace std; bool a[100000005]; int x[100000005]; int find_prime(int n){ int tot=0; for(int i=2;i&lt;=n;i++){ if(!a[i]){ x[tot++]=i; for(int j=2;j*i&lt;=n;j++){ a[j*i]=1; } } } return tot; } int main(){ int len=find_prime(100000); for(int i=0;i&lt;len;i++){ cout&lt;&lt;x[i]&lt;&lt;&quot; &quot;; } return 0; } gcd/lcm gcd:最大公约数 lcm:最小公倍数 $(a,b)[a,b]=ab$ gcd $gcd(a,b)=p_1^{min(a_1,b_1)}\\times p_2^{min(a_2,b_2)}\\times …\\times p_n^{min(a_n,b_n)}$ 怎么算？ 辗转相减 $gcd(a,b) = gcd(b,a-b)$ 辗转相除法 $gcd(a,b) = gcd(b,a\\%b)$ 代码如下： cpp int gcd(int a,int b){ if(b==0) return a; return gcd(b,a%b); } lcm $lcm(a,b)=p_1^{max(a_1,b_1)}\\times p_2^{max(a_2,b_2)}\\times …\\times p_n^{max(a_n,b_n)}$ 代码如下： cpp int lcm(int a,int b){ return a*b/gcd(a,b); } 示例代码1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;int gcd(int a,int b){ if(b==0) return a; return gcd(b,a%b);}int lcm(int a,int b){ return a*b/gcd(a,b);}int main(){ cout&lt;&lt;gcd(3,4)&lt;&lt;endl; cout&lt;&lt;lcm(3,4); return 0;} 裴蜀定理 $gcd(a,b)=d\\Rightarrow ax+by=d$ $gcd(a,b)=1\\Leftarrow\\Rightarrow ax+by=1$","link":"/2019/03/09/e6-b8-85-e5-8c-97-e5-ad-a6-e5-a0-82noip2018-e9-9b-86-e8-ae-add3/"},{"title":" 清北学堂noip2019-DP图论-Day1\t\t","text":"上午都是些概念啥的。。。 下午。。。回文问题 Q1:给定一个数列，求一个最长的回文子序列。 f[i][j]:A[i ~ j]的最长回文子序列 12345678910for (int i = 0; i &lt; n; i++) f[i][i] = 1;for (int step = 2; step &lt;= n; step++) { for (int i = 0; i + step - 1 &lt; n; i++) { int j = i + step - 1; f[i][j] = max(f[i + 1][j], f[i][j - 1]); if (A[i] == A[j]) f[i][j] = max(f[i][j], f[i + 1][j - 1] + 2); }} Q2:给定一个数列，求回文子序列的个数 f[i][j]:A[i ~ j]的回文子序列个数 用了个容斥原理emmmmmmmm 12345678910for (int i = 0; i &lt; n; i++) f[i][i] = 1;for (int step = 2; step &lt;= n; step++) { for (int i = 0; i + step - 1 &lt; n; i++) { int j = i + step - 1; f[i][j] = f[i][j - 1] + f[i + 1][j] - f[i + 1][j - 1]; if (A[i] == A[j]) f[i][j] += f[i + 1][j - 1] + 1; }} 乌龟棋 先使用一般的思路，可否使用下标作为状态？ 不行，因此使用每个类型卡牌的数量作为状态，定义$f[a][b][c][d]$为用a张1卡牌，b张2卡牌，c张3卡牌，d张4卡牌所得到的最高分数。这样可以判断当前位置$r=a+2\\times b+3\\times c+4\\times d$，再使用$w[i]$表示每个点的权值，即可得到状态转移方程： $f[a][b][c][d]=max(f[a][b][c][d],f[a-1][b][c][d]+w[r])$ $f[a][b][c][d]=max(f[a][b][c][d],f[a][b-1][c][d]+w[r])$ $f[a][b][c][d]=max(f[a][b][c][d],f[a][b][c-1][d]+w[r])$ $f[a][b][c][d]=max(f[a][b][c][d],f[a][b][c][d-1]+w[r])$ 最终答案即为$f[n][m][l][k]$,其中$n,m,l,k$分别为第$1,2,3,4$类型卡牌的张数。 NlogN的sd题。。。 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std; int i,j,n,s,t,a[100001];int main(){ cin&gt;&gt;n; a[0]=-1000000; for(i=0;i&lt;n;i++) { cin&gt;&gt;t; if(t&gt;a[s]) a[++s]=t; else { int l=1,h=s,m; while(l&lt;=h) { m=(l+h)/2; if(t&gt;a[m]) l=m+1; else h=m-1; } a[l]=t; } } cout&lt;&lt;s&lt;&lt;endl;} sd题的nlogn告诉我们：有时候善用贪心规则可以优化 DP 的时间复杂度！ 通过分析该题目可知，本质上是求一个最长抖动序列。。。类似lca这样的算法，$O(n^2)$只能码70分，满分算法需要$O(nlogn)$ 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;int a[1000009],f[1000009][2],n;int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; } f[1][0]=f[1][1]=1; for(int i=2;i&lt;=n;i++){ if(a[i]&gt;a[i-1]) f[i][0]=f[i-1][1]+1; if(a[i]&lt;a[i-1]) f[i][1]=f[i-1][0]+1; if(a[i]&lt;=a[i-1]) f[i][0]=f[i-1][0]; if(a[i]&gt;=a[i-1]) f[i][1]=f[i-1][1]; } cout&lt;&lt;max(f[n][0],f[n][1]); return 0;}","link":"/2019/04/30/e6-b8-85-e5-8c-97-e5-ad-a6-e5-a0-82noip2019-dp-e5-9b-be-e8-ae-ba-day1/"},{"title":" 清北学堂noip2019-DP图论-Day2树形DP\t\t","text":"清北学堂noip2019-DP图论-Day2树形DP 简单入门题——没有上司的舞会一棵树，每个点有权值，一个点和其儿子 / 父亲不能同时取，求解从树上选取点能获得的最大权值。 - 树形 DP 中的覆盖问题，同时是一个子树转移问题（当前树的最优解由子树的最优解得到） 对于这类问题，我们应该维护每个子树的最优解 并关注子树到根的转移方式 $dp[i][0]$ 表示我们不选择 $i$ 节点时子树的最大值 $dp[i][1]$ 表示我们选择 $i$ 节点时子树的最大值 转移方程，对于每个节点 $i$ 的所有子节点 $dp[i][0] += max(dp[j][0], dp[j][1])$ $dp[i][1] += dp[j][0]$12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int n,f[6009][2],value[6009],root;bool vis[6009];vector&lt;int&gt; son[6009];void dp(int u){ f[u][0]=0; f[u][1]=value[u]; for(int i=0;i&lt;son[u].size();i++){ int y=son[u][i]; dp(y); f[u][0]+=max(f[y][0],f[y][1]); f[u][1]+=f[y][0]; }}int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;value[i]; } while(1){ int x,y; cin&gt;&gt;x&gt;&gt;y; if(x==y&amp;&amp;x==0) break; vis[x]=1; son[y].push_back(x); } for(int i=1;i&lt;=n;i++){ if(vis[i]==0){ root=i; break; } } dp(root); cout&lt;&lt;max(f[root][0],f[root][1]); return 0;} Codeforce——767C Garland给定一个树，树有点权 要求你把树的某些边删去，使得树变成三个部分 每个部分的点权值和都相等 - 思路：可以想到，一旦能够找到一颗子树和为$w_总/3$就把它和它的父节点断开，即可。 - 原因：因为如果两颗子树的和各是总和的三分之一，那么它们一定不会有交集。 HDU 3586给定一颗无向带权树，要切断所有叶子节点和根节点的联系，每次切断的费用不能超过上限 Limit，问在保证 总费用 &lt;=m 的情况下最小的 Limit - 二分+树形DP - dp[u]表示u子树中上限为limit时符合条件的最小总费用。 那么可以这样设计转移： 123456if(dis(u,v)&gt;limit){ dp[u]+=dp[v];}else{ dp[u]+=min(dp[u],dis(u,v));} Luogu P2458——保安站岗设计状态$dp[i][0/1/2]$， - $dp[i][0]$表示靠父节点的控制 - $dp[i][1]$表示靠自己的控制 - $dp[i][2]$表示靠子节点的控制 这样即可推得状态转移方程： - $dp[u][0]=\\sum min(dp[v][1],dp[v][2])$ - $dp[u][1]=\\sum min(dp[v][0],dp[v][1],dp[v][2])+val[u]$ - $dp[u][2]=\\sum min(dp[v][1],dp[v][2])+某一个dp[v][2]$(这个比较麻烦。。。) 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; son[1509];int n,v[1509],dp[1509][3];void f(int x,int fa){ dp[x][0]=dp[x][1]=0; for(int i=0;i&lt;son[x].size();i++){ int y=son[x][i]; if(y==fa) continue; f(y,x); dp[x][0]+=min(dp[y][1],dp[y][2]); dp[x][1]+=min(min(dp[y][0],dp[y][1]),dp[y][2]); } dp[x][1]+=v[x];dp[x][2]=0x3f3f3f3f; for(int i=0;i&lt;son[x].size();i++){ int y=son[x][i]; if(y==fa) continue; dp[x][2]=min(dp[x][2],dp[x][0]-min(dp[y][1],dp[y][2])+dp[y][1]); }}int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ int x,m; cin&gt;&gt;x; cin&gt;&gt;v[x]; cin&gt;&gt;m; for(int i=1;i&lt;=m;i++){ int y; cin&gt;&gt;y; son[x].push_back(y); son[y].push_back(x); } } f(1,-1); cout&lt;&lt;min(dp[1][1],dp[1][2]); return 0;} 树上dp的链问题有一类树上 DP 的问题，求的是树上的满足条件的“最优链” 经典问题：HDU 2196 给定一棵有边权的树，输出树中与其距离最远的点的距离值 - 显然，从一个节点x出发到达的点只有两种情况： 1. 在x的子树中。 2. 在x的子树外。 显然第一种十分好维护，令 f[i] 表示以 i 为起点的，到 i 的子树内距离最远是多少 则 $f[i] = max(f[j] + dist(i,j))$ 那么第二种如何维护？我们令 $g[i]$ 表示 i 为起点到 i 的子树外距离最远是多少 第二种情况需要再做一次分类 一类是经过它的父亲，到父亲外，即 $g[i]$ &lt;- $g[fa[i]]$ 另一类是经过它的父亲，到了它的兄弟子树中","link":"/2019/04/30/e6-b8-85-e5-8c-97-e5-ad-a6-e5-a0-82noip2019-dp-e5-9b-be-e8-ae-ba-day2-e6-a0-91-e5-bd-a2dp/"},{"title":" 清北学堂noip2019-DP图论-Day2背包\t\t","text":"A.M. 背包和数位DP背包问题01背包 注意： 虽然一维空间的 0-1 背包不但省空间而且好写，但这并不意味着你可以忘记 0-1 背包二维的写法，有些题目其实会用到，而且输出方案的时候需要保持数组两维 0-1 背包问题有两种：第一种是输出容量不超过 V 的最大收益，而第二种则是输出容量恰好为 V 的最大收益，两者的预处理并不相同 Q：如何计算背包的方案总数与最优方案总数？ 方案总数for(int i=1;i&lt;=n;i++){ for(int j=0;j&lt;=m;j++){ f[i][j]=f[i-1][j]; if(j-v[i]&gt;=0) f[i][j]+=f[i-1][j-v[i]]; } }最优方案总数$f[i][j]$是一个正常01背包，$g[i][j]$表示前i个物品选择j体积的物品的最优方案总数。 for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= V; j++) { f[i][j] = f[i - 1][j]; if (j &gt;= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]); } for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= V; j++) { g[i][j] = g[i - 1][j]; if (j &gt;= v[i] &amp;&amp; f[i][j] == f[i - 1][j - v[i]] + w[i]) g[i][j] += g[i - 1][j - v[i]]; }例题——Luogu P1489 Q1：问一共 n 个人分成两队拔河，要求在保证两队人数的差的绝对值不超过1的情况下，输出两队体重差的绝对值的最小值。 这题看起来和背包没啥关系，但是仔细思考，可以发现$f[i][j][k]$表示前i个人里选j个可否组成k，这样问题就变成了01背包变形，第一维可以省去。 #include&lt;bits/stdc++.h&gt;using namespace std; int n,a[209],sum;bool f[209][80009]; int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; sum+=a[i]; } f[0][0]=1; for(int i=1;i&lt;=n;i++){ for(int j=n/2;j&gt;=1;j--){ for(int k=sum;k&gt;=a[i];k--){ if(f[j][k]||f[j-1][k-a[i]]) f[j][k]=1; } } } int ans1,ans2; for(int i=sum/2;i&gt;=0;i--){ if(f[n/2][i]) {ans1=i;break;} } ans2=sum-ans1; if(ans1&gt;ans2) swap(ans1,ans2); cout&lt;&lt;ans1&lt;&lt;&quot; &quot;&lt;&lt;ans2; return 0;} 完全背包 和01背包没啥区别，一个贪心预处理优化： 对于所有 Vi≥Vj，Ci≤Cj 的物品 i，都可以完全扔掉。 对于体积相同的物品只需要留下价值最大的物品。 对于随机数据，该优化力度很大。 多重背包多重背包问题，即每样物品 i ，有自己的体积 Vi，价值 Ci，和数量 Ti，数量并不是无限的，求最大价值 - 思路1：直接把其当做01背包，写出代码。 for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ for(int k=1;k&lt;=t[i];k++){ if(j-k*w[i]&gt;=0) f[j]=max(f[j],f[j-k*v[i]]+k*w[i]); } } }但很明显，这样做复杂度很高。 - 思路2：我们注意到我们只关心最终答案是几，而不关心我放进几个物品，所以当$T_i=3$时，我们可以不必放入3个$(V_i,W_i)$，而可以放入一个$(V_i,W_i)$和一个$(2V_i,2W_i)$，这样仍然可以枚举出放入3个的情况。因此，我们把每个$T_i$都分解为2的幂次，复杂度可以降到$O(n^2logn)$。 for(int i=1;i&lt;=n;i++){ int tt=t[i]; for(int k=1;k&lt;=tt;k&lt;&lt;=1){ for(int j=v;j&gt;=k*w[i];j--){ f[j]=max(f[j],f[j-k*w[i]]+k*v[i]); tt-=k; } } if(tt&gt;0){ for(int j=v;j&gt;=tt*w[i];j--){ f[j]=max(f[j],f[j-tt*w[i]]+tt*v[i]); } } } 分组背包每一个物品隶属于一个组，每个组里的物品是互斥的，意味着你在一组物品中只能选择一个物品。 for (int i = 1; i &lt;= K; i++) //一共有 K 组 for (int j = V; j &gt;= 0; j--) for (对于第 i 组内的物品k) dp[j] = max(dp[j], dp[j - v[k]] + w[k])","link":"/2019/05/01/e6-b8-85-e5-8c-97-e5-ad-a6-e5-a0-82noip2019-dp-e5-9b-be-e8-ae-ba-day2-e8-83-8c-e5-8c-85/"},{"title":" 清北学堂noip2019集训D5——动态规划\t\t","text":"动态规划 ==== 动态规划难点 意识到这个题用动态规划解决 高效设计状态 多做题 最长上升子序列问题 题目： （） 设计状态： $f[i]$表示以$a[i]$结尾的最长上升子序列长度。 最终答案$max_1\\leq i \\leq n$ 如何转移？ for(int i=1;i&lt;=n;i++){ f[i]=1; for(int j=1;j&lt;i;j++){ if(a[i]&lt;a[j]) f[i]=max(f[i],1+f[j]); }} 时间复杂度$O(n^2)$ 如何优化？ 方法一：树状数组优化 假设$a_i$互不相同。 离散化：$a_1,a_2,…,a_n$是一个${1,2,…,n}$的排列 DP值$f[i]$插入数组的$a_i$位置（这里树状数组用于求前缀max） 离散化？ //a[i]互不相同时int a[N];int a2[N];int ord[N];int cmp(int i,int j){ return a[i]&lt;a[j];}void lsh(){ for(int i=0;i&lt;=n;i++){ ord[i]=i; } sort(ord+1,ord+n+1,cmp); for(int i=1;i&lt;=n;i++){ a2[ord[i]]=a[i]; }} 时间复杂度$O(nlogn)$。 方法二：”单调栈” 令$g[j]$表示目前为止，长度为j的上升子序列的末尾元素最小是多少。 $a[1…5]={1,5,2,4,3}$ $g[1]=inf$ 插入1，$g[1]=1,g[2]=inf$ 插入5，$g[1]=1,g[2]=5,g[3]=inf$ 插入2，$g[1]=1,g[2]=2,g[3]=inf$ 插入4，$g[1]=1,g[2]=2,g[3]=4,g[4]=inf$ 插入3，$g[1]=1,g[2]=2,g[3]=3,g[4]=inf$ 如何快速更新？ 二分查找？ 时间复杂度$O(nlogn)$ 假如输入数列有重复？ 映射到不同的值上。 例题 输入一个整数序列$a_1,a_2,…,a_n$，最少需要修改几次使整个序列变成严格上升序列？（要求修改后均为整数）。 让$a_i$减去$i$，得到一个数列，求n-该数列最长不下降子序列长度。 最长公共子序列 状态：$f[i][j]$表示$s[1..i],t[1,,j]$的最长公共子序列 转移方程： $s[i]=t[j]：f[i][j]=f[i-1][j-1]+1$ $s[i]\\neq t[j]：f[i][j]=max{f[i-1][j],f[i][j-1]}$ 时间复杂度$O(n^2)$ 如果$s,t\\leq100000$呢？ 保证s中每一个元素出现的次数小于10次。 思路 如果互不相同 让t中在s中没有出现过的元素删去，让t以s的顺序排序，算一个最长上升子序列。 那次数$\\leq10$呢？ 转化为LIS（最长上升子序列） 例如： s=abdbad t=abcbd a:5,1 b:4,2 c:。。 d:6,3 所以t转化为5，1，4，2，4，2，6，3 再求t的最长上升子序列。 总结起来就是： 将每个元素在s中出现的下表以降序存在一个链表里，未完。。。 DAG上的dp 输入一个有向无环图（DAG），并给定起点s，边权为正，计算从s到每个点u的最长路长度$d[u]$. 要求时间复杂度$O(n+m)$ 先进行拓扑排序$v_1,v_2…,v_n$ 假设$v_1=s$。（否则，s走不到排在s前面的点，可以直接设置它们最短路为-inf） $d[v_i]=0$ 从$i=2,…,n$，枚举所有指向$v_i$的边，计算的$d[v_i]=max{d[v_j]+w(v_j,v_i)}$ 记忆化搜索 背包问题01背包 有$n$个物品，每个有体积$w[i]$,价值$v[i]$。总体积为$W$的背包最多能装多少总价值？ $(n,W\\leq2000)$ 设计状态：$f[i][j]$表示$j$体积装前$i$件物品，最大的总价值。 如何转移？ $f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+v[i])$ cpp for(int i=1;i&lt;=n;i++){ for(int j=0;j&lt;=w[i];j++) f[i][j]=f[i-1][j]; for(int j=w[i];j&lt;=W;j++){ f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+v[i]) } } 优化空间后： for(int i=1;i&lt;=n;i++){ for(int j=W;j&gt;=w[i];j--){ f[j]=max(f[j],f[j-w[i]]+v[i]) } } 完全背包 有$n$种物品，每种有体积$w[i]$,价值$v[i]$且有无限个。总体积为$W$的背包最多能装多少总价值？ $(n,W\\leq2000)$ cpp for(int i=1;i&lt;=n;i++){ for(int j=w[i];j&lt;=W;j++){ f[j]=max(f[j],f[j-w[i]]+v[i]) } } 子集和问题 有$n$个物品，第$i$个体积为$w_i$。能否选出一个子集和，使总容量为$W$的背包装满？ $f[i][j]=1 or 0$表示用前$i$件物品能否凑出$j$体积。 $f[0][0]=1$ cpp for(int i=1;i&lt;=n;i++){ for(int j=0;j&lt;=W;j++) f[i][j]=f[i-1][j]; for(int j=w[i];j&lt;=W;j++){ if(f[i-1][j-w[i]]) f[i][j]=1; } } //f[n][W]==1 or 0? 动态子集和问题 01背包 有$n$个物品，每个有体积$w[i]$,价值$v[i]$。总体积为$W$的背包最多能装多少总价值？ $(n\\leq2000，v[1]+v[2]+···+v[n]\\leq2000,W\\leq10^9)$ 小技巧：反转状态和dp值 状态$f[i][v]$表示前$i$件物品凑出$v$的总价值最小总体积。 边界$f[0][0]=0$。 伪代码： f[0][0]=0;for(int i=0;i&lt;=n;i++){ f[0][i]=inf;} for(int i=1;i&lt;=n;i++){ for(int j=0;j&lt;=2000;j++){ f[i][j]=f[i-1][j]; } for(int j=0;j&lt;=2000;j++){ f[i][j]=min(f[i][j],f[i-1][j-v[i]]+w[i]); }} 区间DP合法子序列问题 一个由$$组成的序列，求出最长的合法子序列长度，$(n\\leq300)$。 定义：合法子序列是一个合法的括号序列，每一对匹配的括号都是同一类型的。比如$()[]$是合法的。 设计状态： $f[i][j]$表示在$[i,j]$有多长的合法子序列。 转移： 如果$a[l],a[r]$是匹配的括号，则$2+f[l+1][r-1]$ 枚举断点$k:f[l][k]+f[k+1][r]$ 按什么顺序进行DP？ 区间长度从小到大的顺序。 （或者：记忆化搜索） 时间复杂度：$O(n^3)$ 矩阵链乘法 将一个$p \\times q$的矩阵乘一个$q \\times r$的矩阵，得到一个$p \\times r$的矩阵，运算花费是$p \\times q \\times r$。 现在输入$p_1,p_2,p_3,…,p_n$。将$p_1 \\times p_2,p_2 \\times p_3,…,p_{n-1} \\times p_n$的矩阵乘起来，最小的总运算花费是多少？ 例题n（记不清了） - 设计状态： $f[l][r]$表示$a[l,r]$字串的答案。 - 转移：$f[l][k]+f[k+1][r]$ 当a[l]==a[r]时，未完。。。 Floyd也是dp n个点的无向图，有向点和边权。每一对s，t，计算从s到t的路径，使得最小化：路径上的总边权+路径最大点权 $(n\\leq300)$ 状态压缩DP经典问题 求n个点的无向图的色数。（可以把顶点染成k种颜色之一，使得每条边两端不同色。最小的k是多少） $n\\leq16$ 设计状态，用f[s]表示结点子集S的色数。枚举子集进行转移。 $f[S]=min(f[S],1+f[S-T])$，T是S的子集$((T\\&amp;S)==t)$，T中的点两两不相邻。","link":"/2019/03/09/e6-b8-85-e5-8c-97-e5-ad-a6-e5-a0-82noip2019-e9-9b-86-e8-ae-add5-e5-8a-a8-e6-80-81-e8-a7-84-e5-88-92/"},{"title":" 清北学堂noip2019集训D6——动态规划\t\t","text":"状态压缩DP 最短哈密顿回路问题 给定一个完全图，带正边权$w(u,v)$。求出一个顶点的排列$v_1,v_2,…,v_n$，使得$w(v_1,v_2),w(v_2,v_3),…,w(v_{n-1},v_n),w(v_n,v_1)$的和最小。 $n\\leq17$ $f[i][j]$表示在$i$这个点集中，从$0$到$j$的最短距离。（$0和$j$都在$i$集合里）//0~n-1 for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) f[i][j]=inf; f[1&lt;&lt;0][0]=0; for(int i=1;i&lt;(1&lt;&lt;n);i++){ if(!(i&amp;1)) continue; for(int j=0;j&lt;n;j++){ if(!((1&lt;&lt;j)&amp;1)) continue; for(int k=1;k&lt;n;k++){ if((1&lt;&lt;k)&amp;i) continue; f[i|(1&lt;&lt;k)][k]=min(f[i|(1&lt;&lt;k)][k],f[i][j]+w[j][k]); } } } int ans=inf; for(int j=1;j&lt;n;j++){ ans=min(ans,f[(1&lt;&lt;n)-1][j]+w[j][0]); } 例题2 - 设计状态： $f[i][S]$表示只填入前i行当每个格子，有多少种合法方案，使得第$i$行当01串等于$S$。（合法：相邻两个格子不同时为$1$）。 sum1234567891011121314151617181920bool xl[1&lt;&lt;10];for(int i=0;i&lt;(1&lt;&lt;10);i++) if(\"S串中存在两个相邻的1\"){ xl[S]=1; }for(int s=0;s&lt;(1&lt;&lt;m);s++) f[1][s]=!xl[s];for(int i=2;i&lt;n;i++){ for(int =0;s&lt;(1&lt;&lt;m);s++){ if(xl[s]) f[i][s]=0; else{ //假设上一行填的是t for(int t=0;t&lt;(1&lt;&lt;m);t++){ if((t&amp;s)==0) f[i][s]=(f[i][s]+f[i-1][t])%p; } } }} &lt;/code&gt;&lt;/pre&gt; - 优化后 12345678910111213141516171819202122232425 sum=0; for(int i=0;i&lt;(i&lt;&lt;n);i++){ sum=sum+f[n][i]%p; }bool xl[1&lt;&lt;10];for(int i=0;i&lt;(1&lt;&lt;10);i++) if(\"S串中存在两个相邻的1\"){ xl[S]=1; }for(int s=0;s&lt;(1&lt;&lt;m);s++) f[1][s]=!xl[s];for(int i=2;i&lt;n;i++){ for(int =0;s&lt;(1&lt;&lt;m);s++){ if(xl[s]) f[i][s]=0; else{ int buji=(1&lt;&lt;m)-1-s;//补集 for(int t=buji;t;t=(t-1)&amp;buji){ f[i][s]=(f[i][s]+f[i-1][t])%p; } f[i][s]=(f[i][s]+f[i-1][0])%p; } }} Dominating set支配集 一个无向图的支配集是一个点的子集$S$，使得图中每个点都属于S或者与至少与一个$S$中的节点相邻 二者至少一个成立 $n$个点的二分图，求其最小支配集。$n\\leq30$(两边一共$n$个点)","link":"/2019/03/09/e6-b8-85-e5-8c-97-e5-ad-a6-e5-a0-82noip2019-e9-9b-86-e8-ae-add6-e5-8a-a8-e6-80-81-e8-a7-84-e5-88-92/"},{"title":" Luogu P1026 统计单词个数\t\t","text":"这两天都忙得忘了写了。。。 今天把这几天做的好题都补一下吧。。。 题目链接 老实说，这道题已经困扰我好几个月了，刚学dp就知道这道题，现在才做出来，所以准备写一下。。 题意大概就是给一个字符串，和一堆单词，问把这个字符串分成k段后，每段的单词数量的和的最大值是多少。 这道题用string的几个方法非常方便。 - 1.find(2)在第一个字符串中查找字符串2，并返回第一个下标，如果不存在，返回1844674407370955161这是个什么鬼东西我也不知道。 - .substr(x,len)取出字符串中以x开头长度为len的一个子字符串。 设计状态：$f[i][k]$代表前i个字符分成k段的最大单词总数。 转移：$f[i][k]=max(f[i][k],f[j][k-1]+sum[j+1][i])$枚举断点j，$sum[i][j]$代表原字符串从i到j的单词总数，先预处理一下。 剩下的看代码吧： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;int n,k,m;string s,x;string d[8];int dl[8],sum[209][209];int dp[209][49];bool pd(int l,int r){ string x=s.substr(l,r-l+1); for(int i=1;i&lt;=m;i++){ if(x.find(d[i])==0) return 1; } return 0;}int main(){ cin&gt;&gt;n&gt;&gt;k; s=\"0\"; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;x; s=s+x; } cin&gt;&gt;m; for(int i=1;i&lt;=m;i++){ cin&gt;&gt;d[i]; } int len=s.length()-1; for(int i=len;i&gt;=1;i--){ for(int j=i;j&gt;=1;j--){ sum[j][i]=sum[j+1][i]; if(pd(j,i)) sum[j][i]++; } } for(int i=1;i&lt;=len;i++) dp[i][1]=sum[1][i]; for(int q=1;q&lt;=k;q++){ for(int i=q+1;i&lt;=len;i++){ for(int j=q;j&lt;i;j++){ dp[i][q]=max(dp[i][q],dp[j][q-1]+sum[j+1][i]); } } } cout&lt;&lt;dp[len][k]; return 0;}","link":"/2019/05/28/luogu-p1026-e7-bb-9f-e8-ae-a1-e5-8d-95-e8-af-8d-e4-b8-aa-e6-95-b0/"},{"title":" Luogu P1073 最优贸易\t\t","text":"题目链接 这道题没太明白。。。 题解好多种方法，我就看了看第一种方法。 动态规划+dfs $f[x]$表示到x节点所能拿到差价的最大值。 状态转移方程：$f[x]=max(f[fa],c[x]-minx)$ $c[x],minx$分别是x节点的售价和到x节点的路上的最小售价。 剩下的写注释吧。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,w[100009];struct Edge{ int to,nxt;}e[1000009];int head[100009],tot;int f[100009],minn[100009];void add(int x,int y){ e[++tot].to=y; e[tot].nxt=head[x]; head[x]=tot;}void dfs(int x,int fa,int minx){ int pd=1;//这个就是判断要不要继续找下去的一个变量。 minx=min(minx,w[x]);//更新minx if(minx&lt;minn[x]) minn[x]=minx,pd=0;//minn保存的是到x节点最小值，这里就是如果最小值小于上一次访问这个节点的最小值，就更新。 int maxx=max(f[fa],w[x]-minx);//dp if(f[x]&lt;maxx) f[x]=maxx,pd=0;//这里是如果这次最大值大于上次访问这个节点时候的最大值，就要把这个新的值传递下去，直到全部传递完。 //其实就是这里不太明白。。。 if(pd) return; for(int i=head[x];i;i=e[i].nxt){ int y=e[i].to; dfs(y,x,minx); }}int main(){ cin&gt;&gt;n&gt;&gt;m; memset(minn,0x3f,sizeof(minn)); for(int i=1;i&lt;=n;i++) cin&gt;&gt;w[i]; for(int i=1;i&lt;=m;i++){ int x,y,op; cin&gt;&gt;x&gt;&gt;y&gt;&gt;op; if(op==1) add(x,y); else add(x,y),add(y,x); } dfs(1,0,0x3f3f3f3f); cout&lt;&lt;f[n]; return 0;}","link":"/2019/05/21/luogu-p1073-e6-9c-80-e4-bc-98-e8-b4-b8-e6-98-93/"},{"title":" Luogu P1122 最大子树和\t\t","text":"链接标题 树形dp 统计出每个子树的大小，求max - 回溯时$f[x]=max(0,f[x_{son}])$代码如下1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;const int N=16009;vector&lt;int&gt; son[N];int v[N],n,maxn=-0x3f3f3f3f,f[N];void dp(int x,int fa){ f[x]=v[x]; for(int i=0;i&lt;son[x].size();i++){ int y=son[x][i]; if(y==fa) continue; dp(y,x); f[x]+=max(0,f[y]); } maxn=max(maxn,f[x]);}int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;v[i]; } for(int i=1;i&lt;n;i++){ int a,b; cin&gt;&gt;a&gt;&gt;b; son[a].push_back(b); son[b].push_back(a); } dp(1,0); cout&lt;&lt;maxn; return 0;}","link":"/2019/03/23/luogu-p1122-e6-9c-80-e5-a4-a7-e5-ad-90-e6-a0-91-e5-92-8c/"},{"title":" Luogu P1271 聚会的快乐\t\t","text":"题目链接 树上dp 水题，和《没有上司的舞会》基本一样，多个字符串的hash（可以直接用STL-map） 设计状态：f[i][0/1]表示第i个节点参加活动（1）或者不参加活动（0）。 状态转移方程： $f[fa][1]+=f[x][0]$ $f[fa][0]+=max(f[x][0],f[x][1])$ 代码如下12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;map&lt;string,int&gt; hash;vector&lt;int&gt; son[209];struct Edge{ string u,fa; int w; }edge[209];int n,f[209][2],tot,tot_h,val[209],head[209];void dp(int x,int fa){ f[x][0]=0; f[x][1]=val[x]; for(int i=0;i&lt;son[x].size();i++){ int y=son[x][i]; if(y==fa) continue; dp(y,x); f[x][1]+=f[y][0]; f[x][0]+=max(f[y][0],f[y][1]); }}int main(){ cin&gt;&gt;n; int s; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;edge[i].u&gt;&gt;val[i]&gt;&gt;edge[i].fa; hash[edge[i].u]=i; } for(int i=1;i&lt;=n;i++){ son[hash[edge[i].fa]].push_back(i); } for(int i=1;i&lt;=n;i++){ if(!hash[edge[i].u]) s=i; } dp(s,-1); cout&lt;&lt;max(f[s][1],f[s][0]); return 0;}","link":"/2019/03/22/luogu-p1271-e8-81-9a-e4-bc-9a-e7-9a-84-e5-bf-ab-e4-b9-90/"},{"title":" Luogu P1282 多米诺骨牌（精）\t\t","text":"题目链接 总结一下：这种题用背包。。。（蒟蒻的我看不出来qwq） 我们先把骨牌翻转，调整至点数大的在上面 这样，我们就能保证上方的点数一定比下方大，并且保证每翻转一 次，都能使上下的点数之差变小，而变小的点数，就是上下点数之差乘以2。 把改变的点数看成物品的体积，初始上下方的点数之差看做背包体积，不难看出背包问题的模型。 那么物品的重量是什么呢？ 因为我们一开始就把点数大的放在了上面，而每放一次，翻转次数就+1。考虑：要是我后来后悔了，我发现不翻这个骨牌更好怎么办？那我会把它翻回来，那么相当于没有翻这个骨牌。 因此，一开始翻过的骨牌重量就是-1，未翻过的骨牌重量就是1（重量等价于翻转次数） 当然，上下相同的骨牌就是体积为0，重量为0的物品，因为他们无论怎么翻，都不会对上下点数差造成影响。 至此，背包的模型就出来了。这个问题被简化成：有n个物品，给出每个物品的体积v[i],他们的重量是1或-1。背包的重量为base，体积为tot，现在请把这n个物品放到背包里去，总体积不能超过tot，体积最大的情况下使得物品重量之和最小。 其中，dp[i][j]表示前i件物品能装到体积为j的最小重量 vs[i][j]表示前i件物品能否装到j体积 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,c;struct node{ int a,b;}a[1009];int f[1009][5009],v[1009],w[1009];bool vis[1009][5009];int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i].a&gt;&gt;a[i].b; if(a[i].a&lt;a[i].b){ swap(a[i].a,a[i].b); w[i]=-1; v[i]=a[i].a-a[i].b; m+=v[i]; v[i]*=2; c++; } else{ w[i]=1; v[i]=a[i].a-a[i].b; m+=v[i]; v[i]*=2; } } for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ f[i][j]=f[i-1][j]; vis[i][j]=vis[i-1][j]; if(vis[i-1][j-v[i]]||j-v[i]==0){ if(!vis[i][j]){ f[i][j]=f[i-1][j-v[i]]+w[i]; vis[i][j]=1; } else{ f[i][j]=min(f[i][j],f[i-1][j-v[i]]+w[i]); } } } } for(int i=m;i&gt;=0;i--){ if(vis[n][i]){ cout&lt;&lt;f[n][i]+c; return 0; } } return 0;}","link":"/2019/05/08/luogu-p1282-e5-a4-9a-e7-b1-b3-e8-af-ba-e9-aa-a8-e7-89-8c-ef-bc-88-e7-b2-be-ef-bc-89/"},{"title":" Luogu P1353 [USACO08JAN]跑步Running\t\t","text":"题目链接 这是道绿题？？？？ 简单到不敢相信 直接上代码： 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;int f[10009][509],n,m,a[10009];int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; } f[1][1]=a[1]; //f(i,j)代表前i个时间里劳累度为j的最大路程。 for(int i=1;i&lt;=n;i++){ for(int j=0;j&lt;=m&amp;&amp;j&lt;=i;j++){ if(j==0){ f[i][j]=max(f[i][j],f[i-1][j]); } else{ f[i+j][0]=max(f[i+j][0],f[i][j]); } f[i+1][j+1]=max(f[i+1][j+1],f[i][j]+a[i+1]); } } cout&lt;&lt;f[n][0]; return 0;}","link":"/2019/03/12/luogu-p1353-usaco08jan-e8-b7-91-e6-ad-a5running/"},{"title":" Luogu P1363 幻想迷宫\t\t","text":"链接 看完题目，最开始的思路是先对图进行搜索，然后搜索在边界的位置是否有道路可以通向这张图对面相同的位置，但是这样的情况就判断不了。 S.#.. ##### #...#很明显这张图中上面的道路和下面的道路并不直接相连，但是却可以无限延伸。 所以我看了题解。。。 掌嘴。。。 我好菜啊。。。 心里好慌。。。 然后就是搜索，每一个点向四个方向搜，如果搜到边界，用取模的方式到这张地图的另外一边，同时保存其真实的坐标，这样一来，当真实坐标和这个位置上次访问到的坐标不同时，说明这个点访问了两次，就是说可以无限延伸。 具体看代码吧 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;int a[1509][1509];struct node{ int x,y; bool v;}d[1509][1509];bool flag=0;int yc[4]={0,0,-1,1},xc[4]={1,-1,0,0};void dfs(int x,int y,int rx,int ry){ if(flag) return; if(d[x][y].v&amp;&amp;(d[x][y].x!=rx||d[x][y].y!=ry)){ flag=1; return; } d[x][y].x=rx,d[x][y].y=ry,d[x][y].v=1;//这里更新一下相当于上次访问到的真实坐标。 for(int i=0;i&lt;4;i++){ int nx,ny; if(x+xc[i]==0) nx=n; else if(x+xc[i]==n+1) nx=1; else nx=x+xc[i]; if(y+yc[i]==0) ny=m; else if(y+yc[i]==m+1) ny=1; else ny=y+yc[i]; int nrx=rx+xc[i],nry=ry+yc[i]; if(!a[nx][ny]&amp;&amp;(d[nx][ny].x!=nrx||d[nx][ny].y!=nry||!d[nx][ny].v)){ dfs(nx,ny,nrx,nry); } }}int main(){ node start; while(cin&gt;&gt;n&gt;&gt;m){ flag=0; for(int i=1;i&lt;=n;i++){ string c; cin&gt;&gt;c; for(int j=1;j&lt;=m;j++){ d[i][j].x=0,d[i][j].y=0,d[i][j].v=0; a[i][j]=0; if(c[j-1]=='#') a[i][j]=1; if(c[j-1]=='S') start.x=i,start.y=j; } } dfs(start.x,start.y,start.x,start.y); if(flag) cout&lt;&lt;\"Yes\"&lt;&lt;endl; else cout&lt;&lt;\"No\"&lt;&lt;endl; } return 0;}","link":"/2019/05/31/luogu-p1363-e5-b9-bb-e6-83-b3-e8-bf-b7-e5-ae-ab/"},{"title":" Luogu P1537 弹珠\t\t","text":"题目链接 水背包，$f[i]$表示能否凑成$i$价值的物品； 分成两组，及判断$f[sum/2]$的情况。 代码12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int f[210009],a[7],s,tot;int main(){ while(1){ tot++; s=0; for(int i=1;i&lt;=6;i++){ cin&gt;&gt;a[i]; s+=a[i]*i; } if(s==0) break; printf(\"Collection #%d:\\n\",tot); if(s%2==1){ printf(\"Can't be divided.\\n\\n\"); continue; } f[0]=1; for(int i=1;i&lt;=6;i++){ for(int j=s/2;j&gt;=i;j--){ for(int k=1;k&lt;=a[i];k++){ if(i*k&lt;=j&amp;&amp;f[j-k*i]==1) f[j]=1; } } } if(f[s/2]==1) printf(\"Can be divided.\\n\\n\"); else printf(\"Can't be divided.\\n\\n\"); for(int i=1;i&lt;=s/2;i++) f[i]=0; } return 0;}","link":"/2019/03/24/luogu-p1537-e5-bc-b9-e7-8f-a0/"},{"title":" Luogu P1550 [USACO08OCT]打井Watering Hole\t\t","text":"题目链接 这道题的思路感觉可以留下来，题目大意就是每个村能打一个井，也能挖水渠到其他村，但是需要所有村都有水，问最小花费。 - 可以建一个虚拟节点，和每个村连起来，边权就是打水井的花费，挖水渠就正常建边。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n,fa[309];int find(int x){ return x==fa[x]?x:fa[x]=find(fa[x]);}struct Edge{ ll x,y,w;}e[180009];int tot;void add(int x,int y,int w){ e[++tot].x=x; e[tot].y=y; e[tot].w=w;}bool cmp(Edge a,Edge b){ return a.w&lt;b.w;}ll kru(){ ll ans=0,cnt=0; for(int i=1;i&lt;=tot;i++){ int xx=find(e[i].x),yy=find(e[i].y); if(xx==yy) continue; fa[xx]=yy; ans+=e[i].w; cnt++; if(cnt==n) break; } return ans;}int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) fa[i]=i; for(int i=1;i&lt;=n;i++){ int w; cin&gt;&gt;w; add(0,i,w),add(i,0,w); } for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ int w; cin&gt;&gt;w; add(i,j,w); } } sort(e,e+tot+1,cmp); cout&lt;&lt;kru(); return 0;}","link":"/2019/05/16/luogu-p1550-usaco08oct-e6-89-93-e4-ba-95watering-hole/"},{"title":" Luogu P1594 护卫队\t\t","text":"题目链接 $f[i]$表示前$i$辆车通过桥所需要的最短时间,$len$表示桥长度，$minx[i][j]$表示从i到j的速度最小值，$sum[i]$表示前$i$辆车的重量前缀和。 - 首先$f[i]=len/v_i+f[i-1]$ - 枚举$j&lt;i$，如果第$j$到$i$辆车可以同时通过，那么$f[i]=min(f[i],f[j]+len/minx[j][i])$ 代码如下：123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;long long g,l,n;struct node{ long long w,s;}a[1009];long long minx[1009][1009],sum[1009];double dp[1009];int main(){ cin&gt;&gt;g&gt;&gt;l&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i].w&gt;&gt;a[i].s; sum[i]=sum[i-1]+a[i].w; minx[i][i]=a[i].s; } for(int i=1;i&lt;=n;i++){ for(int j=i+1;j&lt;=n;j++){ minx[i][j]=min(a[j].s,minx[i][j-1]); } } for(int i=1;i&lt;=n;i++){ dp[i]=(double)l/a[i].s+dp[i-1]; for(int j=i;j&gt;0;j--){ if(sum[i]-sum[j-1]&lt;=g) dp[i]=min(dp[i],dp[j-1]+(double)l/minx[j][i]); } } dp[n]*=60; printf(\"%.1lf\",dp[n]); return 0;}","link":"/2019/04/09/luogu-p1594-e6-8a-a4-e5-8d-ab-e9-98-9f/"},{"title":" Luogu P1622 释放囚犯\t\t","text":"题目链接 区间dp$f[i][j]$表示释放$i$\\~$j$的罪犯所需要的最少的肉，转移枚举分界点$k$。 转移方程:$f[i][j]=min(f[i][j],f[i][k-1]+f[k+1][j]+a[j+1]-a[i-1]-1)$ $a[j+1]-a[i-1]-1$就是第$i-1$到$j+1$个罪犯之间的人数，及所需肉的数量。 - 注意，上述方程需要满足单调性，所以先排序。 代码如下:12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int a[1009],f[109][109];int n,m;int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++){ cin&gt;&gt;a[i]; f[i][i]=n-1; } a[m+1]=n+1; sort(a+1,a+m+1); for(int l=1;l&lt;=m;l++){ for(int i=1;i+l-1&lt;=m;i++){ int j=i+l-1; f[i][j]=0x3f3f3f3f; for(int k=i;k&lt;=j;k++){ if(f[i][j]&gt;f[i][k-1]+f[k+1][j]+a[j+1]-a[i-1]-2) f[i][j]=f[i][k-1]+f[k+1][j]+a[j+1]-a[i-1]-2; } } } cout&lt;&lt;f[1][m]; return 0;}","link":"/2019/03/15/luogu-p1622-e9-87-8a-e6-94-be-e5-9b-9a-e7-8a-af/"},{"title":" Luogu P1651 塔\t\t","text":"题目链接 突然发现，我还是太菜了。 这道题做了一个半小时，开始的一个小时想的都是错的，后来还是看了题解，本来我想的是用bool数组$f[i][j]$来表示从木块中选i个木块能否组成j的高度，用0和1表示。后来打了70分（数据好水）才发现这有后效性。 正解因为题目中讲能否选择几个木块构成两个高度相同的塔，要求输出这个塔的最大高度，那么就可以想到，使用$f[i][j]$来表示选到第i个时，且两个塔的高度差为j时，较高的那个塔的高度，这样便有四个状态可以转移。 - 不放第i个：$f[i][j]=f[i-1][j]$ - 把第i个放到较矮的塔上，矮塔还是矮塔：$f[i][j]=max(f[i][j],f[i-1][j+a[i]])$ - 放到较高的塔上，高塔当然高：$f[i][j]=max(f[i][j],f[i-1][j-a[i]]+a[i])$ - 放到较低的塔上，低塔变成高塔：$f[i][j]=max(f[i][j],f[i-1][a[i]-j]+j)$ 综上，代码如下： 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;int n,a[55],sum;int f[55][500005];int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; sum+=a[i]; } memset(f,-0x3f,sizeof(f)); f[0][0]=0; for(int i=1;i&lt;=n;i++){ for(int j=sum;j&gt;=0;j--){ f[i][j]=max(f[i][j],f[i-1][j]); f[i][j]=max(f[i][j],f[i-1][j+a[i]]); if(j&gt;=a[i]) f[i][j]=max(f[i][j],f[i-1][j-a[i]]+a[i]); if(j&lt;=a[i]) f[i][j]=max(f[i][j],f[i-1][a[i]-j]+j); } } if(f[n][0]&lt;=0) cout&lt;&lt;\"-1\"; else cout&lt;&lt;f[n][0]; return 0;}","link":"/2019/04/14/luogu-p1651-e5-a1-94/"},{"title":" Luogu P1875 佳佳的魔法药水\t\t","text":"链接 图论，明显是dijkstra，$d[i]$数组保存第$i$个药水的最小配置价格，$cnt[i]$保存第$i$个药水最小配置价格的方案数，具体过程： 1. 每次找一个没有访问过的配置价格最小的药水$x$。 2. 枚举所有可以和$x$组成新药水的药水$i$并且已经访问过的节点。 3. 如果$x$和$i$组成的新药水的最小配置价格$d[j]&lt;d[x]+d[i]$，那就更新，并且$cnt[j]=cnt[x] \\times cnt[i]$ 4. 否则如果$d[j]=d[x]+d[i]$，那么$cnt[j]+=cnt[i] \\times cnt[x]$ 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;int a[1509][1509];struct node{ int x,y; bool v;}d[1509][1509];bool flag=0;int yc[4]={0,0,-1,1},xc[4]={1,-1,0,0};void dfs(int x,int y,int rx,int ry){ if(flag) return; if(d[x][y].v&amp;&amp;(d[x][y].x!=rx||d[x][y].y!=ry)){ flag=1; return; } d[x][y].x=x,d[x][y].y=y,d[x][y].v=1; for(int i=0;i&lt;4;i++){ int nx,ny; if(x+xc[i]==0) nx=n; else if(x+xc[i]==n+1) nx=1; else nx=x+xc[i]; if(y+yc[i]==0) ny=m; else if(y+yc[i]==m+1) ny=1; else ny=y+yc[i]; int nrx=rx+xc[i],nry=ry+yc[i]; if(!a[nx][ny]&amp;&amp;(d[nx][ny].x!=nrx||d[nx][ny].y!=nry||!d[nx][ny].v)){ dfs(nx,ny,nrx,nry); } }}int main(){ node start; while(cin&gt;&gt;n&gt;&gt;m){ flag=0; for(int i=1;i&lt;=n;i++){ string c; cin&gt;&gt;c; for(int j=1;j&lt;=m;j++){ d[i][j].x=0,d[i][j].y=0,d[i][j].v=0; a[i][j]=0; if(c[j-1]=='#') a[i][j]=1; if(c[j-1]=='S') start.x=i,start.y=j; } } dfs(start.x,start.y,start.x,start.y); if(flag) cout&lt;&lt;\"Yes\"&lt;&lt;endl; else cout&lt;&lt;\"No\"&lt;&lt;endl; } return 0;}","link":"/2019/06/01/luogu-p1875-e4-bd-b3-e4-bd-b3-e7-9a-84-e9-ad-94-e6-b3-95-e8-8d-af-e6-b0-b4/"},{"title":" Luogu P1896 [SCOI2005]互不侵犯\t\t","text":"我感觉这道题还不错，状压dp的一类典型问题？ 题目链接 就是给个n*n的表格，然后放k个旗子，旗子每个旗子相邻的8个格子不能放旗子。问最多有几种放的方法。 状态就是$f[i][j][k]$表示第i行，状态为j，并且已经放了k个格子的方案总数。然后预处理一下can数组，保存左右互不侵犯的状态。再预处理$gs[i]$数组表示状态为i的有多少个旗子(i的二进制里有多少个1)。 这样枚举上一行状态，如果上一行和这一行满足左上，上，右上互不侵犯，那么$f[i][j][k+gs[i]]+=f[i-1][l][k]$ 最终答案就是所有$f[n][i][k]$的和。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n,k;ll f[10][1&lt;&lt;10][90],can[1&lt;&lt;10],tot;int gs[1&lt;&lt;10];int gs1(int x){ int cnt=0; while(x){ if(1&amp;x) cnt++; x&gt;&gt;=1; } return gs[tot]=cnt;}int main(){ cin&gt;&gt;n&gt;&gt;k; for(int i=0;i&lt;(1&lt;&lt;n);i++) if(!(i&amp;(i&lt;&lt;1))) can[++tot]=i,f[1][tot][gs1(i)]=1; for(int i=2;i&lt;=n;i++){ for(int j=1;j&lt;=tot;j++){ int a=can[j]; for(int l=1;l&lt;=tot;l++){ int b=can[l]; if(a&amp;b) continue; if(a&amp;(b&lt;&lt;1)) continue; if(a&amp;(b&gt;&gt;1)) continue; for(int g=0;g+gs[j]&lt;=k;g++) f[i][j][gs[j]+g]+=f[i-1][l][g]; } } } ll ans=0; for(int i=1;i&lt;=tot;i++) ans+=f[n][i][k]; cout&lt;&lt;ans; return 0;}","link":"/2019/05/28/luogu-p1896-scoi2005-e4-ba-92-e4-b8-8d-e4-be-b5-e7-8a-af/"},{"title":" Luogu P1983 车站分级\t\t","text":"题目链接 又是一道比较经典的题，据说有什么线段树优化构造。。。反正我是不懂。 这道题使用topsort（拓扑排序）的思想； 简化题意：n个车站，每个车站有一个级别，如果有一趟列车，这趟列车经过$a_1,a_2,···,a_s$站，且如果这些站中级别最低的车站的级别为$minx$，那么所有在起点站到终点站之间级别大于等于$minx$的车站都必须停靠。那么m趟列车，给定每趟列车的经过站（车站编号升序给出），求所有车站至少分成多少级。 思路：如果从起点站到终点站之间有火车站没有停靠，就说明这个火车站的级别一定小于所有停靠了的火车站，那么就将每个没有停靠的火车站向停靠的火车站连一条边，这样用topsort的思想，可算出最终分成了几层，便是最少的级别数量； 例如数据 1 3 5 6停靠 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,a[1009],cd[1009],st[1009];bool v[1009],top[1009][1009],del[1009];int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++){ memset(v,0,sizeof(v)); int s; cin&gt;&gt;s; for(int j=1;j&lt;=s;j++){ cin&gt;&gt;a[j]; v[a[j]]=1; } for(int j=a[1];j&lt;=a[s];j++){ if(!v[j]){ for(int k=1;k&lt;=s;k++){ if(top[a[k]][j]) continue; top[a[k]][j]=1; cd[a[k]]++; } } } } int r=1,ans=0; while(r){ r=0; for(int i=1;i&lt;=n;i++){ if(cd[i]==0&amp;&amp;!del[i]){ st[++r]=i; del[i]=1; } } if(r) ans++; for(int i=1;i&lt;=r;i++){ for(int j=1;j&lt;=n;j++){ if(!top[j][st[i]]) continue; top[j][st[i]]=0; cd[j]--; } } } cout&lt;&lt;ans; return 0;}","link":"/2019/06/03/luogu-p1983-e8-bd-a6-e7-ab-99-e5-88-86-e7-ba-a7/"},{"title":" Luogu P2024 [NOI2001]食物链\t\t","text":"题目描述动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。A 吃 B，B 吃 C，C 吃 A。 现有 N 个动物，以 1 － N 编号。每个动物都是 A,B,C 中的一种，但是我们并不知道 它到底是哪一种。 有人用两种说法对这 N 个动物所构成的食物链关系进行描述： 第一种说法是“1 X Y”，表示 X 和 Y 是同类。 第二种说法是“2 X Y”，表示 X 吃 Y 。 此人对 N 个动物，用上述两种说法，一句接一句地说出 K 句话，这 K 句话有的是真 的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 • 当前的话与前面的某些真的话冲突，就是假话 • 当前的话中 X 或 Y 比 N 大，就是假话 • 当前的话表示 X 吃 X，就是假话 你的任务是根据给定的 N 和 K 句话，输出假话的总数。 输入输出格式输入格式： 第一行两个整数，N，K，表示有 N 个动物，K 句话。 第二行开始每行一句话（按照题目要求，见样例） 输出格式： 一行，一个整数，表示假话的总数。 题解转载：Sooke’s OI Record","link":"/2019/03/09/luogu-p2024-noi2001-e9-a3-9f-e7-89-a9-e9-93-be/"},{"title":" Luogu P2280 [HNOI2003]激光炸弹\t\t","text":"题目链接 一道水体，很显然需要二维前缀和，然后考虑一个$O(n^2)$算法，枚举每一个点作为炸弹投放矩阵的右下角，这题就做完了qwq。 代码如下1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;const int N=5009;int a[N][N],ans;int main(){ int n,r; cin&gt;&gt;n&gt;&gt;r; for(int i=1;i&lt;=n;i++){ long long x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; a[x+1][y+1]=z; } for(int i=1;i&lt;=5001;i++){ for(int j=1;j&lt;=5001;j++){ a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1]; } } for(int i=r;i&lt;=5001;i++){ for(int j=r;j&lt;=5001;j++){ ans=max(ans,a[i][j]-a[i-r][j]-a[i][j-r]+a[i-r][j-r]); } } if(ans==0) return 0; cout&lt;&lt;ans; return 0;} P.S.绿题难度怎么差异这么大，也太简单了吧!","link":"/2019/03/18/luogu-p2280-hnoi2003-e6-bf-80-e5-85-89-e7-82-b8-e5-bc-b9/"},{"title":" Luogu P2285 [HNOI2004]打鼹鼠\t\t","text":"题目链接 我开始想到棋盘问题。。。三维数组爆空间。。。 然后就看了看算法标签 想了个一维dp $f[i]$表示前i个地鼠最多能被砸死几个，因为发现时间是按顺序排列的，所以可以想到从当前时间前面探出头的地鼠转移，所以 - $f[i]=max(f[i],f[j]+1)(a[j].t&lt;a[i].t$且$dis(i,j)\\leq tim(i,j))$ 代码： 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;int f[10009],n,m;struct node{ int t,x,y;}a[10009];int dis(int i,int j){ return abs(a[i].x-a[j].x)+abs(a[i].y-a[j].y);}int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++){ cin&gt;&gt;a[i].t&gt;&gt;a[i].x&gt;&gt;a[i].y; f[i]=1; } for(int i=1;i&lt;=m;i++){ for(int j=1;j&lt;=i-1;j++){ if(dis(i,j)&lt;=abs(a[i].t-a[j].t)){ f[i]=max(f[i],f[j]+1); } } } int ans=0; for(int i=1;i&lt;=m;i++){ ans=max(ans,f[i]); } cout&lt;&lt;ans; return 0;}","link":"/2019/05/09/luogu-p2285-hnoi2004-e6-89-93-e9-bc-b9-e9-bc-a0/"},{"title":" Luogu P2327 [SCOI2005]扫雷\t\t","text":"题目链接 思路： 这道题一开始想的状态是$f(i,j)$表示第i个位置放与不放炸弹（用j表示），后来怎么也写不对代码:sweat:，所以我看了眼题解，少了一维。 咳咳，正解： 先设计状态，$f(i,j,k)$表示第i个位置放不放炸弹和下一位放不放炸弹（分别用j，k表示），这样就可以推出转移的方法。 当第i位数字为0时，那直接从$f(i-1,0,0)$转移过来。 当为1时，就有分别把炸弹放到3个格子当中的3种方法。 当为2,3时，同理。 P.S. 题解上说答案只能是大于0，小于2，貌似是的，但是为什么？求大佬解释qwq。 代码如下：12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;int f[10009][2][2],a[10009],n;int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; } f[0][0][0]=f[0][0][1]=1;//第0个位置一定不选，下个位置有选和不选两种情况。 for(int i=1;i&lt;=n;i++){ if(a[i]==0)//如果这个位置为0，那这个位置和上下位置均不选。 f[i][0][0]+=f[i-1][0][0]; if(a[i]==1)//如果为1，那可以这个位置和上下两个位置任意一个选。下方同理。 f[i][1][0]+=f[i-1][0][1],f[i][0][1]+=f[i-1][0][0],f[i][0][0]+=f[i-1][1][0]; if(a[i]==2) f[i][1][0]+=f[i-1][1][1],f[i][0][1]+=f[i-1][1][0],f[i][1][1]+=f[i-1][0][1]; if(a[i]==3) f[i][1][1]+=f[i-1][1][1]; } cout&lt;&lt;f[n][1][0]+f[n][0][0];//在第n个选与不选的结果相加即为ans。 return 0;}","link":"/2019/03/11/luogu-p2327-scoi2005-e6-89-ab-e9-9b-b7/"},{"title":" Luogu P2340 奶牛会展\t\t","text":"题意：给定$n$组数，每组数包含2个数字$S_i$和$F_i$。 要求：取其中几组数，要求他们的和最大，并且所有$S_i$的和与$F_i$的和均大于0。 $1\\leq N\\leq 400$ $-1000\\leq S_i,F_i\\leq 1000$ 可以看出，每组数有选与不选两种情况，可以转化为01背包，让$S_i$作为物品体积，$F_i$作为物品价值。但是由题意可以发现，$S_i$有可能为负数，又因为$-1000\\leq S_i\\leq 1000$，所以背包体积可以是$-400000\\leq m\\leq 400000$，因为数组下标不可以为负，所以将整个数组向右平移$400000$个单位，把$400000$当做$0$。 这样如果$S_i&lt;0$那么正序枚举，反之倒序枚举。 代码： 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;int v[409],w[409];int f[800009],n;int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;w[i]&gt;&gt;v[i]; } memset(f,~0x3f,sizeof(f)); f[400000]=0; for(int i=1;i&lt;=n;i++){ if(v[i]&gt;=0){ for(int j=800000;j&gt;=v[i];j--){ f[j]=max(f[j],f[j-v[i]]+w[i]); } } else{ for(int j=0;j&lt;=800000+v[i];j++){ f[j]=max(f[j],f[j-v[i]]+w[i]); } } } int ans=0; for(int i=400000;i&lt;=800000;i++) if(f[i]&gt;=0) ans=max(ans,f[i]+i-400000); cout&lt;&lt;ans; return 0;}","link":"/2019/05/07/luogu-p2340-e5-a5-b6-e7-89-9b-e4-bc-9a-e5-b1-95/"},{"title":" Luogu P2733 家的范围\t\t","text":"题目链接 题目大意给定一个$n\\times n$的01矩阵，问其中所有由1组成的边长不同的正方形的数量。 输入6 101111 001111 111111 001111 101101 111001输出2 10 3 4 4 1 原来曾经做过一道题，用两个数组分别表示从一个点$(i,j)$向上、左走分别到达的第一个零的位置，这道题也能用。 - $l[i][j]$表示从$(i,j)$点开始向左走，最长的1序列的长度。 - 同理，$u[i][j]$表示从$(i,j)$点开始向上走，最长的1序列的长度。 - 理论复杂度$O(n^3)$ 详细解释看代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;int f[259],l[259][259],u[259][259],n;bool a[259][259];int main(){ cin&gt;&gt;n; string s; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;s; for(int j=1;j&lt;=n;j++){ a[i][j]=s[j-1]-'0'; if(a[i][j]) l[i][j]=u[i][j]=1; } } for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ if(a[i][j]) l[i][j]=max(l[i][j-1]+1,l[i][j]);//预处理l，u数组 if(a[i][j]) u[i][j]=max(u[i-1][j]+1,u[i][j]); } } int minx=0x3f3f3f3f,maxx=0,maxn=0; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ minx=0x3f3f3f3f; maxx=0;//maxx代表以（i，j）作为右下角的最大正方形的边长。 for(int k=i;i-k&lt;u[i][j];k--){ minx=min(minx,l[k][j]);//将minx更新为当前第k行至第i行最大矩阵的长。 if(min(minx,u[i][j])&gt;=2&amp;&amp;(i-k+1&lt;=min(minx,u[i][j]))) maxx=max(maxx,i-k+1); //如果当前边长大于二，并且当前宽小于等于长，就让maxx更新为最长边长的正方形。 } f[maxx]++;//以(i,j)为右下角的最大正方形的边长加一。 maxn=max(maxx,maxn); } } int t=0; for(int i=maxn;i&gt;1;i--){ f[i-1]+=f[i];//因为如果容纳一个边长为x的正方形，那一定可以容纳边长比i小的正方形。 } for(int i=2;i&lt;=n;i++){ if(f[i]) cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;f[i]&lt;&lt;endl; } return 0;}","link":"/2019/03/14/luogu-p2733-e5-ae-b6-e7-9a-84-e8-8c-83-e5-9b-b4/"},{"title":" Luogu P2948 [USACO09OPEN]滑雪课Ski Lessons\t\t","text":"题目链接 现在这蓝题都不好想啊qwq 设计状态：$f[i][j]$表示到一门课程结束时间为$i$，能力值为$j$的最多滑雪次数。 所以先给课程按结束时间排个序。 转移： 1. $dp[x][y]=max(dp[x][y],dp[x2][y2]+q)$，$q$是从上节课的结束时刻到这节课的开始时刻的最多滑雪次数。 2. $dp[x][y2]=dp[x2][y2]+(x-x2)/minn[y2]$，$minn[i]$是能力值为i时的最小滑雪时间； 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;int t,s,n;struct clas{ int begin,end; int v;}c[109];int a[10009][2],minn[10009];int f[10009][109];bool cmp(clas x,clas y){ return x.end&lt;y.end;}int main(){ cin&gt;&gt;t&gt;&gt;s&gt;&gt;n; memset(minn,0x3f,sizeof(minn)); for(int i=1;i&lt;=s;i++){ cin&gt;&gt;c[i].begin&gt;&gt;c[i].end&gt;&gt;c[i].v; c[i].end+=c[i].begin; } for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i][0]&gt;&gt;a[i][1]; minn[a[i][0]]=min(minn[a[i][0]],a[i][1]); } for(int i=1;i&lt;=100;i++) minn[i]=min(minn[i],minn[i-1]); sort(c+1,c+s+1,cmp); c[0].v=1,c[0].begin=0,c[0].end=0; for(int i=0;i&lt;=s;i++){ for(int j=0;j&lt;i;j++){ int ti1=c[i].end,v1=c[i].v; int ti2=c[j].end,v2=c[j].v; if(ti2&lt;c[i].begin) f[ti1][v1]=max(f[ti1][v1],f[ti2][v2]+(c[i].begin-ti2)/minn[v2]); f[ti1][v2]=max(f[ti1][v2],f[ti2][v2]+(ti1-ti2)/minn[v2]); } } for(int i=0;i&lt;=s;i++){ int ti=c[i].end,v=c[i].v; f[t][v]=max(f[t][v],f[ti][v]+(t-ti)/minn[v]); } int ans=0; for(int i=0;i&lt;=s;i++) ans=max(ans,f[t][c[i].v]); cout&lt;&lt;ans; return 0;}","link":"/2019/06/01/luogu-p2948-usaco09open-e6-bb-91-e9-9b-aa-e8-af-beski-lessons/"},{"title":" Luogu P3128 [USACO15DEC]最大流Max Flow\t\t","text":"题目链接 这几天在学LCA，这道题使用了LCA+树上差分的思路。 题目描述，每经过一次的点就会加1，换言之，就是统计每一个节点经过了多少次，所以可以使用树上差分快速得到每个点经过的次数。 我们可以这样统计：如果x和y之间有一条路径，那么可以看做x-&gt;lca(x,y),lca(x,y)-&gt;y；两条路径各自分别加1，但是这样lca（x，y）会被加两遍，所以cnt[x]++,cnt[y]++,cnt[lca(x,y)]-=2。 但是这样一来，lca(u,v)上+2又-2等于0，也就是u—&gt;v整条路经上除了lca(u,v)都加了1，为了排除这个干扰，我们把cnt[lca(u,v)]-=2改成- -cnt[lca(u,v)],- -cnt[lca(u,v)的父亲] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;int tot,head[50009],n,m,s,d[50009],f[50009][20],t,lg[50009],cnt[50009];struct Edge{ int to,next;}e[100009];void add(int x,int y){ e[++tot].to=y; e[tot].next=head[x]; head[x]=tot;}void dfs(int y,int x){ d[y]=d[x]+1; f[y][0]=x; for(int i=1;(1&lt;&lt;i)&lt;=d[y];i++) f[y][i]=f[f[y][i-1]][i-1]; for(int i=head[y];i;i=e[i].next) if(e[i].to!=x) dfs(e[i].to,y);}void dfs_sum(int u,int fa){ for(int i=head[u];i;i=e[i].next){ int y=e[i].to; if(y==fa) continue; dfs_sum(y,u); cnt[u]+=cnt[y]; }}int lca(int x,int y){ if(d[x]&gt;d[y]) swap(x,y); while(d[x]&lt;d[y]) y=f[y][lg[d[y]-d[x]]-1]; if(x==y) return x; for(int i=lg[d[x]]-1;i&gt;=0;i--) if(f[x][i]!=f[y][i]) y=f[y][i],x=f[x][i]; return f[x][0];}int main(){ scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;n;i++){ int x,y; scanf(\"%d%d\",&amp;x,&amp;y); add(x,y); add(y,x); } for(int i=1;i&lt;=n;i++) lg[i]=lg[i-1]+(1&lt;&lt;lg[i-1]==i); dfs(1,0); for(int i=1;i&lt;=m;i++){ int x,y; scanf(\"%d%d\",&amp;x,&amp;y); int lcas=lca(x,y); cnt[x]++,cnt[y]++,cnt[lcas]--,cnt[f[lcas][0]]--; } dfs_sum(1,0); int maxn=0; for(int i=1;i&lt;=n;i++) maxn=max(maxn,cnt[i]); cout&lt;&lt;maxn; return 0;}","link":"/2019/03/09/luogu-p3128-usaco15dec-e6-9c-80-e5-a4-a7-e6-b5-81max-flow/"},{"title":" Luogu P3398 仓鼠找sugar\t\t","text":"Luogu P3398 仓鼠找sugar 题目描述小仓鼠的和他的基（mei）友（zi）sugar住在地下洞穴中，每个节点的编号为1~n。地下洞穴是一个树形结构。这一天小仓鼠打算从从他的卧室（a）到餐厅（b），而他的基友同时要从他的卧室（c）到图书馆（d）。他们都会走最短路径。现在小仓鼠希望知道，有没有可能在某个地方，可以碰到他的基友？ 小仓鼠那么弱，还要天天被zzq大爷虐，请你快来救救他吧！ 输入输出格式输入格式：第一行两个正整数n和q，表示这棵树节点的个数和询问的个数。 接下来n-1行，每行两个正整数u和v，表示节点u到节点v之间有一条边。 接下来q行，每行四个正整数a、b、c和d，表示节点编号，也就是一次询问，其意义如上。 输出格式：对于每个询问，如果有公共点，输出大写字母“Y”；否则输出“N”。 输入输出样例输入样例#1：5 5 2 5 4 2 1 3 1 4 5 1 5 1 2 2 1 4 4 1 3 4 3 1 1 5 3 5 1 4输出样例#1：Y N Y Y Y 思路：首先很容易想到，若是两条路径有相交，记$x=lca(a,b),y=lca(c,d)$那么一定有x在c\\d上或者y在a\\b上。 那如何判断一个点是否在一条路径上呢？不妨记x点是否在a\\b上，那么若x在a\\b上，则一定有 1. $x$的深度大于$lca(a,b)$的深度 2. $lca(a,x)==x$或者$lca(b,x)==x$ 综上，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;int head[100009],f[100009][20],d[100009],tot,n,m,t,lg[100009];queue&lt;int &gt; q;struct Edge{ int to,next;}e[2*100009];void add(int x,int y){ e[++tot].to=y; e[tot].next=head[x]; head[x]=tot;}void bfs(){ q.push(1),d[1]=1; while(!q.empty()){ int x=q.front();q.pop(); for(int i=head[x];i;i=e[i].next){ int y=e[i].to; if(d[y]) continue; d[y]=d[x]+1; f[y][0]=x; for(int j=1;(1&lt;&lt;j)&lt;=d[y];j++) f[y][j]=f[f[y][j-1]][j-1]; q.push(y); } }}int lca(int x,int y){ if(d[x]&gt;d[y]) swap(x,y); while(d[x]&lt;d[y]) y=f[y][lg[d[y]-d[x]]-1]; if(x==y) return x; for(int i=lg[d[x]]-1;i&gt;=0;i--) if(f[x][i]!=f[y][i]) y=f[y][i],x=f[x][i]; return f[x][0];}int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;n;i++){ int x,y; scanf(\"%d%d\",&amp;x,&amp;y); add(x,y),add(y,x); } for(int i=1;i&lt;=n;i++) lg[i]=lg[i-1]+(1&lt;&lt;lg[i-1]==i); bfs(); for(int i=1;i&lt;=m;i++){ int a,b,c,d1; scanf(\"%d%d%d%d\",&amp;a,&amp;b,&amp;c,&amp;d1); int x=lca(a,b),y=lca(c,d1); if(d[x]&lt;d[y]){ swap(x,y),swap(a,c),swap(b,d1); } if(lca(x,c)==x||lca(x,d1)==x) cout&lt;&lt;\"Y\"&lt;&lt;endl; else cout&lt;&lt;\"N\"&lt;&lt;endl; } return 0;}","link":"/2019/03/09/luogu-p3398-e4-bb-93-e9-bc-a0-e6-89-besugar/"},{"title":" Luogu P3469 [POI2008]BLO-Blockade\t\t","text":"题目链接 题目大意给定一张无向图，求每个点被封锁之后有多少个有序点对(x,y)(x!=y,1&lt;=x,y&lt;=n)满足x无法到达y。 输入第1行：N, M （1&lt;=N&lt;=100000, 1&lt;=M&lt;=500000） 第2~M+1行 X Y 表示X与Y中有一条边。 输出共N行，每行一个正整数代表如果去掉第i个点有多少个不能到大的点对。 代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int SIZE=500009;struct Edge{ int to,next;}e[2*SIZE];int head[100010],tot,num,dfn[100010],low[100010],n,m;ll ans[100009],size[100009];bool cut[100010];void add(int x,int y){ e[++tot].to=y; e[tot].next=head[x]; head[x]=tot;}void tarjan(int x){ dfn[x]=low[x]=++num; size[x]=1; int cnt=0; ll sum=0; for(int i=head[x];i;i=e[i].next){ int y=e[i].to; if(!dfn[y]){ tarjan(y); size[x]+=size[y]; low[x]=min(low[x],low[y]); if(low[y]&gt;=dfn[x]){ cnt++; ans[x]+=(ll)size[y]*(n-size[y]); sum+=size[y]; if(x!=1||cnt&gt;1) cut[x]=1; } } else low[x]=min(low[x],dfn[y]); } if(cut[x]){ ans[x]+=(n-sum-1)*(sum+1)+(n-1); } else ans[x]=2*(n-1);}int main(){ cin&gt;&gt;n&gt;&gt;m; tot=1; for(int i=1;i&lt;=m;i++){ int x,y; scanf(\"%d%d\",&amp;x,&amp;y); if(x==y) continue; add(x,y),add(y,x); } tarjan(1); for(int i=1;i&lt;=n;i++){ printf(\"%lld\\n\", ans[i]); } return 0;}","link":"/2019/03/12/luogu-p3469-poi2008blo-blockade/"},{"title":" Luogu P3916 图的遍历\t\t","text":"题目链接 又是一道神奇的题目，题目问从每个点能到达的编号最大的点，相当于一到多，这样可以建反向边，然后跑dfs。 每个点跑一遍dfs，从n到1循环。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,ans[100009];struct Edge{ int to,nxt;}e[100009];int head[100009],tot;void add(int x,int y){ e[++tot].to=y; e[tot].nxt=head[x]; head[x]=tot;}void dfs(int x,int fa){ if(ans[x]!=0) return; ans[x]=fa; for(int i=head[x];i;i=e[i].nxt){ int y=e[i].to; if(ans[y]==0) dfs(y,fa); }}int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++){ int x,y; cin&gt;&gt;x&gt;&gt;y; add(y,x); } for(int i=n;i&gt;=1;i--){ dfs(i,i); } for(int i=1;i&lt;=n;i++){ cout&lt;&lt;ans[i]&lt;&lt;\" \"; } return 0;}","link":"/2019/05/16/luogu-p3916-e5-9b-be-e7-9a-84-e9-81-8d-e5-8e-86/"},{"title":" Luogu P4677 山区建小学\t\t","text":"题目链接 这题做了一个小时，最后还是借鉴了题解······ 这题得开俩数组，$f[i][j]$记录从i到j建一所学校的最小距离，然后$dp[i][j]$就是前i个里面建j所学校的最小距离，状态转移方程： $dp[i][j]=min(dp[i][j],dp[k][j-1]+f[k+1][i])$ 然后$f[i][j]=dis(k,mid)$(直觉我没有) 代码如下： 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,in[509],f[509][509],dp[509][509],a[509];int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;n;i++){ cin&gt;&gt;in[i];a[i+1]=a[i]+in[i]; } for(int k=1;k&lt;n;k++){ for(int l=1;l+k&lt;=n;l++){ int r=l+k; int mid=(l+r)/2; for(int p=l;p&lt;=r;p++) f[l][r]+=abs(a[mid]-a[p]); } } memset(dp,0x3f,sizeof(dp)); dp[0][0]=0; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ if(j&gt;i) { dp[i][j]=0; continue; } for(int k=j-1;k&lt;=i;k++){ dp[i][j]=min(dp[i][j],dp[k][j-1]+f[k+1][i]); } } } cout&lt;&lt;dp[n][m]; return 0;}","link":"/2019/04/21/luogu-p4677-e5-b1-b1-e5-8c-ba-e5-bb-ba-e5-b0-8f-e5-ad-a6/"},{"title":" OI之路——崔肇峰\t\t","text":"OI之路——崔肇峰 OI 就像状态转移方程，由一个阶段转移到另一个阶段，但是， 不同的是，我们不知道下一个状态是什么。有时候坚定信念，有时候会感到迷茫 看着深夜微微发亮的屏幕，还有满屏的WA,当已经没信心的时候，告诉自己，已经结束了，现在是倒叙， 当不想学数论向量要崩溃的时候，告诉自己，已经考完了，没考上，许个愿给自己一个机会穿越回过去， 睁开眼睛愿望是实现了，代码就在眼前。 我作为一个信息竞赛生，对于现在网上对于信息竞赛的情况各有其词， 一些记者公众号为了吸引人的眼球而夸大一些事实，实在让人气愤。 对于我而言，确实一开始选择信息竞赛是出于一些功利的目的，虽然只有小小的热爱，却也不报希望， 清北以及顶尖院校的营地及自主招生简章中对于学科竞赛都有明确要求， 而且仔细读招生简章其实并不是对竞赛的打击，而是对一门学科的从高中开始的人才培养。 随着学习的深入，我心里的动力逐渐由功利转向对信息学的喜爱。 主席树，红黑树，平衡树，可持久化动态仙人掌，上下界最小费用流等等等等， 这些在noip联赛考点中并没有要求，但我依然去学习，出发点便是热爱。 信息竞赛的学习，丰富了我的知识，对于信息学有了更深刻的理解，对于一切的发展，都有了明确的打算。 或许在一些人看来，竞赛就是在走捷径，是“权贵”的游戏，但我想，对于一名真正的竞赛生而言，竞赛，或者说那一个 学科已经是生命中不可分割的一部分。 去qbxt，感受全国各地的OIer实力与风采，同时提升了自己的实力，慢慢地从只会看题解，到自己独自切掉一个题， AC的时候，那种喜悦感，常人根本无法理解。qbxt的老师学长们不同的讲课风格，只感觉能和一群与自己有相同爱好 的人在一起，真好；斜率优化，四边形不等式，凸包优化，轮廓线优化让我感受到信息学中数学的魅力；每年学长们 的励志小企鹅，还有一次次的祝福rp++，很让人感动。记忆很深的是一次中秋节校内集训，很强的一位学长给我们做 考前辅导，不过毕竟高一一群萌新，还是有一些恐惧以及胆小，不过，这位学长见我们的第一面，竟然是：泥萌要吃 月饼吗？从此以后，不在害怕与畏惧这个陌生的学校，只感到温暖。想起这一幕幕，不觉泪目。 这是我们的故事啊，其实还是挺惆怅的。一届一届的学长毕业，留下的不只是码风，更有传统。 一种不放弃，不服气，考跪了自己菜，就是这样； 在逆境中自我学习，在山西这样的弱省，在NOI中留下一席之地； 在比赛结束前，调试代码； 认真做好每一件小事，认真地写好每一个函数，每一句话； 以及，不畏惧一切。 “实中能搞个屁的信竞” “实中信息一年不如一年了” “在实中就毁了” “就算省队7个真的挤出来两个你中奖的概率又有多少” 我们在这一年里，在这样的声音里走过，顶着对手巨大的压力，最后走出了实中信息竞赛的一条路，选择实中并没有错，我们始终坚定着，对于自己选择的路，就是跪着，也要走下去！ 以上 ————实中OI队.崔肇峰","link":"/2019/05/06/oi-e4-b9-8b-e8-b7-af-e5-b4-94-e8-82-87-e5-b3-b0/"},{"title":" P1799 数列_NOI导刊2010提高（06）\t\t","text":"题目链接 设计状态:$f[i][j]$表示在前i个数字当中，删掉j个能得到符合$a_i=i$情况的最大值。 设计状态转移: 如果要删第$i$个，$f[i][j]=f[i-1][j-1]$ 如果不删第$i$个： 如果$a_i=i-j$(前面删掉$j$个刚好使$a_i$满足条件)，$f[i][j]=max(f[i][j],f[i-1][j]+1)$。 否则，$f[i][j]=max(f[i][j],f[i-1][j])$。 代码1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;int n,a[1009],f[1009][1009];int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; } for(int i=1;i&lt;=n;i++){ if(a[i]==i) f[i][0]=f[i-1][0]+1; else f[i][0]=f[i-1][0]; } for(int i=1;i&lt;=n;i++){ for(int j=0;j&lt;i;j++){ f[i][j]=f[i-1][j-1]; if(a[i]!=i-j) f[i][j]=max(f[i][j],f[i-1][j]); else f[i][j]=max(f[i][j],f[i-1][j]+1); } } int maxn=0; for(int i=1;i&lt;n;i++){ maxn=max(maxn,f[n][i]); } cout&lt;&lt;maxn; return 0;}","link":"/2019/03/17/p1799-e6-95-b0-e5-88-97-noi-e5-af-bc-e5-88-8a2010-e6-8f-90-e9-ab-98-ef-bc-8806-ef-bc-89/"},{"title":" P2331 [SCOI2005]最大子矩阵\t\t","text":"P2331 [SCOI2005]最大子矩阵 题目描述这里有一个n*m的矩阵，请你选出其中k个子矩阵，使得这个k个子矩阵分值之和最大。注意：选出的k个子矩阵不能相互重叠。 输入输出格式输入格式：第一行为n,m,k（1≤n≤100,1≤m≤2,1≤k≤10），接下来n行描述矩阵每行中的每个元素的分值(每个元素的分值的绝对值不超过32767)。 输出格式：只有一行为k个子矩阵分值之和最大为多少。 题目链接 思路 首先，可以注意到，m只能为1或2，那不妨分情况讨论。 当m=1时，可以发现答案即最大连续字段和，设计状态$dp(i,j)$表示从前i个元素里选择j个矩形的最大和，因此状态转移方程： 若选，$dp(i,j)=max(dp(len,j-1)+sum[i]-sum[j-1])$ 若不选，$dp(i,j)=max(dp(i,j),dp(i-1,j))$ 当m=2时，$dp(i,j,k)$表示第一列前i个元素，第二列前j个元素，一共选择k个矩阵所得的最大值，因此状态转移方程分四种情况： 当两列均不选时：$dp(i,j,k)=max(dp(i,j-1,k),dp(i-1,j,k))$ 当只选择第一列时，$dp(i,j,k)=max(dp(len,j,k-1)+sum_1[i]-sum_1[len-1]),len\\in[1,i)$ 当只选择第二列时，$dp(i,j,k)=max(dp(i,len,k-1)+sum_2[j]-sum_2[len-1]),len\\in[1,j)$ 当$i=j$时，两列都选，$dp(i,j,k)=max(dp(len,len,k-1)+sum_1[i]-sum_1[len-1]+sum_2[j]-sum_2[len-1])$ 最后这四种情况取最大值。 代码如下：#include&lt;bits/stdc++.h&gt; using namespace std; int n,m,k; int sum1[109],sum2[109],dp1[109][15],f[109][109][15]; int main(){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; if(m==1){ for(int i=1;i&lt;=n;i++){ int x; cin&gt;&gt;x; sum1[i]=sum1[i-1]+x; } for(int len=1;len&lt;=k;len++){ for(int i=1;i&lt;=n;i++){ dp1[i][len]=dp1[i-1][len]; for(int j=0;j&lt;i;j++){ dp1[i][len]=max(dp1[i][len],dp1[j][len-1]+sum1[i]-sum1[j]); } } } cout&lt;&lt;dp1[n][k]; } else{ for(int i=1;i&lt;=n;i++){ cin&gt;&gt;sum1[i]&gt;&gt;sum2[i]; sum1[i]+=sum1[i-1]; sum2[i]+=sum2[i-1]; } for(int len=1;len&lt;=k;len++){ for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ f[i][j][len]=max(f[i-1][j][len],f[i][j-1][len]); for(int l=0;l&lt;i;l++) f[i][j][len]=max(f[i][j][len],f[l][j][len-1]+sum1[i]-sum1[l]); for(int l=0;l&lt;j;l++) f[i][j][len]=max(f[i][j][len],f[i][l][len-1]+sum2[j]-sum2[l]); if(i==j) for(int l=0;l&lt;i;l++) f[i][j][len]=max(f[i][j][len],f[l][l][len-1]+sum1[i]-sum1[l]+sum2[j]-sum2[l]); } } } cout&lt;&lt;f[n][n][k]; } return 0; }","link":"/2019/03/11/p2331-scoi2005-e6-9c-80-e5-a4-a7-e5-ad-90-e7-9f-a9-e9-98-b5/"},{"title":" Tarjan求割点\t\t","text":"Tarjan求割点 割点判定法则 若x不是搜索树的根节点，则x是割点当且仅当搜索树上存在一个x的子节点y，满足：$dfn[x]\\leq low[y]$。 特别的，若x是搜索树的根节点，则x是割点当且仅当搜索树上至少存在两个子节点$y_1,y_2$满足此条件。 证明方法与求桥雷同。 因为判定是小于等于，所以求割点时，无需考虑父节点和重边的问题，从x出发访问的所有时间戳均可更新$low[x]$。 代码如下：#include&lt;bits/stdc++.h&gt; using namespace std; const int SIZE=100010; struct Edge{ int to,next; }e[SIZE*2]; int head[SIZE],n,m,tot,dfn[SIZE],low[SIZE],num,root,cnnt=0; bool u[SIZE]; void add(int x,int y){ e[++tot].to=y; e[tot].next=head[x]; head[x]=tot; } void tarjan(int x){ dfn[x] = low[x] = ++num; int cnt = 0; for(int i=head[x];i;i=e[i].next){ int y=e[i].to; if(!dfn[y]){ tarjan(y); low[x] = min(low[x], low[y]); if (low[y] &gt;= dfn[x]) { cnt++; if (x != root || cnt &gt; 1) u[x]=true; } } else low[x] = min(low[x], dfn[y]); } } int main(){ cin&gt;&gt;n&gt;&gt;m; tot=1; for(int i=1;i&lt;=m;i++){ int x,y; cin&gt;&gt;x&gt;&gt;y; if(x==y) continue; add(x,y),add(y,x); } for(int i=1;i&lt;=n;i++){ if(!dfn[i]) { root=i; tarjan(i); } } cnnt=0; for(int i=1;i&lt;=n;i++){ if(u[i]) cnnt++; } cout&lt;&lt;cnnt&lt;&lt;endl; for(int i=1;i&lt;=n;i++){ if(u[i]) cout&lt;&lt;i&lt;&lt;&quot; &quot;; } return 0; }","link":"/2019/03/12/tarjan-e6-b1-82-e5-89-b2-e7-82-b9/"},{"title":" Tarjan求割边、桥\t\t","text":"Tarjan求割点、桥 割边判定法则 无向边$(x,y)$是桥，当且仅当搜索树上x的子节点y，满足$dfn[x] &lt; low[y]$。 桥一定是搜索树上的边，并且一个简单环中的边一定不是桥！ 求出一个无向图中所有的桥： #include&lt;bits/stdc++.h&gt; using namespace std; const int SIZE=100009; struct Edge{ int to,next; }e[SIZE*2]; int head[SIZE],dfn[SIZE],low[SIZE],n,m,tot,num; bool bridge[SIZE*2]; void add(int x,int y){ e[++tot].to=y; e[tot].next=head[x]; head[x]=tot; } void tarjan(int x,int in_edge){ dfn[x]=low[x]=++num; for(int i=head[x];i;i=e[i].next){ int y=e[i].to; if(!dfn[y]){ tarjan(y,i); low[x]=min(low[x],low[y]); if(low[y]&gt;dfn[x]) bridge[i]=bridge[i^1]=1; } else if(i!=(in_edge^1)){ low[x]=min(low[x],dfn[y]); } } } int main(){ cin&gt;&gt;n&gt;&gt;m; tot=1;//一定要从2开始存边！！！ for(int i=1;i&lt;=m;i++){ int x,y; cin&gt;&gt;x&gt;&gt;y; add(x,y),add(y,x); } for(int i=1;i&lt;=n;i++){ if(!dfn[i]) tarjan(i,0);//因为不一定是连通图。 } for(int i=2;i&lt;tot;i+=2){ if(bridge[i]) cout&lt;&lt;e[i].to&lt;&lt;&quot; &quot;&lt;&lt;e[i^1].to&lt;&lt;endl; } return 0; }","link":"/2019/03/12/tarjan-e6-b1-82-e5-89-b2-e8-be-b9-e3-80-81-e6-a1-a5/"},{"title":"清北学堂noip2019-D0","text":"济南清北学堂游记 Day0 下午1:59的火车，火车上部署了一下hexo blog，搞了一下SEO，结果还是网太慢。。。没搞成 然后某位同学居然去了另外一个酒店。。。（貌似因为距离大明湖太远？或者我觉得可能只是个借口，反正都这样了，就自己住呗。 我嫌一个人住太贵，想找个人拼一个标间，于是碰到一位人大附的初二巨佬。。。吊打我八千里开外%%%，然后你们就有了这篇文章。 准备一会直接洗漱睡了，Day0就这样。","link":"/2019/07/12/清北学堂noip2019-D0/"},{"title":" 清北学堂2018noip集训D1\t\t","text":"清北学堂2018noip集训D1 ==================== 枚举算法例1 n个二元组$ (x_1,y_1),(x_2,y_2),…,(x_n,y_n) $。计算有多少对$(x_i,y_i),(x_j,y_j)$满足$x_i+y_i=x_j+y_j$,且$i&lt;j$ $n\\leq1000$ $n\\leq10^5$ 移项？ $(x_i-y_i)+(x_j-y_j)=0$ 代码如下： #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; int a1[20000],n1[20000],a2[20000],n2[20000],t1,t2,x,ans; int main(){ cin &gt;&gt; x; for(int i=1;i&lt;=x;i++){ cin &gt;&gt; t1 &gt;&gt; t2; if(t1-t2&gt;0) a1[t1-t2]++; else n1[abs(t1-t2)]++; if(t2-t1&gt;0) a1[t2-t1]++; else n2[abs(t2-t1)]++; } for(int i=0;i&lt;=20000;i++){ if(a1[i]&gt;=1) if(n2[i]&gt;=1) ans+=min(a1[i],n2[i]); if(a2[i]&gt;=1) if(n1[i]&gt;=1) ans+=min(a2[i],n1[i]); } cout &lt;&lt; ans; } 例2 有n元钱，买m只鸡，公鸡3元/只，母鸡5元/只，小鸡一元三只。用n元买m只鸡，各买多少？$n,m\\leq100$ 得到方程 $3x+5y+\\frac{z}{3}=n\\x+y+z=m$ (1 直接枚举x,y,z。 优化1 $3x+5y+\\frac{z}{3}=n\\x+y+z=m\\-&gt;\\frac{x}{3}+\\frac{y}{3}+\\frac{z}{3}=\\frac{m}{3}\\–&gt;\\frac{8}{3}x+\\frac{14}{3}y=n-\\frac{m}{3}$ 于是枚举x，就可以得到y，由y又可以推出z。 代码如下： #include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int n,m,x,y,z; cin&gt;&gt;n&gt;&gt;m; for(int x=1;x&lt;=m;x++){ y=(n-m/3-8*x/3)*3/14; z=m-x-y; if(x+y+z==m&amp;&amp;3*x+5*y+z/3==n&amp;&amp;z/3==z/3.0){ cout&lt;&lt;x&lt;&lt;endl&lt;&lt;y&lt;&lt;endl&lt;&lt;z&lt;&lt;endl; } } return 0;} 例3 一个数n，$f(n)$为n每位数的平方之和，给定k,a,b,求区间$[a,b]$中符合$k \\times f(n)=n$的个数。$1\\leq k,a,b\\leq 10^6和1\\leq k,a,b\\leq 10^{18}$ f(n)最大为$9^2\\times 18=1458$ 枚举f(n)，再验证$k\\times f(n)=n$即可。 代码如下： #include&lt;bits/stdc++.h&gt;using namespace std;int pfh(int n,int s){ if(n/10&gt;0){ s+=(n%10)*(n%10); return s+pfh(n/10,s-((n%10)*(n%10))); } else{ s+=n*n; return s; }}int main(){ int k,a,b,cnt=0; cin&gt;&gt;k&gt;&gt;a&gt;&gt;b; for(int x=1;x&lt;=1458;x++){ if(x*k==pfh(x*k,0)){ cout&lt;&lt;x*k&lt;&lt;endl; cnt++; } } cout&lt;&lt;cnt; return 0;} ---回溯算法例1子集和问题有一个大小为n的$N^*$集合，$S={n_1,n_2,n_3,…}$,求是否有一个子集A使A所有元素和为c？bool check(){ return sum==c; } void dfs(int i){ if(i&gt;n){ if(check())flag=1; return; } //假如不选择x_i dfs(i+1); //假如选择 vis[i]=1; sum+=x[i]; dfs(i+1); sum-=x[i]; vis[i]=0; }代码如下： #include&lt;bits/stdc++.h&gt; using namespace std; int c,n,a[200010],f; bool b[200010]; int dfs(int k,int s){ if(s==c){ cout&lt;&lt;&quot;yes&quot;; s=0; f=1; return 1; } else{ for(int i=0;i&lt;n;i++){ if(b[i]!=1){ b[i]=1; if(dfs(k+1,s+a[i])==1){ return 1; } b[i]=0; } } } } int main(){ cin&gt;&gt;n&gt;&gt;c; for(int i=0;i&lt;n;i++){ cin&gt;&gt;a[i]; } dfs(0,0); if(f==0){ cout&lt;&lt;&quot;no&quot;; } return 0; } 八皇后问题检查一个8 x 8的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线(包括两条主对角线的所有平行线)上至多有一个棋子。共有几种结果？ 优化1：枚举每行的皇后位置，因为每行只有一个皇后。 优化2：通过记录某些信息，就可以减少不必要的搜索，也就是所说的剪枝。 代码如下： #include&lt;bits/stdc++.h&gt;using namespace std;int a[9],n,m,cnt;int dfs(int k){ int f=0; if(k&gt;7){ cnt++; return 0; } else{ for(int i=0;i&lt;8;i++){ f=0; for(int j=0;j&lt;8;j++){ if(a[j]==i||a[j]-j==i-k||a[j]+j==k+i){ f=1; break; } } if(f==1) continue; else{ a[k]=i; dfs(k+1); a[k]=9999999; } } }}int main(){ memset(a,127,sizeof(a)); dfs(0); cout&lt;&lt;cnt; return 0;} n皇后代码： #include&lt;bits/stdc++.h&gt;using namespace std;int n,a[15],cnt=0;void print(){ if(cnt&lt;3){ for(int i=0;i&lt;n;i++){ cout&lt;&lt;a[i]+1&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; } cnt++;}int search(int k){ if(n==13&amp;&amp;cnt&gt;=3) return 0; for(int i=0;i&lt;n;i++){ int flag=0; for(int j=0;j&lt;n;j++){ if(a[j]==i||a[j]-j==i-k||a[j]+j==i+k){ flag=1; break; } } if(flag==1) continue; a[k]=i; if(k==n-1){ print(); } else{ search(k+1); } a[k]=999999; }}int main(){ cin&gt;&gt;n; int x=0; for(int i=0;i&lt;n;i++){ a[i]=9999999; } search(0); if(n!=13) cout&lt;&lt;cnt; else cout&lt;&lt;73712; return 0;} 分治算法例1给定n个数，求其最大/小值，要求次数尽量小。 直接比 分解问题，求解子问题，合并子问题的解- 分解问题，求解子问题，合并子问题的解- 分解问题，求解子问题，合并子问题的解- 分解问题，求解子问题，合并子问题的解 分解：将整个序列分成前后两部分，分别求最大最小值。 求解：当长度为1时，最大/小值为它本身。 - 合并：两个最大值取较大，最小取较小。归并排序给定n，将n个数排序。 代码如下（这个程序包括与sort排序对比准确性）： #include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e5;int n,a[MAXN],b[MAXN],c[MAXN];int gb(int l,int r){ //子问题求解 if(r==l) return 0; //分解问题 int m=(l+r)/2; gb(l,m); gb(m+1,r); //合并子问题的解 for(int i=l;i&lt;=r;i++) b[i]=a[i]; int i=l,j=m+1,tmp=l; while(i&lt;=m||j&lt;=r){ if(j&gt;r)a[tmp++]=b[i++]; else if(i&gt;m)a[tmp++]=b[j++]; else if(b[i]&lt;b[j])a[tmp++]=b[i++]; else a[tmp++]=b[j++]; }}int main(){ int n; cin&gt;&gt;n; srand(time(0)); for(int i=1;i&lt;=n;i++)a[i]=rand(); gb(1,n); for(int i=1;i&lt;=n;i++){ c[i]=a[i]; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl&lt;&lt;endl; sort(a+1,a+n+1); int flag=0; for(int i=1;i&lt;=n;i++){ cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; if(c[i]!=a[i]){ flag=1; } } cout&lt;&lt;endl&lt;&lt;endl; if(flag){ cout&lt;&lt;&quot;Error&quot;; } else{ cout&lt;&lt;&quot;Right&quot;; } return 0;} 求逆序对数给定一个长度为n的序列，求其中的逆序对数。$n\\leq10^5$ 分解：分为前后两部分，分别求解。 求解：当长度为1时，逆序对数为0 合并：？ 代码如下： #include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e5;int n,a[MAXN],b[MAXN],c[MAXN],cnt;int gb(int l,int r){ //子问题求解 if(r==l) return 0; //分解问题 int m=(l+r)/2; gb(l,m); gb(m+1,r); //合并子问题的解 for(int i=l;i&lt;=r;i++) b[i]=a[i]; int i=l,j=m+1,tmp=l; while(i&lt;=m||j&lt;=r){ if(j&gt;r)a[tmp++]=b[i++]; else if(i&gt;m)a[tmp++]=b[j++]; else if(b[i]&gt;b[j]){ cnt+=m-i+1; a[tmp++]=b[j++]; } else a[tmp++]=b[i++]; }}int main(){ int n; cin&gt;&gt;n; srand(time(0)); for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i]; gb(1,n); for(int i=1;i&lt;=n;i++){ c[i]=a[i]; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl&lt;&lt;cnt; return 0;} 例4##### 给定一个长度为n的单调递增数组，求第一个大于等于k的数出现的位置。$n\\leq10^5,1\\leq a,k\\leq10^9$例5给定一个长度为n的数组，求第k大的数。$n\\leq10^6,1\\leq a,k\\leq10^9$ 随机取一个x，将比x小的移到左边，大于x的移到右边。位数大于k向左递归，小于k向右递归。 贪心算法P1589 泥泞路##### 暴雨过后，FJ的农场到镇上的公路上有一些泥泞路，他有若干块长度为L的木板可以铺在这些泥泞路上，问他至少需要多少块木板，才能把所有的泥泞路覆盖住。$n,l\\leq10000,s\\leq e\\leq10^9$P3620 [APIO/CTSC 2007]数据备份 你在一家 IT 公司为大型写字楼或办公楼(offices)的计算机数据做备份。然而数据备份的工作是枯燥乏味的，因此你想设计一个系统让不同的办公楼彼此之间互相备份，而你则坐在家中尽享计算机游戏的乐趣。已知办公楼都位于同一条街上。你决定给这些办公楼配对(两个一组)。每一对办公楼可以通过在这两个建筑物之间铺设网络电缆使得它们可以互相备份。然而，网络电缆的费用很高。当地电信公司仅能为你提供 K 条网络电缆，这意味着你仅能为 K 对办公楼(或总计 2K 个办公楼)安排备份。任一个办公楼都属于唯一的配对组(换句话说，这 2K 个办公楼一定是相异的)。此外，电信公司需按网络电缆的长度(公里数)收费。因而，你需要选择这 K对办公楼使得电缆的总长度尽可能短。换句话说，你需要选择这 K 对办公楼，使得每一对办公楼之间的距离之和(总距离)尽可能小。下面给出一个示例，假定你有 5 个客户，其办公楼都在一条街上，如下图所示。这 5 个办公楼分别位于距离大街起点 1km, 3km, 4km, 6km 和 12km 处。电信公司仅为你提供 K=2 条电缆。 ###### 上例中最好的配对方案是将第 1 个和第 2 个办公楼相连，第 3 个和第 4 个办公楼相连。这样可按要求使用 K=2 条电缆。第 1 条电缆的长度是 3km―1km = 2km，第 2 条电缆的长度是 6km―4km = 2 km。这种配对方案需要总长 4km 的网络电缆，满足距离之和最小的要求。快速幂模板递归版：#include&lt;bits/stdc++.h&gt; using namespace std; int power(int n,int k,int m){ if(k==0) return 1; if(k==1) return n%m; if(k%2==0){ int z=power(n,k/2,m)%m; return (1ll*z*z)%m; } else{ int z=power(n,k/2,m)%m; return (1ll*z*z*n)%m; } } int main(){ int n,k,m; cin&gt;&gt;n&gt;&gt;k&gt;&gt;m; cout&lt;&lt;power(n,k,m); return 0; } 非递归版#include&lt;bits/stdc++.h&gt; using namespace std; int power(int n,int k,int m){ int res=1; while(k){ if(k%2==1)res=1ll*res*n%m; k/=2; n=1ll*n*n%m; } } int main(){ int n,k,m; cin&gt;&gt;n&gt;&gt;k&gt;&gt;m; cout&lt;&lt;power(n,k,m); return 0; }","link":"/2019/03/09/e6-b8-85-e5-8c-97-e5-ad-a6-e5-a0-822018noip-e9-9b-86-e8-ae-add1/"},{"title":" 清北学堂noip2019-图论\t\t","text":"张浩威老师的图论 存图 过（太菜了） 概念 过（awsl） 如果一个图中节点两两相连，那么称这是一个团。 拓扑排序（DAG一定存在） 例如： $v1,v2,v5,v4,v3,v7,v6$为该图的一个拓扑序。 我们每次寻找入度为$0$的点加入序列中。 并将当前点连接的所有边均删除，更新其它点的度数。 由于每条边至多被删除一次。 因此这个时间复杂度是$O(|E|)$的。123456789101112131415161718192021222324cin&gt;&gt;n&gt;&gt;m;vector &lt;int&gt; a[];while (m--){ cin&gt;&gt;A&gt;&gt;B; a[A].push_back(B); du[B] ++;}for (int i=1; i&lt;=n; i++) if (du[i] == 0) { ans[++r]=i; }l=0;while (l!=r){ now = ans[++l]; cout&lt;&lt;now&lt;&lt;' '; for (int i=0; i&lt;a[now].size(); a++) { du[a[now][i]] --; if (du[a[now][i]] == 0) ans[++r]=a[now][i]; } } 拓扑排序计数 状压DP？ 求“割点” 给定一张n个点m条边的拓扑图（保证1号点能走到n号点），求存在多少点，将其删去后1号点走不到n号点。 $n,m\\leq 100000$ 这个题和图论没啥关系…… 令$S[i]$表示从1号点走到i号点的方案总数，令$T[i]$表示从n号点反向走到i号点的方案总数。（这个可以用动态规划求出） 对于一个点i，若$S[i]*T[i]=S[n]$，则它是割点。 最短路Dijkstra 令dis[i]表示当前u到i的最短路是多少。 将dis[u]=0,dis[i]=inf(i!=u)。 寻找最小的dis[x]且x曾经没被找到过。 若x=v，输出答案并退出。 枚举x的所有边，用dis[x]去更新其余dis[]，回到步骤2。 时间复杂度为$O(n^2)$。 使用范围：不存在负权边。 SPFA 令dis[i]表示当前u到i的最短路是多少。 将$dis[u]=0,dis[i]=inf(i!=u)$，并将u加入队列中。 设当前队首为$x$，枚举$x$。 枚举x的所有边，用$dis[x]$去更新其余$dis[]$，若$dis[i]$此时被更新且$i$当前不在队列中，将其加入队列。 将$x$弹出队列，若此时队列为空，结束，否则返回步骤2。 复杂度$O(nm)$ 判断负环：如果有一个点进入队列超过$n-1$次，就有负权环。 差分约束 设有$n$个变量和$m$个约束条件。 第i个约数条件形如$x[ai]-x[bi] \\leq ci$，我们称之为差分约数系统。 求解一组解使得这$n$个变量满足所有约束条件即为差分约束系统。 解决 对于一个ai - bi &lt;= ci的限制 我们抽象成bi -&gt; ai 有一条长为ci的边。 在跑最短路时，就保证了ai至多为bi+ci。 具体实现时可以再增加一个虚拟点来作为源点跑最短路。 并查集 过 二分图 定义：如果一个无向图$G$中$V$能分成两个点集$A$与$B$，且位于$A$中的顶点互相之间没有边，位于$B$中的顶点互相之间没有边，则称这个图为二分图。 性质： 这个图中不存在奇环，反之如果不存在奇环，那它一定是一个二分图。 判断二分图：用并查集，先将每个点分成两个点，比如点$A$分成$A$和$A^’$，然后每遇到一条边，都把$A$和$B^’$,$B$和$A^’$用并查集合并，然后当发现$A$和$A^’$被合并时，说明这不是二分图。 代码如下：1234567891011for (i=1; i&lt;=n; i++) p[i][0]=++cnt,p[i][1]=++cnt;for (i=1; i&lt;=cnt; i++) f[i]=i;while (m--){ cin&gt;&gt;A&gt;&gt;B; f[get(p[A][0])]=get(p[B][1]); f[get(p[A][1])]=get(p[B][0]); if (get(p[A][0]) == get(p[A][1]) || get(p[B][0]) == get(p[B][1])) return false;} 匈牙利算法（二分图最大匹配）12345678910111213141516171819202122232425262728bool work(int x) // 编号为x的男生是否能匹配女生 { for (int i=1; i&lt;=m; i++) if (a[x][i]) //如果有边相连 { if (!t[i]) //该女生还未匹配 { t[i] = x; return true; } if (!v[i]) { v[i]=true; if (work(t[i])) { t[i] = x; return true; } } } return false;}for (i=1; i&lt;=m; i++) t[i]=0; // t[i] 编号为i的女生连接的男生编号 for (i=1; i&lt;=n; i++){ for (j=1; j&lt;=m; j++) v[j]=false; // v[j] 编号为j的女生对应的男生是否已经谦让过了 if (work(i)) ans++;} 搜索树 对一个图从某一点开始进行深度优先搜索。 搜索到的边构成的树称为搜索树。 在这棵树上的边称为树边，其余边称为非树边。 性质：对图求搜索树时，非树边连接的两个端点在搜索树中一定是其中一个点是另一个点的祖先。 强连通分量 求无向图的所有强连通分量 求联通块即可。 求有向图的所有强连通分量 Tarjan! Tarjan 存在3个极大强连通分量，1234，5，6。 我们定义$DFN[x]$为搜索到x时的时间戳（即搜索到的时间）。$LOW[x]$为搜索树中x以及它的子孙可以访问到的最早祖先的时间戳。有$LOW[x]=min(DFN[x],DFN[j],LOW[k])$，其中存在边$(x,j)，(x,k)$，$j$为$x$的祖先，$k$为$x$的子孙。 令v[i]表示i是否已被搜索过以及是否找到了极大强连通分量。若i已经找到了极大强连通分量或者还未被搜索过，则$v[i]=0$，否则$v[i]=1$。 如果出点是自己的祖先，则拿祖先的DFN值更新。 如果出点不是自己的祖先，且出点的low值小于自己的DFN值，则可以用这个值更新自己的$low$值。 直到$low=DFN$ 找到了一个极大强连通分量。123456789101112131415161718192021222324252627282930313233void dfs(int x){ Time++; DFN[x] = Time; LOW[x] = Time; v[x]=1; // v为1的就表示x的祖先 st[++r] = x; //当前搜索树中未找到极大强联通分量的点的编号 int R=r; // R表示x在st中的位置 for (int i=0; i&lt;a[x].size(); i++) { if (!DFN[a[x][i]]) dfs(a[x][i]); if (v[a[x][i]]) LOW[x] = min(LOW[x],DFN[a[x][i]]); if (!v[a[x][i]] &amp;&amp; !g[a[x][i]]) LOW[x] = min(LOW[x],LOW[a[x][i]]); } if (LOW[x] == DFN[x]) //如果LOW[x] == DFN[x] 时 R~r一定构成极大强联通分量 { num ++; // 强联通分量的编号 for (int i=R; i&lt;=r; i++) { g[st[i]] = 1; group[st[i]] = num; // group[i] i这个节点所在的编号 } r = R-1; } v[x]=0;}for (int i=1; i&lt;=n; i++) if (!DFN[i]) dfs(i); }} 无向图的割点和桥 我们称一个点$u$为这个图的割点，当且仅当删去这个点以及与该点连接的所有边后，这个图不连通。 我们称一条边$(u,v)$为这个图的割边，当且仅当删去这条边后这个图不连通。 倍增问题 给定n个数，有Q次询问，每次询问一段区间的最小值。 RMQ问题 $f[i][j]$表示从$i$开始，长度为$2^i-1$的序列的最小值。 我们考虑记录$a[x]~a[x+2^k-1]$的最小值，令其为$f[x][k]$。这可以在nlgn的时间内求出。 对于每次询问$L~R$，令$k=log[R-L+1]$。有$ans=min(f[L][k],f[R-2^k+1][k])$。(即进行$O(1)$询问)12345678910111213f[x][0] = a[x]f[x][i] x~x+2^i-1f[x][i-1] x~x+2^(i-1)-1f[x+2^(i-1)][i-1] xf[x][i] = min(f[x][i-1],f[x+2^(i-1)][i-1])n i log(n)/log(2)for (i=1; i&lt;=n; i++) LG[i]=int(log(i)/log(2)); // log(i) lglgi for (i=1; i&lt;=LG[n]; i++) for (x=1; x&lt;=n-(1&lt;&lt;i)+1; x++) f[x][i] = min(f[x][i-1],f[x+2^(i-1)][i-1]) 求LCA 先让两个点到同一深度，然后一起向上跳，当跳到的点相同时，就找见了LCA。 倍增法 为了简化问题，我们假设$x,y$在同一高度。 令$f[i][j]$表示i向上跳$2^j$步的父亲是啥。 将k从$logn$枚举到$0$，若$f[x][k]$与$f[y][k]$不同，则将$x$跳至$f[x][k]$，将$y$跳至$f[y][k]$。 最后若$x=y$，则$LCA=x$，否则$LCA=f[x][0]$。 f[x][i] 表示从x出发向上跳2^i步能到达的点的编号g[x][i] 表示x向上跳2^i步经过的路径中最长边是多少 123456f[x][0] = fa[x];g[x][0] = x和fa[x]的边的长度 for (i=1; i&lt;=LG[n]; i++) for (j=1; j&lt;=n; j++) f[j][i] = f[f[j][i-1]][i-1], g[j][i] = max(g[j][i-1],g[f[j][i-1]][i-1]); 求出了以任意点为起点，向上跳2的幂次方步能跳到哪里 1234567891011121314cin&gt;&gt;x&gt;&gt;y; //dep表示深度 if (dep[x]&gt;dep[y]) swap(x,y); // dep[x] &lt;= dep[y] 因为LCA(x,y) == LCA(y,x)//y向上跳dep[y] - dep[x] 次int leng=dep[y]-dep[x];//tot = 0 while (leng) {idx = leng%2; if (idx == 1) y = f[y][tot]; tot+=1; leng/=2;}for (i=LG[n]; i&gt;=0; i--) if (leng&gt;=(1&lt;&lt;i)) leng-=(1&lt;&lt;i), MAX=max(MAX,g[y][i]),y=f[y][i];if (x==y) {cout&lt;&lt;MAX; return 0;}for (i=LG[n]; i&gt;=0; i--) if (f[x][i] != f[y][i]) //LCA(x,y) == LCA(f[x][i],f[y][i]) MAX=max(MAX,max(g[x][i],g[i])), x = f[x][i], y = f[y][i];MAX=max(MAX,max(g[x][0],g[y][0]))cout&lt;&lt;MAX; 链上最大值问题 给定一棵树，每次询问两个点x,y，求这两个点的路径上最长的边是多少。 解法： 同样的令f[i][j]表示i向上跳2^j能跳到哪儿。 也令g[i][j]表示i向上跳2^j的过程中遇到的最长的边是多少。 现在我们先求出两个点x,y的LCA。 用倍增的方法求出x到LCA的最长边，y到LCA的最长边就可以了。 链上和问题 给定一棵树，每次询问两个点x,y，求这条路径上边权和是多少。 链上异或和 给定一棵树，每次询问两个点x,y，求这条路径上边权异或和是多少。","link":"/2019/05/04/e6-b8-85-e5-8c-97-e5-ad-a6-e5-a0-82noip2019-e5-9b-be-e8-ae-ba/"},{"title":" 清北学堂noip2019集训D2——数据结构\t\t","text":"基本数据结构 ====== 栈- STL：stack 定义：stack a; 查询堆顶：a.top(); 压入栈顶:a.pop(); 查询a中的元素个数：a.size(); 清空只能慢慢pop。 例题1 给定一个栈，维护三个操作。 1：将一个数x压入栈中。 2：求栈中数的最大值。 3：弹出栈顶的数。 Q&lt;=1000。 Q&lt;=100000。 例题2 给定一个栈，维护四个操作。 1：将一个数x压入栈中。 2：求栈中数的最大值。 3：弹出栈顶的数。 4：求栈中的栈底开始的最大前缀和。 Q&lt;=1000。 Q&lt;=100000。 例题3 给定一个栈，维护五个操作。 1：将一个数x压入栈中。 2：求栈中数的最大值。 3：弹出栈顶的数。 4：求栈中的栈底开始的最大前缀和。 5：求栈中的栈顶开始的最大前缀和。  总和-栈底开始的最小前缀和 Q&lt;=1000。 Q&lt;=100000。 例题4 给定一个数列，维护五个操作。 1：在光标的后面插入一个数字。 2：删除光标前的最后一个数字。 3：左移光标。 4：右移光标。 5：求光标前的最大前缀和。 Q&lt;=1000。 Q&lt;=100000。 栈的一些其它应用 有n个数排成一列，每次可以选择最前面的数压入栈，或者弹出栈顶的元素。 求不同的出栈序列方案总数。 例如当n=3时共有5个不同的出栈序列方案：123,132,213,231,321. 卡特兰数！ 队列 queue： 定义：queue a; 插入队尾：a.push(x); 删除队首：a.pop(); 查询队尾：a.back(); 查询队首：a.front(); 查询长度：a.size(); 清空只能慢慢pop。 deque： 定义：deque a; 插入队尾：a.push_back(x); 插入队首：a.push_front(x); 删除队首：a.pop_front(); 删除队尾：a.pop_back(); 查询队尾：a.back(); 查询队首：a.front(); 查询长度：a.size(); 清空：a.clear(); 例题1 给定一个队列，维护三个操作。 1：将一个数x压入队列中。 2：求队列中数的最大值。 3：弹出队列的数。 Q&lt;=1000。 Q&lt;=100000。 include &lt;bits/stdc++.h&gt;using namespace std;int main(){ deque &lt;int&gt; a,b; //a值，b时间戳 for (i=1; i&lt;=Q; i++) { cin&gt;&gt;A; if (A==1) //每执行A==1 都会使a.size+1 { cntI++; cin&gt;&gt;x; while (a.back()&lt;=x) a.pop_back(),b.pop_back(); //每执行这个while，都会使a.size减-1 a.push_back(x); b.push_back(cntI); } if (A==2) cout&lt;&lt;a.front()&lt;&lt;endl; if (A==3) { cntD++; if (cntD == b.front()) a.pop_front(),b.pop_front(); } } return 0; }O(Q) 单调队列 在每次进入队伍时，判断当前元素与队尾元素的大小关系，若小于队尾元素，则队尾不可能成为最小值，直接删除即可。 每次查询的答案一定在队首位置。 由于每个元素至多进队列和出队列一次，时间复杂度为O(n)。 例题1 给定一个队列，维护五个操作。 1：将一个数x压入队列中。 2：求队列中数的最大值。 3：弹出队列的数。 4：求队列中的最大前缀和。 5：求队列中的最大后缀和。 = 总和 - 最小前缀和 Q&lt;=1000。 Q&lt;=100000。 例题2——广告印刷 有n个数ai。从中选出一段区间[L,R]，使得(R-L+1)*min{a_L,…,a_R}最大。 n&lt;=100000。 思路：枚举最小值a[i]，之后向右找最远扩展到哪里，右边最近的且比a[i]小的 对于每个i，都在右边找一个最近且比a[i]小的。 这件事情可以用单调队列解决。 考虑对于第i个数，求出当这个数成为最小值时，往左往右分别最远能到哪里。 用这些来更新答案就可以了。 使用单调队列来实现这一过程。 例题3 给定n*m的01矩阵 找一个面积最大的全0子矩阵。 $n,m\\leq1000$ cpp if (a[i][j]==0) f[i][j] = f[i-1][j] + 1; else f[i][j] = 0; RMQ问题 给定n个数，有Q次询问，每次询问一段区间的最小值。 倍增。 nlgn 1 线段树。 n lgn 分块。 nsqrtn sqrtn 整体二分。 倍增：记录所有长度为2的幂次的区间的最小值。 n=5 [1,1] [2,2] [3,3] [4,4] [5,5] [1,2] [2,3] [3,4] [4,5] [1,4] [2,5] f[i][j] 表示 [i,i+2^j-1] 这段区间的最小值 [2,5] f[2][2] nlgn项 f[i][0] = a[i] f[i][j]表示[i,i+2^j-1]这段区间的最小值 f[i][j] = min(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]) for (j=1; j&lt;=20; j++) for (i=1; i&lt;=n-(1&lt;&lt;j)+1; i++) f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]) [L,R] 先找到一个k，使得2^k &lt;= R-L+1 且 2^(k+1) &gt; R-L+1 一开始预处理 p[x] 表示当R-L+1=x时k应该是多少 k=int(log(R-L+1)/log(2)) k=p[R-L+1]; min(f[L][k],f[R-(1&lt;&lt;k)+1][k]) 开车旅行 我们考虑记录a[x]a[x+2^k-1]的最小值，令其为f[x][k]。这可以在nlgn的时间内求出。 对于每次询问LR，令k=log[R-L+1]。有ans=min(f[L][k],f[R-2^k+1][k])。(即进行O(1)询问) LCA 给定一棵树，求两个点的最近公共祖先。 通过倍增来求LCA。 思路： 1.将两个点深度变成一样。 一起往上走找最近公共祖先。 事先得先求出每个点的父亲是谁，以及它的深度是多少。 dfs fa[i]表示i的父亲，dep[i]表示i的深度 第一步：将x和y走到同一层。 if (dep[x]&lt;dep[y]) swap(x,y); // 保证dep[x]&gt;=dep[y] 意味着 x要向上走dep[x]-dep[y]步。 f[i][j] 表示 i向上走2^j步后，能到哪儿 f[i][0]=fa[i]; f[i][j]=f[f[i][j-1]][j-1] for (j=1; j&lt;=20; j++) for (i=1; i&lt;=n; i++) f[i][j]=f[f[i][j-1]][j-1] 通过f数组来加速x向上走这个过程。 x向上走dep[x]-dep[y]步。 t=dep[x]-dep[y] 将t二进制分解 10 = 1010 x先向上跳8步，再向上跳2步 for (i=20; i&gt;=0; i–) if (t&amp;(1&lt;&lt;i)) x=f[x][i]; x和y就会到达同一层 让x和y一起往上跳，找它们的最近公共祖先 for (i=20; i&gt;=0; i--) if (f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i] if (x==y) return x; else return f[x][0]; 预处理fa，dep f[i][0]=fa[i]; f[i][j]=f[f[i][j-1]][j-1] for (j=1; j&lt;=20; j++) for (i=1; i&lt;=n; i++) f[i][j]=f[f[i][j-1]][j-1] t=dep[x]-dep[y] for (i=20; i&gt;=0; i--) if (t&amp;(1&lt;&lt;i)) x=f[x][i]; //这一步结束时有可能x==y if (x==y) return x; for (i=20; i&gt;=0; i--) if (f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i] return f[x][0]; dfs void dfs(int x,int y) { dep[x]=y; for (i=son of x) {fa[i]=x; dfs(i,y+1);} } dfs(1,1); 链上最大值问题 给定一棵带边权的树，每次询问两个点x,y，求这两个点的路径上最长的边是多少。 思路： f[i][j]从i出发向上走2^j步能走到哪儿 g[i][j]从i出发向上走2^j步的过程中经过的最长边是什么 f[i][0]=fa[i],g[i][0]=dis(i,fa[i]); f[i][j]=f[f[i][j-1]][j-1] g[i][j]=max(g[i][j-1],g[f[i][j-1]][j-1]). 求答案的时候，用g数组来更新最大值 链上和问题 给定一棵树，每次询问两个点x,y，求这条路径上边权和是多少。 思路： dis[i] 从根节点出发到i经过的边的长度和 x~y的路径长度 dis[x]+dis[y] – 2*dis[LCA(x,y)] 链上异或问题 给定一棵树，每次询问两个点x,y，求这条路径上边权异或和是多少。 思路： dis[i]表示从1出发到i经过的边的边权亦或和 x~y = dis[x]^dis[y] Hash简单Hash 有100个数字，每个数字的大小都是$\\leq10^5$。 问是否存在一对数字的值相等。 要求一个线性做法。 for (i=1; i&lt;=100; i++) { cin&gt;&gt;A; f[A]++; if (f[A]==2) return true; } return false; $\\leq10^9$ 呢？ for (i=1; i&lt;=100; i++) { cin&gt;&gt;A; A%=12345678; f[A]++; if (f[A]==2) return true; } return false; 重要性质 假如有n个自然数。 要使得这n个数之间在大概率下不冲突(不同的数在模p意义下相等)。 p&gt;=n^2。 一维Hashvoid Insert(int x) { int t=x % 19999997; //a[i]来表示i这个位置存的数是什么 while (a[t] &amp;&amp; a[t]!=x) t=(t+1) % 19999997; a[t]=x; b[t]++; // b[i]表示a[i]这个数字出现了几次 } int Query(int x) { int t=x % 19999997; while (a[t] &amp;&amp; a[t]!=x) t=(t+1) % 19999997; if (a[t]==x) return b[t]; else return 0; } cin&gt;&gt;A; Insert(A); if (Query(A)==2) return true; 模数开成10倍的元素个数，近似线性 字符串Hash 给定一个字符串，求是否存在两个长度为k的子串完全相同。 abcabc k=4 要求$O(|s|)$ |s|&lt;=100W 对于每一个数字 先对10^18取模 得到 n-k+1个 10^18级别的数，询问是否存在一对数相同 两次hash 第一次hash -&gt; 很大的26进制数 变成 10^18级别的数 二次 -&gt; 10^18级别的数映射到1000W级别的数组 二维Hash 给定一个n_n的矩阵，求是否存在两个完全相同的k_k的子矩阵。 要求时间复杂度与读入同阶。","link":"/2019/03/09/e6-b8-85-e5-8c-97-e5-ad-a6-e5-a0-82noip2019-e9-9b-86-e8-ae-add2-e6-95-b0-e6-8d-ae-e7-bb-93-e6-9e-84/"},{"title":" 美国贸易战的实质是遏制中国！The essence of the US trade war is to contain China！\t\t","text":"打开看看？ 当大部分人都预期中美贸易磋商即将迎来曙光的时候，美国政客又一次极力诋毁和指责中国，并不顾双方在加强知识产权保护、扩大市场准入、促进双边贸易平衡等方面取得的实质性进展，单方面举起关税大棒，开始对2000亿美元中国输美商品的关税从10%上调至25%，使眼看就要拨云见日的中美经贸磋商瞬间阴云密布。 美国政客的极限施压再次惊醒了中美贸易战这头“灰犀牛”，引发了全球投资者的极度不安，全球股票市场均呈现大幅下跌。 （一） 美国政客为自己的关税大棒找了个说法，声称中国要对之前谈判达成的条款进行重新协商。即使如特朗普先生所言，中国对谈判的文本提出修改意见，这也是中方的基本权利。 要知道，中美之间进行的是经贸磋商，磋商就是一个反复商量的过程，就是双方不断讨价还价的过程。你想要什么就给什么，那不是磋商，那是“一边倒”的压服。 中国人民历史上被西方列强强加过很多不平等条约，新中国成立后，中国人民好不容易挣脱了这些不平等条约。今天的中国，再也不愿意，也不可能接受新的不平等条约。 实际上，中美经贸磋商中一再出尔反尔的倒是美国。2017年11月，特朗普访华，两国元首表示，双方将继续致力于互利共赢的中美经贸合作，中美双方签署了高达2535亿美元的经贸合作协议。但4个月后，2018年3月22日，特朗普就指示美国贸易代表办公室要对中国商品加征关税，要限制中国投资。 2018年5月19日，经过艰苦努力，中美达成“不打贸易战，并停止互相加征关税”的共识，并对外发表了联合声明。但仅仅10天后，美国突然宣布将于6月15日公布将被征收25%关税的500亿美元中国产品最终名单，公然违背双方刚达成的共识。如果按照特朗普先生的做法，同美国打交道必然无言可信。 再扯远一点，美国在信守承诺上可是劣迹斑斑，他连正在执行中的协议都可以撕毁。比如说最近闹得比较凶的伊朗核问题，之所以横生波澜，就是美国单方面撕毁了伊核协议。要知道这份协议是美国政府自己主导签订的，是联合国安理会一致通过的。美国经常指责中国不遵守承诺，但其实常常不遵守承诺的是他自己。 （二） 那么美国为什么此时又抡起关税大棒呢？答案应该是美国想从中国身上压榨到更多的利益，想用关税搅乱中国的发展信心。在中美经贸摩擦中，要看透美国行为的本质。美国人看似和我国在谈经贸，但其很多要求早已超出经贸范畴，醉翁之意不在酒，在于遏制中国，在于搅乱中国的发展。 对于遏制中国，美国是一以贯之的，只不过不同时期，遏制手段不同而已。以前是制裁、封锁、轰炸使馆等等，今天成了贸易战。 美国之所以发起贸易战，其声称的理由是美中贸易不平衡，是美国对华贸易逆差。但其实美国人都清楚，贸易战也许会减少对华贸易逆差，但不可能减少美国的贸易逆差。 美国哈佛大学教授，曾经担任过副国务卿的哈珀教授就明确指出，关税不可能减少美国贸易逆差。“特朗普政府一旦真的对中国商品大规模征税，这部分进口来源只会转移到其他经济体，例如孟加拉国、越南等国都会快速替补空缺，因而征收高额关税并不能减少美国逆差总额。” 所以，美国关税真正的指向并不是减少其逆差，而是减少中国出口，减少中国顺差，进而遏制我国发展。 说白了，美国是不愿意看到中国的发展，中国的强大的。美国政府多次表达了维持“美国第一”的强烈意愿。特朗普曾明确讲：“当我上任时，我们面临的问题是，中国将在非常短的时间内超过我们。但那种情况不会再发生了。”为什么不会再发生了？因为美国正在不遗余力地予以遏制，而且他相信，他能像当年打击日本一样，成功地通过贸易战遏制中国发展势头。在遏制中国发展上，特朗普不是第一人，可能也不是最后一人。 美国一位前总统就曾经明确说过：“如果超过十亿的中国居民也像澳大利亚人、美国人现在这样生活，那么我们所有人都将陷入十分悲惨的境地，因为那是这个星球所无法承受的”。 而要遏制中国发展，最有效的就是打掉中国的制度优势。美国人对此清楚得很，便假借经贸之手，挥舞关税大棒，意图逼迫中国签署城下之盟，放弃制度优势。 但中国早已不是100年前之中国，经贸问题可以谈，但以贸易为幌子对我国的政治体制、对我国的主权行为横加干预，这是我们绝对不能接受的。 （三） 在经贸磋商中，美国之所以敢不断抡大棒，不断进行极限施压，其所凭借的是中美之间贸易的不对称性。美国的子弹似乎比我们多。但是，手中子弹的多少并不能决定战争的胜负，战争的胜负还要看双方的意志，双方的精神，双方的耐力。 遥想当年抗美援朝，志愿军用单衣加土豆加步枪，就打败了拥有当时最精良装备的美国军队。当时，中国手里的子弹不知比现在少多少，但我们还是取得了胜利。 自古以来，中国就不是一个任人欺凌的国家，中国人民自古就有伟大的抗争精神。 今天，中国不仅有伟大的斗争精神，我们还有强大的斗争能力。 中国人珍视和平，以和为贵，但也不会委屈求和。 “朋友来了有好酒，豺狼来了有猎枪”，谈，我们好酒相迎，打，我们也不怕，猎枪有的是。 中国人不惹事，但也不怕事，该亮剑时必亮剑。（文/陈壮） (责编：白宇) When most people anticipate the dawn of Sino-US trade negotiations, American politicians once again vigorously denigrate and accuse China of unilaterally raising tariff sticks and raising tariffs on $200 billion of Chinese goods exported to the United States from 10% to 25%, despite the substantial progress made by both sides in strengthening intellectual property protection, expanding market access and promoting bilateral trade balance. In the near future, the Sino-US economic and trade consultation will be cloudy. The extreme pressure of American politicians has once again awakened the “gray rhino” of the Sino-US trade war, triggering extreme anxiety among global investors and a sharp drop in global stock markets. (1) American politicians have come up with an argument for their tariff stick, claiming that China will renegotiate previously negotiated terms. Even if, as Mr. Trump said, China proposes amendments to the negotiating text, which is also China’s basic right. We should know that the economic and trade consultation between China and the United States is a process of repeated consultation, that is, the process of continuous bargaining between the two sides. Give whatever you want. It’s not negotiation. It’s one-sided persuasion. Many unequal treaties were imposed by Western powers in the history of the Chinese people. After the founding of New China, the Chinese people had no difficulty in breaking away from these unequal treaties. Today’s China is no longer willing or able to accept new unequal treaties. In fact, it is the United States that has repeatedly backfired in the Sino-US economic and trade negotiations. In November 2017, Trump visited China. The two heads of state said that they would continue to work for mutually beneficial and win-win economic and trade cooperation between China and the United States. The two sides signed an economic and trade cooperation agreement of up to 253.5 billion US dollars. But four months later, on March 22, 2018, Trump instructed the U.S. Trade Representative’s office to impose tariffs on Chinese goods and restrict Chinese investment. On May 19, 2018, after arduous efforts, China and the United States reached a consensus on “no trade war, and stop imposing tariffs on each other”, and issued a joint statement to the outside world. But just 10 days later, the United States suddenly announced on June 15 that it would publish a final list of $50 billion of Chinese products subject to a 25% tariff, in flagrant violation of the consensus just reached between the two sides. If Mr Trump’s approach is followed, dealing with the United States is bound to be wordless and credible. To put it further, the United States is so bad at keeping its promises that it can tear up even the agreements being implemented. For example, the recent Iranian nuclear issue, which has been more fierce, is caused by the unilateral tearing up of the Iranian nuclear agreement by the United States. We should know that this agreement was signed under the leadership of the United States Government and unanimously adopted by the United Nations Security Council. The United States often accuses China of failing to keep its promises, but in fact, it is often him who fails to keep his promises. (two) So why did the United States use the tariff stick again at this time? The answer should be that the United States wants to squeeze more benefits from China and use tariffs to disrupt China’s confidence in development. In the Sino-US economic and trade frictions, we should see through the essence of American behavior. Americans seem to be talking with our country about economy and trade, but many of their requirements have already gone beyond the scope of economy and trade. Drunken men are not interested in wine, but in curbing China and disrupting China’s development. To contain China, the United States is consistent, but in different periods, the means of containment are different. It used to be sanctions, blockades, bombing embassies and so on, but today it has become a trade war. The reason why the United States launched the trade war is that the trade imbalance between the United States and China is the trade deficit between the United States and China. But in fact, Americans know that the trade war may reduce the trade deficit with China, but it is impossible to reduce the trade deficit with the United States. Harvard University professor and former deputy secretary of state Professor Harper made it clear that tariffs could not reduce the U.S. trade deficit. “Once the Trump government really imposes a large-scale tax on Chinese goods, this part of the import source will only be transferred to other economies, such as Bangladesh, Vietnam and other countries will quickly replace the vacancy, so imposing high tariffs will not reduce the total deficit of the United States.” Therefore, the real direction of US tariffs is not to reduce its deficit, but to reduce China’s exports, reduce China’s surplus, and then curb China’s development. To put it bluntly, the United States is unwilling to see the development of China, China’s strong. The U.S. government has repeatedly expressed its strong willingness to maintain “America First”. Trump made it clear: “When I took office, the problem we faced was that China would surpass us in a very short time. But that won’t happen again.” Why won’t it happen again? Because the United States is doing its utmost to curb it, and he believes that he can successfully curb China’s momentum of development through trade wars, just as he did against Japan. Trump is not the first and probably not the last person to curb China’s development. A former president of the United States once said clearly: “If more than one billion Chinese residents live like Australians and Americans now, then all of us will be in a very tragic situation, because that is beyond the capacity of the planet.” To curb China’s development, the most effective way is to eliminate China’s institutional advantages. Americans know this very well, so they use the hand of trade and economy to wave tariff sticks, intending to force China to sign an alliance under the city and abandon its institutional advantages. But China is not China 100 years ago. Economic and trade issues can be discussed. However, it is absolutely unacceptable for us to interfere with our political system and sovereignty under the guise of trade. (three) In the economic and trade negotiations, the reason why the United States dares to continue to make big sticks and exert extreme pressure is the asymmetry of trade between China and the United States. America seems to have more bullets than us. However, the number of hand neutron bombs does not determine the victory or defeat of the war. The victory or defeat of the war depends on the will of both sides, the spirit of both sides and the endurance of both sides. Looking back on the war of resistance against the United States and aid to the DPRK, the volunteer military with single clothes and potatoes and rifles defeated the American army, which had the most sophisticated equipment at that time. At that time, China had fewer bullets than it does now, but we still won. Since ancient times, China has not been a bullying country. The Chinese people have a great spirit of resistance since ancient times. Today, China has not only a great spirit of struggle, but also a strong ability to fight. The Chinese cherish peace and value peace, but they will not compromise and seek peace. “Friends come with good wine, jackals come with shotguns.” Talk about it, we welcome each other with good wine, fight, we are not afraid, there are shotguns. Chinese people are not troublesome, but they are not afraid of things. When they shine their sword, they must shine their sword. (Wen/Chen Zhuang) (Responsibility: Bai Yu) 转载：人民网 Reprint: people.cn","link":"/2019/05/16/e7-be-8e-e5-9b-bd-e8-b4-b8-e6-98-93-e6-88-98-e7-9a-84-e5-ae-9e-e8-b4-a8-e6-98-af-e9-81-8f-e5-88-b6-e4-b8-ad-e5-9b-bd-ef-bc-81the-essence-of-the-us-trade-war-is-to-contain-china-ef-bc-81/"},{"title":" 清北学堂noip2018集训D2\t\t","text":"清北学堂noip2018集训D2 P.S.今天讲数据结构，大概包括了二叉堆，二叉搜索树，线段树，树状数组，并查集，st表，RMQ，LCA。 二叉堆 基本功能 O(log n)插入元素 O(1)查最大（最小）元素 O(log n)删除最大（最小）元素 O(log n)删除任意元素 基本结构 最为常用的堆结构就是完全二叉堆。 在逻辑形式上，结构必须等同于完全二叉树，同时，堆顶以外的每个节点都不大于（小于）其父亲，即堆有序。 如果堆顶最大，称为最大二叉堆（大根堆），反之称为最小二叉堆（小根堆）。 因为完全二叉堆等同于完全二叉树的结构，故高度相当。为O(log n). 一般为了实现方便，根节点编号为1，节点n左节点为2n，右节点为2n+1. 查询操作 最大（最小），直接返回堆顶即可。 插入操作 首先把新元素插入向量末尾，为了维持堆的有序性，逐层检查是否有序并调整，过程通常称为上滤。 建堆 O(n log n)插入每个元素即可。 O(n)? 先随机放入一个完全二叉树。 从倒数第二个深度开始检索，使堆有序。 ##### 删除最大（最小）元素 首先将堆顶元素与堆尾元素交换。 删除堆尾元素。 一步一步将这个换上去的元素下移。 直到堆有序。 ##### 删除任意元素 - 新建一个堆，将删除的元素放入新堆里。即可实现删除。二叉搜索树 基本功能 排序 查询元素大小排名 插入元素 二叉平衡树的基础 结构 若左子树不为空，则左子树上所有节点小于根节点。 若右子树不为空，则右子树上所有节点大于根节点。 左右子树也分别称二叉排序树。 排序 中序遍历 查询元素大小排次 从根开始向左、右是唯一的，如果向右，那么将左边的节点数加起来，反之不加。 插入 与查询方法类似。 - 查询到节点后向上更新其他节点。线段树 基本功能 建树 单点查询 单点修改 区间查询 区间修改 结构 是一棵二叉搜索树，每个节点代表一个区间。 每个节点需要维护 区间左右端点 区间要维护的信息 基本思想：二分 特殊性质 左子节点区间为[l,mid],右为[mid+1,r]. 对于一个节点k，左子节点为2k，右子节点为2k+1. 建树 对于二分的每一个节点，确定其代表的区间。 如果为叶子结点，存需要维护的信息。 对于非叶子结点，将两个子节点状态合并。 单点查询 在左右节点搜索是确定的，由节点的mid决定，如果要查询的点大于mid，则在右子树搜索，反之在左子树搜索。代码如下： cpp #include&lt;bits/stdc++.h&gt; using namespace std; #define LL long long const int MAXN = 100000; struct tree{ int l,r,s; }mi[4*MAXN+20]; void build(int k,int l,int r){ mi[k].l=l; mi[k].r=r; if(l==r){ mi[k].s=r; return; } int mid=(l+r)/2; build(2*k,l,mid); build(2*k+1,mid+1,r); mi[k].s=mi[k*2].s+mi[k*2+1].s; } int search(int k,int n){ if(mi[k].l==mi[k].r&amp;&amp;mi[k].r==n){ return k; } int mid=(mi[k].l+mi[k].r)/2; if(n&lt;=mid) return search(k*2,n); else return search(k*2+1,n); } int main(){ build(1,1,6); cout&lt;&lt;search(1,5); return 0; } 单点修改 先执行单点搜索，然后执行修改操作，再向上更新状态。 代码如下cpp int insert(int k,int n,int v){ int now=search(k,n); mi[now].s+=v; while(now!=1){ now/=2; mi[now].s=mi[2*now].s+mi[2*now+1].s; } } 区间查询 令[l,r]为当前节点代表的区间，mid代表区间中点，[x,y]代表要查询的区间。 若[l,r]=[x,y]直接返回即可。 如果$y\\leq mid$,[l,r]-&gt;[l,mid],[x,y]不变，递归查询。 如果$x &gt; mid$,[l,r]-&gt;[mid+1,r],[x,y]不变，递归查询。 否则，[x,y]跨过了mid的两端，将其分成了两个子问题，$[l,mid]$中查$[x,mid]$.$[mid+1,r]$中查$[mid+1,y]$. 代码如下： cpp int query_sum(int k,int x,int y){ if(y&lt;mi[k].l||x&gt;mi[k].r) return 0; if(x==mi[k].l&amp;&amp;mi[k].r==y) return mi[k].s; int mid=(mi[k].l+mi[k].r)/2; return query_sum(k*2,x,mid)+query_sum(k*2+1,mid+1,y); } 区间修改 关键：懒标记 经过节点的集合与区间查询相同 更新这些区间的答案并打上一个标记，来表示这个区间中的数要进行哪些修改。 只有当查询或者修改经过一个节点时，才将其节点上的懒标记放到两个孩子节点，下放的同时修改两个孩子节点的答案。 模板（无区间修改）/*求和线段树*/ #include&lt;bits/stdc++.h&gt; using namespace std; #define LL long long #define inf 2147483647 const int MAXN = 100000; struct tree{ int l,r,s; }mi[4*MAXN+20]; void build(int k,int l,int r){ mi[k].l=l; mi[k].r=r; if(l==r){ mi[k].s=r; return; } int mid=(l+r)/2; build(2*k,l,mid); build(2*k+1,mid+1,r); mi[k].s=mi[k*2].s+mi[k*2+1].s; } int search(int k,int n){ if(mi[k].l==mi[k].r&amp;&amp;mi[k].r==n){ return k; } int mid=(mi[k].l+mi[k].r)/2; if(n&lt;=mid) return search(k*2,n); else return search(k*2+1,n); } int query_sum(int k,int x,int y){ if(y&lt;mi[k].l||x&gt;mi[k].r) return 0; if(x==mi[k].l&amp;&amp;mi[k].r==y) return mi[k].s; int mid=(mi[k].l+mi[k].r)/2; return query_sum(k*2,x,mid)+query_sum(k*2+1,mid+1,y); } int insert(int k,int n,int v){ int now=search(k,n); mi[now].s+=v; while(now!=1){ now/=2; mi[now].s=mi[2*now].s+mi[2*now+1].s; } } int main(){ int n,m,x,v; cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;v; build(1,n,m); cout&lt;&lt;query_sum(1,x,v); return 0; } 树状数组 基本功能 单点修改，前缀信息查询。 区间修改可减信息（前缀和），单点查询。 lowbit函数 含义：一个数，二进制表示中的最后一个1。 计算机中负数的表示？ 怎么求lowbit呢？ $x and (-x)$ 结构 我们定义c[i]为区间$[i-lowbit(i)+1,i]$。 怎么直观的看一看呢？ $S_n=S_{(n-lowbit(n))}+C_n$ 查询代码 int sum(int x){ int ans=0; for(;x;x-=lowbit(x)) ans+=c[x]; return ans;} 修改代码 void update(int x,int v){ for(;x&lt;=n;x+=lowbit(x)) c[x]+=v;} 代码示例： #include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=100010;int a[maxn],c[maxn];int n;int lowbit(int x){ return x&amp;(-x);}int sum(int x){ int ans=0; for(;x;x-=lowbit(x)) ans+=c[x]; return ans;}void update(int x,int v){ for(;x&lt;=n;x+=lowbit(x)) c[x]+=v;}int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; update(i,a[i]); } cout&lt;&lt;sum(n); return 0;} 区间修改，单点查询 且以修改为加法，查询为求和为例。 - 对于将$[l,r]$加$x$的操作，可以将点$l$加$x$，将点$r+1$减$x$，这时候求点$n$的前缀和就能得到点$n$真实的值。并查集 基本功能 合并两个集合 查询某一个元素属于哪个集合 结构 并查集S由若干子集合$S_i$构成，并查集的逻辑结构是一个森林。 $S_i$表示森林中的一颗子树。 一般以子树的根作为该子树的代表。 而对于并查集的存储结构，可用一维数组来实现。 查询某个元素属于哪个集合 通常而言都是以根作为这个集合的代表元。 因此只需要不断向父亲节点走，直到走到根为止返回即可。 合并集合 路径压缩优化 示例代码 ```cpp #include&lt;bits/stdc++.h&gt; using namespace std; int fa[200010]; int n; int find(int x) { if(fa[x] == 0) return x; return fa[x] = find(fa[x]); } void add(int x,int y){ int xx=find(x),yy=find(y); fa[yy]=xx; } int main(){ cin&gt;&gt;n; int x,y,m,z; for(int i=0;i&lt;n;i++){ cin&gt;&gt;x&gt;&gt;y; add(x,y); } cin&gt;&gt;m&gt;&gt;z; cout&lt;&lt;find(m)&lt;&lt;” “&lt;&lt;find(z); return 0; } ``` RMQ问题 R——Range M——Minimum/Maximum Q——Query 即区间最值问题 例题 - 方法1：使用线段树 - 方法2：st表 ST表 基本功能 $O(nlogn)$预处理，$O(1)$查询区间最值。 结构 $f[i][j]$表示区间$[i,i+2^j-1]$的信息。 整个$f$数组就是ST表。 建表 $f[i][0]$就是单点i的信息 当$j&gt;0$时，$f[i][j]$为$f[i][j-1],f[i+2^{j-1}-1][j-1]$两个区间信息的并集。 查询 比方说我们要查询区间$[x,y]$的信息。 令t为最大的正整数使得$2^t\\leq y-x+1$ 那么答案就是$[x,x+2^t-1]\\cup[y-2^t+1,y]$ 代码如下： #include&lt;bits/stdc++.h&gt;#define maxn 111100#define logN 25//因为cmath中的log函数效率差，不如直接设定一个永远到不了的值using namespace std; int f[maxn][logN],a[maxn],n,m; void pre_st(){ //制表 for(int i=1;i&lt;=n;i++) f[i][0]=a[i]; //因为第二个框框中存的j是用来计算 i+2^j-1（既该f保存的值） //服务于动态规划的结果 for(int j=1;j&lt;=logN;j++){ for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]); //注释1 （1&lt;&lt;j）是计算出 2^j 把一一直右移即可得到 //注释2 使用刚才得到的动态规划方程 }} int main(){ cin &gt;&gt; n;cin &gt;&gt; m; for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); pre_st(); //制表 int x,y; for(int i=1;i&lt;=m;i++){ cin &gt;&gt; x &gt;&gt; y; int s=log(y-x+1)/log(2); //计算出这一段距离之中最大的2的倍数，以查表 cout &lt;&lt; max(f[x][s],f[y-(1&lt;&lt;s)+1][s]) &lt;&lt; endl;; //合并左右不分的解 } return 0;} * * * 查询树上两点的最近公共祖先（LCA） ------------------ * L——Lowest * C——Common * A——Ancestor * 即最近公共祖先 ### 欧拉序 * 一种特殊的dfs序，每到达一个点就加入序列。 * 记录每个点第一次出现的时间$S\\[u\\]$，欧拉序中第i个点为$Q\\[i\\]$。 * $LCA(x,y)$是$Q\\[S\\[x\\]...S\\[y\\]\\]$中层数最低的点。 * 区间最值？ * ST表！","link":"/2019/03/09/e6-b8-85-e5-8c-97-e5-ad-a6-e5-a0-82noip2018-e9-9b-86-e8-ae-add2/"},{"title":" 清北学堂noip2018集训D4\t\t","text":"P.S.最小生成树，最短路问题，SPFA算法，强连通分量。 图的读入 n m m行，u，v 例如： 6 8 1 2 1 3 2 4 3 4 3 5 4 1 4 6 5 6 6 8 1 1 1 2 1 5 2 5 2 3 3 4 4 5 4 6 一些术语 简单图：无重边，无自环。 路径：一组首尾相连的边的集合 度数（入度，出度）：连接一个点的边的数量。 连通图：图中任意两点都有路径连接。 连通分量（联通块）：极大的联通子图。 完全图：任意两点有边相连。n个点的完全图有$n(n-1)/2$。 有向无环图（DAG） 图的存储 用的方便？ 检查两点之间是否有边。 遍历（枚举）一个点的所有出边。 #### 邻接矩阵 检查两点之间是否有边。 注意空间 256 MB 256*1024*1024 B bool 1B int 4B long long 8B double 8B 时间 1s $10^7$ O(n) 代码如下 cpp #include&lt;bits/stdc++.h&gt; using namespace std; int n,m; // n*n int graph[105][105]; int main(){ scanf(&quot;%d%d&quot;,&amp;m,&amp;n); int x,y; for(int i=0;i&lt;n;i++){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); x--;y--; graph[x][y]=1; graph[y][x]=1; //重边：graph[x][y]++; //graph[x][y]++; //权值：graph[x][y]=z; //graph[y][x]=z; } for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;n;j++){ cout&lt;&lt;graph[i][j]&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; } return 0; } 邻接表 遍历（枚举）一个点的所有出边。 n个链表 对于每个点，开一个链表，链表存储当前这个点的所有出边。 1 .vector存图 STL 可变长数组 2 . 数组链表 代码如下： #include&lt;bits/stdc++.h&gt; using namespace std; int n,m; vector&lt;int&gt; a[10005]; int graph[105][105]; int main(){ scanf(&quot;%d%d&quot;,&amp;m,&amp;n); int x,y; for(int i=0;i&lt;n;i++){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); a[x].push_back(y); a[y].push_back(x);//无向图 } int w=3; for(int i=0;i&lt;a[w].size();i++){ cout&lt;&lt;a[w][i]&lt;&lt;&quot; &quot;; } return 0; } * 链表存储 * 代码如下： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; int n,m; // 数组链表 邻接表 // 链表头 链表节点的下一个节点 这条边指向图中的点 int head[10005],nxt[30005], ver[30005]; int tot;// 记录链表节点用了多少个 void add(int x,int y){ // 在x的链表中 加一条指向y的边 ++tot; // 当前链表节点就是编号为tot ver[tot]=y; nxt[tot]=head[x]; head[x]=tot; } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0,x,y;i&lt;m;i++){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y); add(y,x);//无向图 } // 遍历一个点的所有出边 int x=5; for(int i=head[x];i;i=nxt[i]){ int y=ver[i]; printf(&quot;%d &quot;,y); } return 0; } * 带权值： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; int n,m; // 数组链表 邻接表 // 链表头 链表节点的下一个节点 这条边指向图中的点 边的权值 int head[10005],nxt[30005], ver[30005] , w[30005]; int tot;// 记录链表节点用了多少个 void add(int x,int y,int z){ // 在x的链表中 加一条指向y的边 权值为z ++tot; // 当前链表节点就是编号为tot ver[tot]=y; w[tot]=z; nxt[tot]=head[x]; head[x]=tot; } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0,x,y;i&lt;m;i++){ scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); add(x,y,z); add(y,x,z);//无向图 } // 遍历一个点的所有出边 int x=5; for(int i=head[x];i;i=nxt[i]){ int y=ver[i]; printf(&quot;%d %d &quot;,y,w[i]); } return 0; } * #### 遍历图 * dfs * 代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; int n,m; // 数组链表 邻接表 // 链表头 链表节点的下一个节点 这条边指向图中的点 int head[10005],nxt[30005], ver[30005]; int tot;// 记录链表节点用了多少个 void add(int x,int y){ // 在x的链表中 加一条指向y的边 ++tot; // 当前链表节点就是编号为tot ver[tot]=y; nxt[tot]=head[x]; head[x]=tot; } bool vis[10005]; void dfs(int x){ printf(&quot;%d &quot;,x); vis[x]=1; for(int i=head[x];i;i=nxt[i]){ if(!vis[ver[i]]){ dfs(ver[i]); } } } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0,x,y;i&lt;m;i++){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y); add(y,x);//无向图 } dfs(1); return 0; } * bfs * 代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; using namespace std; int n,m; // 数组链表 邻接表 // 链表头 链表节点的下一个链表节点 这条边指向图中的点 int head[10005],nxt[30005], ver[30005]; int tot;// 记录链表节点用了多少个 void add(int x,int y){ // 在x的链表中 加一条指向y的边 ++tot; // 当前链表节点就是编号为tot ver[tot]=y; nxt[tot]=head[x]; head[x]=tot; } bool vis[10005]; // 是否已经入队 int d[10005]; // 到起点的距离 queue&lt;int&gt; q; // 队列 // q.front() 队列的第一个元素 // q.push(x) 把x加入到队列中 // q.pop()弹出第一个数字 // q.empty()返回队列是否为空 // q.size()队列里还有多少元素 int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0,x,y;i&lt;m;i++){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y); add(y,x);//无向图 } // 遍历一个点的所有出边 // int x=5; // for(int i=head[x];i;i=nxt[i]){ // int y=ver[i]; // printf(&quot;%d &quot;,y); // } // // 重复入队 // while(!q.empty()) { // int x=q.front();q.pop(); // vis[x] = 1; // // do something // // for(int i=head[x];i;i=nxt[i]){ // if(!vis[ver[i]]){ // q.push(ver[i]); // } // } // } q.push(1);vis[1]=1; /// !!!! while(!q.empty()) { int x=q.front();q.pop(); // do something for(int i=head[x];i;i=nxt[i]){ int y=ver[i]; if(!vis[y]){ vis[y] = 1; d[y] = d[x] + 1 ; q.push(y); } } } for(int i=1;i&lt;=n;i++){ printf(&quot;%d &quot;,d[i]); } return 0; } * #### 最短路 * 多源最短路 * Floyd * 考虑用dp解决这个问题； * $dp\\[i\\]\\[j\\]\\[k\\]=min(dp\\[i-1\\]\\[j\\]\\[i\\]+dp\\[i-1\\]\\[i\\]\\[k\\],dp\\[i-1\\]\\[j\\]\\[k\\])$ * $dp\\[j\\]\\[k\\]=min(dp\\[j\\]\\[i\\]+dp\\[i\\]\\[k\\],dp\\[j\\]\\[k\\])$ * 代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; int n,m; // n*n // 100000 200000 int graph[105][105]; // 边权&gt;0 int floyd[105][105]; int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0,x,y,z;i&lt;m;i++){ scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); graph[x][y]=z; } memset(floyd,0x3F,sizeof(floyd)); for(int i=1;i&lt;=n;i++) floyd[i][i] = 0; // 初始值 for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ if(graph[i][j]) floyd[i][j]=graph[i][j]; } } // floyd O(n^3) for(int k=1;k&lt;=n;k++){ // 循环顺序注意 for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ floyd[i][j]=min(floyd[i][j],floyd[i][k]+floyd[k][j]); } } } int xx,yy; scanf(&quot;%d%d&quot;,&amp;xx,&amp;yy); printf(&quot;%d&quot;,floyd[xx][yy]); return 0; } * 单源最短路 * 求一个点到每个点的最短路 * Dijkstra 迪杰斯特拉算法 * SFPA算法 * Dijkstra 迪杰斯特拉算法 1. 从所有点中选择未标记的$dis\\[i\\]$值最小的顶点$i$，将$i$标记； 2. 松弛节点$i$的相邻节点 3. 若所有点都被标记，结束。否则回到1 4. 代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; using namespace std; int n,m; // 数组链表 邻接表 // 链表头 链表节点的下一个节点 这条边指向图中的点 边的权值 int head[10005],nxt[30005], ver[30005] , w[30005]; int tot;// 记录链表节点用了多少个 void add(int x,int y,int z){ // 在x的链表中 加一条指向y的边 权值为z ++tot; // 当前链表节点就是编号为tot ver[tot]=y; w[tot]=z; nxt[tot]=head[x]; head[x]=tot; } struct N{ int x,w; // x节点，w 当前d[x]的值 friend bool operator &lt; (N a,N b){ // C++重载运算符 return a.w&gt;b.w; } N(int a=0,int b=0){ // 构造函数 x=a,w=b; } }; priority_queue&lt;N&gt; pq; int d[10005]; bool vis[10005] int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0,x,y;i&lt;m;i++){ scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); add(x,y,z); add(y,x,z);//无向图 } int s=1; memset(d,0x3f,sizeof d); // 0x3f3f3f3f d[s]=0; pq.push(N(s,d[s]); // pq.push((N){s,d[s]}); while(!pq.empty()){ int x=pq.top().x;pq.pop(); if(vis[x]) continue; else vis[x]=1; for(int i=head[x];i;i=nxt[i]){ int y=ver[i]; if(d[y]&gt;d[x]+w[i]){ d[y]=d[x]+w[i]; pq.push(N(y,d[y])); } } } // d[] // d[x] == 0x3f3f3f3f 不连通 return 0; } * 带计数的算法（多个最短路） #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; using namespace std; int n,m; // 数组链表 邻接表 // 链表头 链表节点的下一个节点 这条边指向图中的点 边的权值 int head[10005],nxt[30005], ver[30005] , w[30005]; int tot;// 记录链表节点用了多少个 void add(int x,int y,int z){ // 在x的链表中 加一条指向y的边 权值为z ++tot; // 当前链表节点就是编号为tot ver[tot]=y; w[tot]=z; nxt[tot]=head[x]; head[x]=tot; } struct N{ int x,w; // x节点，w 当前d[x]的值 friend bool operator &lt; (N a,N b){ // C++重载运算符 return a.w&gt;b.w; } N(int a=0,int b=0){ // 构造函数 x=a,w=b; } }; priority_queue&lt;N&gt; pq; int d[10005]; // 最短路的权值 int cnt[10005]; // 最短路的条数 bool vis[10005] int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0,x,y;i&lt;m;i++){ scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); add(x,y,z); add(y,x,z);//无向图 } int s=1; memset(d,0x3f,sizeof d); // 0x3f3f3f3f d[s]=0; cnt[s] = 1; pq.push(N(s,d[s]); // pq.push((N){s,d[s]}); while(!pq.empty()){ int x=pq.top().x;pq.pop(); if(vis[x]) continue; else vis[x]=1; for(int i=head[x];i;i=nxt[i]){ int y=ver[i]; if(d[y]&gt;d[x]+w[i]){ d[y]=d[x]+w[i]; cnt[y]=cnt[x]; pq.push(N(y,d[y])); }else if(d[y] == d[x]+w[i]){ cnt[y]+=cnt[x]; } } } // d[] // d[x] == 0x3f3f3f3f 不连通 return 0; } * POJ 2387 * SPFA * 流程： 1. 将源点S出队。 2. 从队列里取出头的点v，用原点到v的**当前最短距离**来更新源点到与v相邻的点的最短距离（松弛操作） 3. 将最短距离更新过且不在队列中的点入队。 4. 回到第二步，直到队列为空为止。 * 最坏情况$O(nm)$，大多数$O(m)/O(km)$ * 可以处理负权。 * 在稀疏图效率较高。 * 示例代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; using namespace std; int n,m; // 数组链表 邻接表 // 链表头 链表节点的下一个节点 这条边指向图中的点 边的权值 int head[10005],nxt[30005], ver[30005] , w[30005]; int tot;// 记录链表节点用了多少个 void add(int x,int y,int z){ // 在x的链表中 加一条指向y的边 权值为z ++tot; // 当前链表节点就是编号为tot ver[tot]=y; w[tot]=z; nxt[tot]=head[x]; head[x]=tot; } queue&lt;int&gt; q; int d[10005]; bool inq[10005]; int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0,x,y;i&lt;m;i++){ scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); add(x,y,z); add(y,x,z);//无向图 } int s=1; memset(d,0x3f,sizeof d); // 0x3f3f3f3f d[s]=0; q.push(s); inq[s]=1; while(!q.empty()){ int x=q.front();q.pop(); inq[x]=0; for(int i=head[x];i;i=nxt[i]){ int y=ver[i]; if(d[y]&gt;d[x]+w[i]){ d[y]=d[x]+w[i]; if(!inq[y]) inq[y]=1,q.push(y); } } } // d[] // d[x] == 0x3f3f3f3f 不连通 return 0; } * #### 最小生成树 * 生成树：选出一个图的$n-1$条边，使其构成一棵树。 * 最小生成树（MST）：边权和最小的那个生成树。 ![最小生成树](https://img-blog.csdn.net/20181004164451428?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNDQwNDg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) * Prim * Prim算法是通过先获取一个点，然后不断加入点的一个过程。 * 初始化：$V^’=x,E^’=\\\\varnothing$，x是随便一个节点。 * 重复下列操作，直到$V^’=V$ * 在E集合当中选择最小的边&lt;u,v&gt;使得$u\\\\in V^’但是v\\\\notin V^’$; * $V^’$加入节点v，$E^’$加入&lt;u,v&gt; * $(V^’,E^’)$为最小生成树。 * 类似Dijkstra. * 示例代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; using namespace std; int n,m; // 数组链表 邻接表 // 链表头 链表节点的下一个节点 这条边指向图中的点 边的权值 int head[10005],nxt[30005], ver[30005] , w[30005]; int tot;// 记录链表节点用了多少个 void add(int x,int y,int z){ // 在x的链表中 加一条指向y的边 权值为z ++tot; // 当前链表节点就是编号为tot ver[tot]=y; w[tot]=z; nxt[tot]=head[x]; head[x]=tot; } struct N{ int x,w; // x节点，w 当前d[x]的值 friend bool operator &lt; (N a,N b){ // C++重载运算符 return a.w&gt;b.w; } N(int a=0,int b=0){ // 构造函数 x=a,w=b; } }; priority_queue&lt;N&gt; pq; bool vis[10005] int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0,x,y;i&lt;m;i++){ scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); add(x,y,z); add(y,x,z);//无向图 } int s=1; d[s]=0; pq.push(N(s,0); int sum = 0; // pq.push((N){s,d[s]}); while(!pq.empty()){ int x=pq.top().x; sum+=pq.top().w; pq.pop(); if(vis[x]) continue; else vis[x]=1; for(int i=head[x];i;i=nxt[i]){ int y=ver[i]; if(!vis[y]){ pq.push(N(y,w[i])); } } } // sum 最小生成树的权值和 return 0; } * Kruskal * 给所有边按照边权从小到大的顺序排序； * 从小到大依次考虑每条边(u,v)（最开始没有任何的边）: * 如果u 与v 已经连通了，那么加入(u,v) 后会出现环，不添加 * 如果u 与v 没有连通，那么加入(u,v) 使其连通 * 并查集维护连通性。 * 代码如下： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; using namespace std; int n,m; int fa[1000005]; // fa[x] x在并查集树上的父亲是谁 int get(int x){ // 返回x在并查集树上的根 if(fa[x] == x) return x; return fa[x]=get(fa[x]); // 路径压缩 } void merge(int x,int y){ // 合并x所在集合 和 y所在集合 x=get(x); y=get(y); fa[x]=y; } struct Edge{ int x,y,z; }edge[1000005]; bool cmp(Edge&amp;a,Edge&amp;b){ return a.z&lt;b.z; } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); // 并查集初始化 for(int i=1;i&lt;=n;i++) fa[i]=i; for(int i=1;i&lt;=m;i++){ scanf(&quot;%d%d%d&quot;,&amp;edge[i].x,&amp;edge[i].y,&amp;edge[i].z); } sort(edge+1,edge+m+1,cmp); int sum = 0; for(int i=1;i&lt;=m;i++){ int u=edge[i].x,v=edge[i].y; if(get(u)!=get(v)){ merge(u,v); sum+=edge[i].z; } } printf(&quot;%d&quot;,sum); // 货车运输 /* for(int i=1;i&lt;=m;i++){ // 相同边权的边 int u=edge[i].x,v=edge[i].y; if(get(u)!=get(v)){ // i sum+=edge[i].z; } } for(int i=1;i&lt;=m;i++){ // 相同边权的边 int u=edge[i].x,v=edge[i].y; if(get(u)!=get(v)){ merge(u,v); // i之前是可以 加进MST， 现在不行 sum+=edge[i].z; } } */ return 0; } * POJ 2421 constructing roads * POJ 1789 Truck History * POJ1679 判断最小生成树的唯一性 * 拓扑排序 ---- * 有向无环图 ![有向无环图](https://img-blog.csdn.net/20181004165952791?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNDQwNDg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) * 拓扑序指的是可以把所有点写成一个序列，使得所有边都是从前面的点连向后面的点。 * DAG 可以进行拓扑排序。 * 维护一个入度为0 的顶点的集合，每次从该集合中任意取出一个顶点，将该顶点放入保存结果的List 中。紧接着循环遍历由该顶点引出的所有边，从图中移除这条边，同时获取该边的另外一个顶点，如果该顶点的入度在减去本条边之后为0，那么也将这个顶点放到入度为0 的集合中。然后继续从集合中取出一个顶点，重复操作。 * 当集合为空之后，检查图中是否还存在任何边，如果存在的话，说明图中至少存在一条环路。不存在的话则返回结果List，此List 中的顺序就是对图进行拓扑排序的结果。 * $O(n + m)$ * 代码如下： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; using namespace std; int n,m; // 数组链表 邻接表 // 链表头 链表节点的下一个节点 这条边指向图中的点 int head[10005],nxt[30005], ver[30005]; int tot;// 记录链表节点用了多少个 void add(int x,int y){ // 在x的链表中 加一条指向y的边 ++tot; // 当前链表节点就是编号为tot ver[tot]=y; nxt[tot]=head[x]; head[x]=tot; } int indegree[10005]; int a[10005]; queue&lt;int&gt; q; int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0,x,y;i&lt;m;i++){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y); indegree[y]++; } for(int i=1;i&lt;=n;i++){ if(indegree[i] == 0) q.push(i); } int cnt=0; while(!q.empty()){ int x=q.front();q.pop(); a[++cnt] = x; for(int i=head[x];i;i=nxt[i]){ indegree[ver[i]] -- ; if(indegree[ver[i]]==0){ q.push(ver[i]); } } } for(int i=1;i&lt;=n;i++){ printf(&quot;%d &quot;,a[i]); } return 0; }","link":"/2019/03/09/e6-b8-85-e5-8c-97-e5-ad-a6-e5-a0-82noip2018-e9-9b-86-e8-ae-add4/"}],"tags":[{"name":"精","slug":"精","link":"/tags/精/"},{"name":"LCA","slug":"LCA","link":"/tags/LCA/"},{"name":"图论","slug":"图论","link":"/tags/图论/"},{"name":"Tarjan","slug":"Tarjan","link":"/tags/Tarjan/"},{"name":"数论","slug":"数论","link":"/tags/数论/"},{"name":"dp","slug":"dp","link":"/tags/dp/"},{"name":"树形结构","slug":"树形结构","link":"/tags/树形结构/"},{"name":"优","slug":"优","link":"/tags/优/"},{"name":"字符串","slug":"字符串","link":"/tags/字符串/"},{"name":"搜索","slug":"搜索","link":"/tags/搜索/"},{"name":"背包问题","slug":"背包问题","link":"/tags/背包问题/"},{"name":"最小生成树","slug":"最小生成树","link":"/tags/最小生成树/"},{"name":"区间dp","slug":"区间dp","link":"/tags/区间dp/"},{"name":"状态压缩，状压","slug":"状态压缩，状压","link":"/tags/状态压缩，状压/"},{"name":"拓扑排序","slug":"拓扑排序","link":"/tags/拓扑排序/"},{"name":"并查集","slug":"并查集","link":"/tags/并查集/"},{"name":"枚举","slug":"枚举","link":"/tags/枚举/"},{"name":"前缀和","slug":"前缀和","link":"/tags/前缀和/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"}],"categories":[{"name":"OI","slug":"OI","link":"/categories/OI/"},{"name":"题目","slug":"OI/题目","link":"/categories/OI/题目/"},{"name":"随笔","slug":"随笔","link":"/categories/随笔/"},{"name":"知识点","slug":"OI/知识点","link":"/categories/OI/知识点/"},{"name":"集训","slug":"OI/集训","link":"/categories/OI/集训/"},{"name":"政治","slug":"政治","link":"/categories/政治/"}]}