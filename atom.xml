<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog of YorkWu</title>
  
  <subtitle>山西省实验中学蒟蒻OIer</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yueyangwu.cn/"/>
  <updated>2019-07-13T04:37:54.695Z</updated>
  <id>http://yueyangwu.cn/</id>
  
  <author>
    <name>Yueyang Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>清北学堂noip2019-Day1</title>
    <link href="http://yueyangwu.cn/2019/07/13/%E6%B8%85%E5%8C%97%E5%AD%A6%E5%A0%82noip2019-Day1/"/>
    <id>http://yueyangwu.cn/2019/07/13/清北学堂noip2019-Day1/</id>
    <published>2019-07-13T04:20:33.000Z</published>
    <updated>2019-07-13T04:37:54.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="清北学堂noip2019-Day1"><a href="#清北学堂noip2019-Day1" class="headerlink" title="清北学堂noip2019-Day1"></a>清北学堂noip2019-Day1</h1><a id="more"></a><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><blockquote><p>P.S. 每道题的代码我之后补加。。。</p></blockquote><h3 id="problem-1：Chocolate"><a href="#problem-1：Chocolate" class="headerlink" title="problem 1：Chocolate"></a>problem 1：Chocolate</h3><h4 id="Chocolate"><a href="#Chocolate" class="headerlink" title="Chocolate"></a><a href="https://www.luogu.org/problemnew/show/P2706" target="_blank" rel="noopener">Chocolate</a></h4><p>一块$n\times m$的巧克力， 切成$n\times m$块。</p><p>巧克力上共有$n-1$条横线和$m-1$条竖线，每次沿着一条线将巧克力切开。</p><p>无论切割长短，横线切一次的代价是$y_1,y_2,y_3,…,y_{n-1}$，竖线是$x_1,x_2,x_3,…,x_{m-1}$。</p><p>求最小总代价。</p><p>$n,m\leq 10^5$</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a><a href="https://www.luogu.org/problemnew/solution/P2706" target="_blank" rel="noopener">题解</a></h4><p>横向切会使纵向次数+1，纵向同理。</p><p>所以肯定先切大的，再切小的。</p><p>于是把横纵放到一起排序，依次取最大值统计答案即可。</p><h3 id="problem-2"><a href="#problem-2" class="headerlink" title="problem 2"></a>problem 2</h3><h4 id="USACO-Allowance"><a href="#USACO-Allowance" class="headerlink" title="USACO Allowance"></a><a href="https://www.luogu.org/problemnew/show/P2376" target="_blank" rel="noopener">USACO Allowance</a></h4><ul><li>John决定每个星期给b一点零花钱</li><li>j有一些硬币， 共n种面额。每一个面额都能整除比他大的所有面额。</li><li>他想用给定的硬币集合（给出硬币种类及数量），每个星期至少给b某个零花钱的数目C。</li><li>请计算他最多能给多少星期零花钱。</li></ul><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a><a href="https://www.luogu.org/problemnew/solution/P2376" target="_blank" rel="noopener">题解</a></h4><ul><li><p>阶段一：尽快接近C，用大面额的凑。</p></li><li><p>阶段二：超过C尽量少，用小面额的凑。</p></li><li><p>开始能用大面额就用大面额，直到凑到的$sum + a_i&gt;C$，然后尽量用小的凑，直到$sum+a_i&gt;C$。</p></li></ul><h3 id="problem-3"><a href="#problem-3" class="headerlink" title="problem 3"></a>problem 3</h3><h4 id="Face-the-Right-Way"><a href="#Face-the-Right-Way" class="headerlink" title="Face the Right Way"></a><a href="https://www.luogu.org/problemnew/show/P2882" target="_blank" rel="noopener">Face the Right Way</a></h4><p>给出一个长为n的F/B序列，n&lt;=5000。</p><p>你可以每次选择连续长度为k的一段，进行FB转换。</p><p>使得最后整个序列全为F。</p><p>求最少的操作次数和对应的最小长度。</p><h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a><a href="https://www.luogu.org/problemnew/solution/P2882?page=2" target="_blank" rel="noopener">题解</a></h4><p> 因为同一个点翻转两次就与没有翻转的效果相同了，因此我们有一个贪心策略为：</p><p>左到右对于出现的每一个B翻转一次从当前点开始的区间，就能保证是最优解。</p><p>但是我们会发现这样是$n^2$的，再枚举长度，就变为了$n^3$。</p><p>因此，需要对区间翻转差分一下，总时间复杂度就是$n^2$的了。<br><img src="/p3.png" alt="p3"></p><h3 id="problem-4"><a href="#problem-4" class="headerlink" title="problem 4"></a>problem 4</h3><h4 id="旅行家的预算"><a href="#旅行家的预算" class="headerlink" title="旅行家的预算"></a><a href="https://www.luogu.org/problemnew/show/P1016" target="_blank" rel="noopener">旅行家的预算</a></h4><p>一个旅行家想驾驶汽车以最少的费用从一个城市到另一个城市（假设出发时油箱是空的）。</p><p>给定两个城市之间的距离D1、汽车油箱的容量C（以升为单位）、每升汽油能行驶的距离D2、出发点每升汽油价格P和沿途油站数N（N可以为零），油站i离出发点的距离Di、每升汽油价格Pi（i=1,2,…,N）。</p><p>求最少的综费用，如果无法到达目的地，则输出“No Solution”。</p><h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a><a href="https://www.luogu.org/problemnew/solution/P1016" target="_blank" rel="noopener">题解</a></h4><p>枚举途中经过的加油站，每经过一个加油站，计算一次花费</p><p>在一个加油站所需要加的油，就是能够支持它到达下一个油价比它低的加油站的量</p><p>如果在这个加油站即使加满油，都不能到达一个比它油价低的加油站，就把油箱加满，前往能够到达的加油站中油价最低的那个</p><p>如果在这个加油站即使加满油，都不能到达任意一个加油站，也不能到达终点城市，说明无解</p><h3 id="problem-5"><a href="#problem-5" class="headerlink" title="problem 5"></a>problem 5</h3><h4 id="The-Minima-Game"><a href="#The-Minima-Game" class="headerlink" title="The Minima Game"></a><a href="https://www.luogu.org/problemnew/show/P3507" target="_blank" rel="noopener">The Minima Game</a></h4><p>给出N个正整数，AB两个人轮流取数，A先取。每次可以取任意多个数，直到N个数都被取走。每次获得的得分为取的数中的最小值，A和B的策略都是尽可能使得自己的得分减去对手的得分更大。在这样的情况下，最终A的得分减去B的得分为多少。</p><p>$n\leq 10^5$</p><h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a><a href="https://www.luogu.org/problemnew/solution/P3507" target="_blank" rel="noopener">题解</a></h4><ul><li>身临其境的分析：</li></ul><p>一方面要让自己取的数中的最小值尽量大，</p><p>一方面要让剩下数中的最大值尽量小。</p><p>故先手肯定会从大到小的取数，</p><p>并且取出的数是连续的一段。</p><ul><li><strong>证明：</strong></li></ul><p>从大到小取数显然，若不是连续取数，则留下的数更多，大的数更多，会给对方更多的机会。所以必然是连续取数。</p><ul><li>所以我们倒着来考虑一下，将所有的数从小到大排列之后，f[i]表示两人取完前i个数，先手减去后手的最大值。(这里先手后手是相对的，因为我们是倒序的，和实际取法是完全相反的，它实际上是处理出了1~i个数的情况下的最优解，A先从i开始往左边取，所以说考虑先手减后手最大值）</li></ul><h3 id="problem-6"><a href="#problem-6" class="headerlink" title="problem 6"></a>problem 6</h3><h4 id="ZJOI2005-午餐"><a href="#ZJOI2005-午餐" class="headerlink" title="[ZJOI2005]午餐"></a><a href="https://www.luogu.org/problemnew/show/P2577" target="_blank" rel="noopener">[ZJOI2005]午餐</a></h4><p>N人来到了食堂，每个人由自己的打饭时间和吃饭时间。</p><p>食堂有两个打饭窗口，我们要把所有的人分成两队，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口。每个人打完饭后立刻开始吃。</p><p>现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。 </p><p>两个窗口是并行操作互不影响的，要求输出最佳方案下所有人吃完饭的时刻。</p><h4 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a><a href="https://www.luogu.org/problemnew/solution/P2577" target="_blank" rel="noopener">题解</a></h4><p>贪心的理解，如果所有人都要早点走</p><p>那么吃饭时间长的就先吃，吃饭时间短的就晚点吃</p><p>所以，按照吃饭时间排序</p><p>每个人吃完饭的时间之和前面所有人的打饭的时间和有关</p><p>$f[i][j][k]$表示当前做到第i个人，第一列，第二列前面的人的打饭时间之和分别为$j,k$，最后一个人吃完饭的最小时间.</p><p>但直接三维状态会炸？</p><p>所以，状态是f[i][j]表示当前做到第i个人， 第一列队伍前面所有人打饭的时间和是j时最后一个人吃完饭的最小时间</p><p>如果把这个人放在第一列$f[i][j]=min(f[i][j],max(f[i−1][j−Get[i]],j+eat[i]))$</p><p>另外把这个人放在第二列$f[i][j]=max(f[i−1][j],sum[i]−j+eat[i])$</p><h3 id="problem-7"><a href="#problem-7" class="headerlink" title="problem 7"></a>problem 7</h3><h4 id="Water-Tanks"><a href="#Water-Tanks" class="headerlink" title="Water Tanks"></a>Water Tanks</h4><p>给你一棵树，k升水，p块钱，进行一次游戏。</p><p>在游戏进行前，可以在任意个节点上放置1升水（总数不超过k）</p><p>游戏进行若干轮，每轮游戏开放所有节点，可以选择若干个节点关闭，代价为该节点的水数量。然后所有未关闭节点的水流向它的父亲(不会连续移动)。</p><p>最后，根节点中的水会被取走，水的数量为该轮游戏的盈利。</p><p>求最大盈利-代价。</p><h4 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h4><p>在放置水的选择上，应该尽量选择深度相邻的节点，即将所有节点按照深度排序后，所选择放水的节点应该是连续的一段。</p><p>考虑选择某段区间后，所需要花费的钱。</p><p>假设深度范围[l , r] ，某个深度的点为 a[i] ，则花费钱为sigma(a[i]*(r-i)) </p><p>用两个指针进行扫描即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;清北学堂noip2019-Day1&quot;&gt;&lt;a href=&quot;#清北学堂noip2019-Day1&quot; class=&quot;headerlink&quot; title=&quot;清北学堂noip2019-Day1&quot;&gt;&lt;/a&gt;清北学堂noip2019-Day1&lt;/h1&gt;
    
    </summary>
    
      <category term="OI" scheme="http://yueyangwu.cn/categories/OI/"/>
    
      <category term="集训" scheme="http://yueyangwu.cn/categories/OI/%E9%9B%86%E8%AE%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>清北学堂noip2019-D0</title>
    <link href="http://yueyangwu.cn/2019/07/12/%E6%B8%85%E5%8C%97%E5%AD%A6%E5%A0%82noip2019-D0/"/>
    <id>http://yueyangwu.cn/2019/07/12/清北学堂noip2019-D0/</id>
    <published>2019-07-12T14:36:50.000Z</published>
    <updated>2019-07-12T14:48:17.941Z</updated>
    
    <content type="html"><![CDATA[<h2 id="济南清北学堂游记-Day0"><a href="#济南清北学堂游记-Day0" class="headerlink" title="济南清北学堂游记 Day0"></a>济南清北学堂游记 Day0</h2><a id="more"></a><hr><ul><li>下午1:59的火车，火车上部署了一下hexo blog，搞了一下SEO，结果还是网太慢。。。没搞成</li><li>然后某位同学居然去了另外一个酒店。。。（貌似因为距离大明湖太远？或者我觉得可能只是个借口，反正都这样了，就自己住呗。</li><li>我嫌一个人住太贵，想找个人拼一个标间，于是碰到一位人大附的初二巨佬。。。吊打我八千里开外%%%，然后你们就有了这篇文章。</li><li>准备一会直接洗漱睡了，Day0就这样。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;济南清北学堂游记-Day0&quot;&gt;&lt;a href=&quot;#济南清北学堂游记-Day0&quot; class=&quot;headerlink&quot; title=&quot;济南清北学堂游记 Day0&quot;&gt;&lt;/a&gt;济南清北学堂游记 Day0&lt;/h2&gt;
    
    </summary>
    
      <category term="OI" scheme="http://yueyangwu.cn/categories/OI/"/>
    
      <category term="集训" scheme="http://yueyangwu.cn/categories/OI/%E9%9B%86%E8%AE%AD/"/>
    
    
  </entry>
  
  <entry>
    <title> CodeForces 484 B. Maximum Value</title>
    <link href="http://yueyangwu.cn/2019/06/06/codeforces-484-b-maximum-value/"/>
    <id>http://yueyangwu.cn/2019/06/06/codeforces-484-b-maximum-value/</id>
    <published>2019-06-06T07:05:38.000Z</published>
    <updated>2019-07-12T02:17:57.014Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/problemset/problem/484/B" title="题目链接" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><hr><p>题目翻译：给定序列$a_n$，求$a_i \% a_j$的最大值，$1 \leq i,j \leq n$且$a_i&gt;a_j$。 可以先将输入的数据由小到大排序，如果有相同的数据就去重，然后枚举除数，对于一个除数，从它的二倍开始，直到它大于数列中的最大值。 。。。好不通顺。。。看代码吧。</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; a,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Solution</span>&#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span> n,ans,maxn,q;</span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Solve</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);</span><br><span class="line">        a.resize(n);</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);</span><br><span class="line">            maxn=max(maxn,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a.begin(),a.end());</span><br><span class="line">        n=unique(a.begin(),a.end())-a.begin();</span><br><span class="line">        a.resize(n);</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> k=<span class="hljs-number">2</span>*a[i];</span><br><span class="line">            <span class="hljs-keyword">while</span>(k&lt;maxn+a[i])&#123;</span><br><span class="line">                <span class="hljs-keyword">int</span> x=lower_bound(a.begin(),a.end(),k)-a.begin()<span class="hljs-number">-1</span>;</span><br><span class="line">                <span class="hljs-keyword">if</span>(x==<span class="hljs-number">-1</span>)&#123;</span><br><span class="line">                    k+=a[i];</span><br><span class="line">                    <span class="hljs-keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-comment">//printf("k=%d a[%d]=%d a[x] mod a[i]=%d\n",k,x,a[x],a[x]%a[i]);</span></span><br><span class="line">                ans=max(ans,a[x]%a[i]);</span><br><span class="line">                k+=a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    Solution().Solve();</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://codeforces.com/problemset/problem/484/B&quot; title=&quot;题目链接&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://yueyangwu.cn/categories/OI/"/>
    
      <category term="题目" scheme="http://yueyangwu.cn/categories/OI/%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="精" scheme="http://yueyangwu.cn/tags/%E7%B2%BE/"/>
    
  </entry>
  
  <entry>
    <title> Luogu P1983 车站分级		</title>
    <link href="http://yueyangwu.cn/2019/06/03/luogu-p1983-e8-bd-a6-e7-ab-99-e5-88-86-e7-ba-a7/"/>
    <id>http://yueyangwu.cn/2019/06/03/luogu-p1983-e8-bd-a6-e7-ab-99-e5-88-86-e7-ba-a7/</id>
    <published>2019-06-03T01:36:43.000Z</published>
    <updated>2019-07-11T17:27:36.350Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1983" title="题目链接" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><hr><p>又是一道比较经典的题，据说有什么线段树优化构造。。。反正我是不懂。 这道题使用topsort（拓扑排序）的思想；</p><ul><li>简化题意：n个车站，每个车站有一个级别，如果有一趟列车，这趟列车经过$a_1,a_2,···,a_s$站，且如果这些站中级别最低的车站的级别为$minx$，那么所有在起点站到终点站之间级别大于等于$minx$的车站都必须停靠。那么m趟列车，给定每趟列车的经过站（车站编号升序给出），求所有车站至少分成多少级。</li><li>思路：如果从起点站到终点站之间有火车站没有停靠，就说明这个火车站的级别一定小于所有停靠了的火车站，那么就将每个没有停靠的火车站向停靠的火车站连一条边，这样用topsort的思想，可算出最终分成了几层，便是最少的级别数量；</li><li>例如数据 1 3 5 6停靠 <img src="http://yueyangwu.cn/wp-content/uploads/2019/06/56401.png" alt="1" title="1"></li></ul><p>代码如下</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n,m,a[<span class="hljs-number">1009</span>],cd[<span class="hljs-number">1009</span>],st[<span class="hljs-number">1009</span>];</span><br><span class="line"><span class="hljs-keyword">bool</span> v[<span class="hljs-number">1009</span>],top[<span class="hljs-number">1009</span>][<span class="hljs-number">1009</span>],del[<span class="hljs-number">1009</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="hljs-built_in">memset</span>(v,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(v));</span><br><span class="line">        <span class="hljs-keyword">int</span> s;</span><br><span class="line">        <span class="hljs-built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=s;j++)&#123;</span><br><span class="line">            <span class="hljs-built_in">cin</span>&gt;&gt;a[j];</span><br><span class="line">            v[a[j]]=<span class="hljs-number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=a[<span class="hljs-number">1</span>];j&lt;=a[s];j++)&#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(!v[j])&#123;</span><br><span class="line">                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=s;k++)&#123;</span><br><span class="line">                    <span class="hljs-keyword">if</span>(top[a[k]][j]) <span class="hljs-keyword">continue</span>;</span><br><span class="line">                    top[a[k]][j]=<span class="hljs-number">1</span>;</span><br><span class="line">                    cd[a[k]]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">int</span> r=<span class="hljs-number">1</span>,ans=<span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span>(r)&#123;</span><br><span class="line">        r=<span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(cd[i]==<span class="hljs-number">0</span>&amp;&amp;!del[i])&#123;</span><br><span class="line">                st[++r]=i;</span><br><span class="line">                del[i]=<span class="hljs-number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span>(r) ans++;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=r;i++)&#123;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="hljs-keyword">if</span>(!top[j][st[i]]) <span class="hljs-keyword">continue</span>;</span><br><span class="line">                top[j][st[i]]=<span class="hljs-number">0</span>;</span><br><span class="line">                cd[j]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1983&quot; title=&quot;题目链接&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://yueyangwu.cn/categories/OI/"/>
    
      <category term="题目" scheme="http://yueyangwu.cn/categories/OI/%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="精" scheme="http://yueyangwu.cn/tags/%E7%B2%BE/"/>
    
      <category term="图论" scheme="http://yueyangwu.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="拓扑排序" scheme="http://yueyangwu.cn/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title> Luogu P2948 [USACO09OPEN]滑雪课Ski Lessons		</title>
    <link href="http://yueyangwu.cn/2019/06/01/luogu-p2948-usaco09open-e6-bb-91-e9-9b-aa-e8-af-beski-lessons/"/>
    <id>http://yueyangwu.cn/2019/06/01/luogu-p2948-usaco09open-e6-bb-91-e9-9b-aa-e8-af-beski-lessons/</id>
    <published>2019-06-01T01:32:17.000Z</published>
    <updated>2019-07-11T17:29:23.230Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2948" title="题目链接" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><hr><p>现在这蓝题都不好想啊qwq 设计状态：$f[i][j]$表示到一门课程结束时间为$i$，能力值为$j$的最多滑雪次数。 所以先给课程按结束时间排个序。 转移： 1. $dp[x][y]=max(dp[x][y],dp[x2][y2]+q)$，$q$是从上节课的结束时刻到这节课的开始时刻的最多滑雪次数。 2. $dp[x][y2]=dp[x2][y2]+(x-x2)/minn[y2]$，$minn[i]$是能力值为i时的最小滑雪时间； 代码：</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> t,s,n;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clas</span>&#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span> begin,end;</span><br><span class="line">    <span class="hljs-keyword">int</span> v;</span><br><span class="line">&#125;c[<span class="hljs-number">109</span>];</span><br><span class="line"><span class="hljs-keyword">int</span> a[<span class="hljs-number">10009</span>][<span class="hljs-number">2</span>],minn[<span class="hljs-number">10009</span>];</span><br><span class="line"><span class="hljs-keyword">int</span> f[<span class="hljs-number">10009</span>][<span class="hljs-number">109</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(clas x,clas y)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> x.end&lt;y.end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">cin</span>&gt;&gt;t&gt;&gt;s&gt;&gt;n;</span><br><span class="line">    <span class="hljs-built_in">memset</span>(minn,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span>(minn));</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=s;i++)&#123;</span><br><span class="line">        <span class="hljs-built_in">cin</span>&gt;&gt;c[i].begin&gt;&gt;c[i].end&gt;&gt;c[i].v;</span><br><span class="line">        c[i].end+=c[i].begin;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="hljs-built_in">cin</span>&gt;&gt;a[i][<span class="hljs-number">0</span>]&gt;&gt;a[i][<span class="hljs-number">1</span>];</span><br><span class="line">        minn[a[i][<span class="hljs-number">0</span>]]=min(minn[a[i][<span class="hljs-number">0</span>]],a[i][<span class="hljs-number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span>;i++) minn[i]=min(minn[i],minn[i<span class="hljs-number">-1</span>]);</span><br><span class="line">    sort(c+<span class="hljs-number">1</span>,c+s+<span class="hljs-number">1</span>,cmp);</span><br><span class="line">    c[<span class="hljs-number">0</span>].v=<span class="hljs-number">1</span>,c[<span class="hljs-number">0</span>].begin=<span class="hljs-number">0</span>,c[<span class="hljs-number">0</span>].end=<span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=s;i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> ti1=c[i].end,v1=c[i].v;</span><br><span class="line">            <span class="hljs-keyword">int</span> ti2=c[j].end,v2=c[j].v;</span><br><span class="line">            <span class="hljs-keyword">if</span>(ti2&lt;c[i].begin) f[ti1][v1]=max(f[ti1][v1],f[ti2][v2]+(c[i].begin-ti2)/minn[v2]);</span><br><span class="line">            f[ti1][v2]=max(f[ti1][v2],f[ti2][v2]+(ti1-ti2)/minn[v2]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=s;i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> ti=c[i].end,v=c[i].v;</span><br><span class="line">        f[t][v]=max(f[t][v],f[ti][v]+(t-ti)/minn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=s;i++) ans=max(ans,f[t][c[i].v]);</span><br><span class="line">    <span class="hljs-built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P2948&quot; title=&quot;题目链接&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://yueyangwu.cn/categories/OI/"/>
    
      <category term="题目" scheme="http://yueyangwu.cn/categories/OI/%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="精" scheme="http://yueyangwu.cn/tags/%E7%B2%BE/"/>
    
      <category term="dp" scheme="http://yueyangwu.cn/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title> Luogu P1875 佳佳的魔法药水		</title>
    <link href="http://yueyangwu.cn/2019/06/01/luogu-p1875-e4-bd-b3-e4-bd-b3-e7-9a-84-e9-ad-94-e6-b3-95-e8-8d-af-e6-b0-b4/"/>
    <id>http://yueyangwu.cn/2019/06/01/luogu-p1875-e4-bd-b3-e4-bd-b3-e7-9a-84-e9-ad-94-e6-b3-95-e8-8d-af-e6-b0-b4/</id>
    <published>2019-06-01T00:19:54.000Z</published>
    <updated>2019-07-11T17:27:10.958Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1875" title="链接" target="_blank" rel="noopener">链接</a></p><a id="more"></a><hr><p>图论，明显是dijkstra，$d[i]$数组保存第$i$个药水的最小配置价格，$cnt[i]$保存第$i$个药水最小配置价格的方案数，具体过程： 1. 每次找一个没有访问过的配置价格最小的药水$x$。 2. 枚举所有可以和$x$组成新药水的药水$i$并且已经访问过的节点。 3. 如果$x$和$i$组成的新药水的最小配置价格$d[j]&lt;d[x]+d[i]$，那就更新，并且$cnt[j]=cnt[x] \times cnt[i]$ 4. 否则如果$d[j]=d[x]+d[i]$，那么$cnt[j]+=cnt[i] \times cnt[x]$ 代码：</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n,m;</span><br><span class="line"><span class="hljs-keyword">int</span> a[<span class="hljs-number">1509</span>][<span class="hljs-number">1509</span>];</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span> x,y;</span><br><span class="line">    <span class="hljs-keyword">bool</span> v;</span><br><span class="line">&#125;d[<span class="hljs-number">1509</span>][<span class="hljs-number">1509</span>];</span><br><span class="line"><span class="hljs-keyword">bool</span> flag=<span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> yc[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;,xc[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> rx,<span class="hljs-keyword">int</span> ry)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span>(d[x][y].v&amp;&amp;(d[x][y].x!=rx||d[x][y].y!=ry))&#123;</span><br><span class="line">        flag=<span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    d[x][y].x=x,d[x][y].y=y,d[x][y].v=<span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> nx,ny;</span><br><span class="line">        <span class="hljs-keyword">if</span>(x+xc[i]==<span class="hljs-number">0</span>) nx=n;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x+xc[i]==n+<span class="hljs-number">1</span>) nx=<span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">else</span> nx=x+xc[i];</span><br><span class="line">        <span class="hljs-keyword">if</span>(y+yc[i]==<span class="hljs-number">0</span>) ny=m;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(y+yc[i]==m+<span class="hljs-number">1</span>) ny=<span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">else</span> ny=y+yc[i];</span><br><span class="line">        <span class="hljs-keyword">int</span> nrx=rx+xc[i],nry=ry+yc[i];</span><br><span class="line">        <span class="hljs-keyword">if</span>(!a[nx][ny]&amp;&amp;(d[nx][ny].x!=nrx||d[nx][ny].y!=nry||!d[nx][ny].v))&#123;</span><br><span class="line">            dfs(nx,ny,nrx,nry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    node start;</span><br><span class="line">    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        flag=<span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="hljs-built_in">string</span> c;</span><br><span class="line">            <span class="hljs-built_in">cin</span>&gt;&gt;c;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                d[i][j].x=<span class="hljs-number">0</span>,d[i][j].y=<span class="hljs-number">0</span>,d[i][j].v=<span class="hljs-number">0</span>;</span><br><span class="line">                a[i][j]=<span class="hljs-number">0</span>;</span><br><span class="line">                <span class="hljs-keyword">if</span>(c[j<span class="hljs-number">-1</span>]==<span class="hljs-string">'#'</span>) a[i][j]=<span class="hljs-number">1</span>;</span><br><span class="line">                <span class="hljs-keyword">if</span>(c[j<span class="hljs-number">-1</span>]==<span class="hljs-string">'S'</span>) start.x=i,start.y=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(start.x,start.y,start.x,start.y);</span><br><span class="line">        <span class="hljs-keyword">if</span>(flag) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Yes"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"No"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1875&quot; title=&quot;链接&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://yueyangwu.cn/categories/OI/"/>
    
      <category term="题目" scheme="http://yueyangwu.cn/categories/OI/%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="图论" scheme="http://yueyangwu.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="优" scheme="http://yueyangwu.cn/tags/%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title> Luogu P1363 幻想迷宫		</title>
    <link href="http://yueyangwu.cn/2019/05/31/luogu-p1363-e5-b9-bb-e6-83-b3-e8-bf-b7-e5-ae-ab/"/>
    <id>http://yueyangwu.cn/2019/05/31/luogu-p1363-e5-b9-bb-e6-83-b3-e8-bf-b7-e5-ae-ab/</id>
    <published>2019-05-31T12:58:04.000Z</published>
    <updated>2019-07-11T17:25:23.768Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1363" title="链接" target="_blank" rel="noopener">链接</a></p><a id="more"></a><hr><p>看完题目，最开始的思路是先对图进行搜索，然后搜索在边界的位置是否有道路可以通向这张图对面相同的位置，但是这样的情况就判断不了。</p><pre><code>S.#..######...#</code></pre><p>很明显这张图中上面的道路和下面的道路并不直接相连，但是却可以无限延伸。 所以我看了题解。。。 掌嘴。。。 我好菜啊。。。 心里好慌。。。 然后就是搜索，每一个点向四个方向搜，如果搜到边界，用取模的方式到这张地图的另外一边，同时保存其真实的坐标，这样一来，当真实坐标和这个位置上次访问到的坐标不同时，说明这个点访问了两次，就是说可以无限延伸。 具体看代码吧</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n,m;</span><br><span class="line"><span class="hljs-keyword">int</span> a[<span class="hljs-number">1509</span>][<span class="hljs-number">1509</span>];</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span> x,y;</span><br><span class="line">    <span class="hljs-keyword">bool</span> v;</span><br><span class="line">&#125;d[<span class="hljs-number">1509</span>][<span class="hljs-number">1509</span>];</span><br><span class="line"><span class="hljs-keyword">bool</span> flag=<span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> yc[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;,xc[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> rx,<span class="hljs-keyword">int</span> ry)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span>(d[x][y].v&amp;&amp;(d[x][y].x!=rx||d[x][y].y!=ry))&#123;</span><br><span class="line">        flag=<span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    d[x][y].x=rx,d[x][y].y=ry,d[x][y].v=<span class="hljs-number">1</span>;<span class="hljs-comment">//这里更新一下相当于上次访问到的真实坐标。</span></span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> nx,ny;</span><br><span class="line">        <span class="hljs-keyword">if</span>(x+xc[i]==<span class="hljs-number">0</span>) nx=n;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x+xc[i]==n+<span class="hljs-number">1</span>) nx=<span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">else</span> nx=x+xc[i];</span><br><span class="line">        <span class="hljs-keyword">if</span>(y+yc[i]==<span class="hljs-number">0</span>) ny=m;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(y+yc[i]==m+<span class="hljs-number">1</span>) ny=<span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">else</span> ny=y+yc[i];</span><br><span class="line">        <span class="hljs-keyword">int</span> nrx=rx+xc[i],nry=ry+yc[i];</span><br><span class="line">        <span class="hljs-keyword">if</span>(!a[nx][ny]&amp;&amp;(d[nx][ny].x!=nrx||d[nx][ny].y!=nry||!d[nx][ny].v))&#123;</span><br><span class="line">            dfs(nx,ny,nrx,nry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    node start;</span><br><span class="line">    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        flag=<span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="hljs-built_in">string</span> c;</span><br><span class="line">            <span class="hljs-built_in">cin</span>&gt;&gt;c;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                d[i][j].x=<span class="hljs-number">0</span>,d[i][j].y=<span class="hljs-number">0</span>,d[i][j].v=<span class="hljs-number">0</span>;</span><br><span class="line">                a[i][j]=<span class="hljs-number">0</span>;</span><br><span class="line">                <span class="hljs-keyword">if</span>(c[j<span class="hljs-number">-1</span>]==<span class="hljs-string">'#'</span>) a[i][j]=<span class="hljs-number">1</span>;</span><br><span class="line">                <span class="hljs-keyword">if</span>(c[j<span class="hljs-number">-1</span>]==<span class="hljs-string">'S'</span>) start.x=i,start.y=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(start.x,start.y,start.x,start.y);</span><br><span class="line">        <span class="hljs-keyword">if</span>(flag) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Yes"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"No"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1363&quot; title=&quot;链接&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://yueyangwu.cn/categories/OI/"/>
    
      <category term="题目" scheme="http://yueyangwu.cn/categories/OI/%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="图论" scheme="http://yueyangwu.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="搜索" scheme="http://yueyangwu.cn/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title> Luogu P1896 [SCOI2005]互不侵犯		</title>
    <link href="http://yueyangwu.cn/2019/05/28/luogu-p1896-scoi2005-e4-ba-92-e4-b8-8d-e4-be-b5-e7-8a-af/"/>
    <id>http://yueyangwu.cn/2019/05/28/luogu-p1896-scoi2005-e4-ba-92-e4-b8-8d-e4-be-b5-e7-8a-af/</id>
    <published>2019-05-28T13:01:45.000Z</published>
    <updated>2019-07-11T17:27:22.469Z</updated>
    
    <content type="html"><![CDATA[<p>我感觉这道题还不错，状压dp的一类典型问题？ <a href="https://www.luogu.org/problemnew/show/P1896" title="题目链接" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><hr><p>就是给个n*n的表格，然后放k个旗子，旗子每个旗子相邻的8个格子不能放旗子。问最多有几种放的方法。 状态就是$f[i][j][k]$表示第i行，状态为j，并且已经放了k个格子的方案总数。然后预处理一下can数组，保存左右互不侵犯的状态。再预处理$gs[i]$数组表示状态为i的有多少个旗子(i的二进制里有多少个1)。 这样枚举上一行状态，如果上一行和这一行满足左上，上，右上互不侵犯，那么$f[i][j][k+gs[i]]+=f[i-1][l][k]$ 最终答案就是所有$f[n][i][k]$的和。</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n,k;</span><br><span class="line">ll f[<span class="hljs-number">10</span>][<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>][<span class="hljs-number">90</span>],can[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>],tot;</span><br><span class="line"><span class="hljs-keyword">int</span> gs[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span>(x)&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>&amp;x) cnt++;</span><br><span class="line">        x&gt;&gt;=<span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> gs[tot]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i++) <span class="hljs-keyword">if</span>(!(i&amp;(i&lt;&lt;<span class="hljs-number">1</span>))) can[++tot]=i,f[<span class="hljs-number">1</span>][tot][gs1(i)]=<span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=tot;j++)&#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> a=can[j];</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>;l&lt;=tot;l++)&#123;</span><br><span class="line">                <span class="hljs-keyword">int</span> b=can[l];</span><br><span class="line">                <span class="hljs-keyword">if</span>(a&amp;b) <span class="hljs-keyword">continue</span>;</span><br><span class="line">                <span class="hljs-keyword">if</span>(a&amp;(b&lt;&lt;<span class="hljs-number">1</span>)) <span class="hljs-keyword">continue</span>;</span><br><span class="line">                <span class="hljs-keyword">if</span>(a&amp;(b&gt;&gt;<span class="hljs-number">1</span>)) <span class="hljs-keyword">continue</span>;</span><br><span class="line">                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> g=<span class="hljs-number">0</span>;g+gs[j]&lt;=k;g++) f[i][j][gs[j]+g]+=f[i<span class="hljs-number">-1</span>][l][g];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=tot;i++) ans+=f[n][i][k];</span><br><span class="line">    <span class="hljs-built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我感觉这道题还不错，状压dp的一类典型问题？ &lt;a href=&quot;https://www.luogu.org/problemnew/show/P1896&quot; title=&quot;题目链接&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://yueyangwu.cn/categories/OI/"/>
    
      <category term="题目" scheme="http://yueyangwu.cn/categories/OI/%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="dp" scheme="http://yueyangwu.cn/tags/dp/"/>
    
      <category term="状态压缩，状压" scheme="http://yueyangwu.cn/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%EF%BC%8C%E7%8A%B6%E5%8E%8B/"/>
    
  </entry>
  
  <entry>
    <title> Luogu P1026 统计单词个数		</title>
    <link href="http://yueyangwu.cn/2019/05/28/luogu-p1026-e7-bb-9f-e8-ae-a1-e5-8d-95-e8-af-8d-e4-b8-aa-e6-95-b0/"/>
    <id>http://yueyangwu.cn/2019/05/28/luogu-p1026-e7-bb-9f-e8-ae-a1-e5-8d-95-e8-af-8d-e4-b8-aa-e6-95-b0/</id>
    <published>2019-05-28T12:42:23.000Z</published>
    <updated>2019-07-11T17:22:46.451Z</updated>
    
    <content type="html"><![CDATA[<p>这两天都忙得忘了写了。。。 今天把这几天做的好题都补一下吧。。。 <a href="https://www.luogu.org/problemnew/show/P1026" title="题目链接" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><hr><p>老实说，这道题已经困扰我好几个月了，刚学dp就知道这道题，现在才做出来，所以准备写一下。。 题意大概就是给一个字符串，和一堆单词，问把这个字符串分成k段后，每段的单词数量的和的最大值是多少。 这道题用string的几个方法非常方便。 - <string>1.find(<string>2)在第一个字符串中查找字符串2，并返回第一个下标，如果不存在，返回1844674407370955161这是个什么鬼东西我也不知道。 - <string>.substr(x,len)取出字符串中以x开头长度为len的一个子字符串。 设计状态：$f[i][k]$代表前i个字符分成k段的最大单词总数。 转移：$f[i][k]=max(f[i][k],f[j][k-1]+sum[j+1][i])$枚举断点j，$sum[i][j]$代表原字符串从i到j的单词总数，先预处理一下。 剩下的看代码吧：</string></string></string></p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n,k,m;</span><br><span class="line"><span class="hljs-built_in">string</span> s,x;</span><br><span class="line"><span class="hljs-built_in">string</span> d[<span class="hljs-number">8</span>];</span><br><span class="line"><span class="hljs-keyword">int</span> dl[<span class="hljs-number">8</span>],sum[<span class="hljs-number">209</span>][<span class="hljs-number">209</span>];</span><br><span class="line"><span class="hljs-keyword">int</span> dp[<span class="hljs-number">209</span>][<span class="hljs-number">49</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">pd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">string</span> x=s.substr(l,r-l+<span class="hljs-number">1</span>);</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(x.find(d[i])==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    s=<span class="hljs-string">"0"</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="hljs-built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        s=s+x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">cin</span>&gt;&gt;m;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="hljs-built_in">cin</span>&gt;&gt;d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">int</span> len=s.length()<span class="hljs-number">-1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=len;i&gt;=<span class="hljs-number">1</span>;i--)&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&gt;=<span class="hljs-number">1</span>;j--)&#123;</span><br><span class="line">            sum[j][i]=sum[j+<span class="hljs-number">1</span>][i];</span><br><span class="line">            <span class="hljs-keyword">if</span>(pd(j,i)) sum[j][i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++) dp[i][<span class="hljs-number">1</span>]=sum[<span class="hljs-number">1</span>][i];</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> q=<span class="hljs-number">1</span>;q&lt;=k;q++)&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=q+<span class="hljs-number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=q;j&lt;i;j++)&#123;</span><br><span class="line">                dp[i][q]=max(dp[i][q],dp[j][q<span class="hljs-number">-1</span>]+sum[j+<span class="hljs-number">1</span>][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">cout</span>&lt;&lt;dp[len][k];</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天都忙得忘了写了。。。 今天把这几天做的好题都补一下吧。。。 &lt;a href=&quot;https://www.luogu.org/problemnew/show/P1026&quot; title=&quot;题目链接&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://yueyangwu.cn/categories/OI/"/>
    
      <category term="题目" scheme="http://yueyangwu.cn/categories/OI/%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="dp" scheme="http://yueyangwu.cn/tags/dp/"/>
    
      <category term="优" scheme="http://yueyangwu.cn/tags/%E4%BC%98/"/>
    
      <category term="字符串" scheme="http://yueyangwu.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title> Luogu P1073 最优贸易		</title>
    <link href="http://yueyangwu.cn/2019/05/21/luogu-p1073-e6-9c-80-e4-bc-98-e8-b4-b8-e6-98-93/"/>
    <id>http://yueyangwu.cn/2019/05/21/luogu-p1073-e6-9c-80-e4-bc-98-e8-b4-b8-e6-98-93/</id>
    <published>2019-05-21T03:36:58.000Z</published>
    <updated>2019-07-11T17:23:06.976Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1073" title="题目链接" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><hr><p>这道题没太明白。。。 题解好多种方法，我就看了看第一种方法。 动态规划+dfs $f[x]$表示到x节点所能拿到差价的最大值。 状态转移方程：$f[x]=max(f[fa],c[x]-minx)$ $c[x],minx$分别是x节点的售价和到x节点的路上的最小售价。 剩下的写注释吧。 代码：</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n,m,w[<span class="hljs-number">100009</span>];</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span> to,nxt;</span><br><span class="line">&#125;e[<span class="hljs-number">1000009</span>];</span><br><span class="line"><span class="hljs-keyword">int</span> head[<span class="hljs-number">100009</span>],tot;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> f[<span class="hljs-number">100009</span>],minn[<span class="hljs-number">100009</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    e[++tot].to=y;</span><br><span class="line">    e[tot].nxt=head[x];</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fa,<span class="hljs-keyword">int</span> minx)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> pd=<span class="hljs-number">1</span>;<span class="hljs-comment">//这个就是判断要不要继续找下去的一个变量。</span></span><br><span class="line">    minx=min(minx,w[x]);<span class="hljs-comment">//更新minx</span></span><br><span class="line">    <span class="hljs-keyword">if</span>(minx&lt;minn[x]) minn[x]=minx,pd=<span class="hljs-number">0</span>;<span class="hljs-comment">//minn保存的是到x节点最小值，这里就是如果最小值小于上一次访问这个节点的最小值，就更新。</span></span><br><span class="line">    <span class="hljs-keyword">int</span> maxx=max(f[fa],w[x]-minx);<span class="hljs-comment">//dp</span></span><br><span class="line">    <span class="hljs-keyword">if</span>(f[x]&lt;maxx) f[x]=maxx,pd=<span class="hljs-number">0</span>;<span class="hljs-comment">//这里是如果这次最大值大于上次访问这个节点时候的最大值，就要把这个新的值传递下去，直到全部传递完。</span></span><br><span class="line">    <span class="hljs-comment">//其实就是这里不太明白。。。</span></span><br><span class="line">    <span class="hljs-keyword">if</span>(pd) <span class="hljs-keyword">return</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[x];i;i=e[i].nxt)&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> y=e[i].to;</span><br><span class="line">        dfs(y,x,minx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="hljs-built_in">memset</span>(minn,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span>(minn));</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">cin</span>&gt;&gt;w[i];</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> x,y,op;</span><br><span class="line">        <span class="hljs-built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;op;</span><br><span class="line">        <span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>) add(x,y);</span><br><span class="line">        <span class="hljs-keyword">else</span> add(x,y),add(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0x3f3f3f3f</span>);</span><br><span class="line">    <span class="hljs-built_in">cout</span>&lt;&lt;f[n];</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1073&quot; title=&quot;题目链接&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://yueyangwu.cn/categories/OI/"/>
    
      <category term="题目" scheme="http://yueyangwu.cn/categories/OI/%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="精" scheme="http://yueyangwu.cn/tags/%E7%B2%BE/"/>
    
      <category term="图论" scheme="http://yueyangwu.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="dp" scheme="http://yueyangwu.cn/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title> Luogu P3916 图的遍历		</title>
    <link href="http://yueyangwu.cn/2019/05/16/luogu-p3916-e5-9b-be-e7-9a-84-e9-81-8d-e5-8e-86/"/>
    <id>http://yueyangwu.cn/2019/05/16/luogu-p3916-e5-9b-be-e7-9a-84-e9-81-8d-e5-8e-86/</id>
    <published>2019-05-16T12:11:11.000Z</published>
    <updated>2019-07-11T17:29:57.446Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3916" title="题目链接" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><hr><p>又是一道神奇的题目，题目问从每个点能到达的编号最大的点，相当于一到多，这样可以建反向边，然后跑dfs。 每个点跑一遍dfs，从n到1循环。 代码：</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n,m,ans[<span class="hljs-number">100009</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span> to,nxt;</span><br><span class="line">&#125;e[<span class="hljs-number">100009</span>];</span><br><span class="line"><span class="hljs-keyword">int</span> head[<span class="hljs-number">100009</span>],tot;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    e[++tot].to=y;</span><br><span class="line">    e[tot].nxt=head[x];</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(ans[x]!=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;</span><br><span class="line">    ans[x]=fa;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[x];i;i=e[i].nxt)&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> y=e[i].to;</span><br><span class="line">        <span class="hljs-keyword">if</span>(ans[y]==<span class="hljs-number">0</span>) dfs(y,fa);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> x,y;</span><br><span class="line">        <span class="hljs-built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        add(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)&#123;</span><br><span class="line">        dfs(i,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="hljs-built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="hljs-string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P3916&quot; title=&quot;题目链接&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://yueyangwu.cn/categories/OI/"/>
    
      <category term="题目" scheme="http://yueyangwu.cn/categories/OI/%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="图论" scheme="http://yueyangwu.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="优" scheme="http://yueyangwu.cn/tags/%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title> 美国贸易战的实质是遏制中国！The essence of the US trade war is to contain China！		</title>
    <link href="http://yueyangwu.cn/2019/05/16/e7-be-8e-e5-9b-bd-e8-b4-b8-e6-98-93-e6-88-98-e7-9a-84-e5-ae-9e-e8-b4-a8-e6-98-af-e9-81-8f-e5-88-b6-e4-b8-ad-e5-9b-bd-ef-bc-81the-essence-of-the-us-trade-war-is-to-contain-china-ef-bc-81/"/>
    <id>http://yueyangwu.cn/2019/05/16/e7-be-8e-e5-9b-bd-e8-b4-b8-e6-98-93-e6-88-98-e7-9a-84-e5-ae-9e-e8-b4-a8-e6-98-af-e9-81-8f-e5-88-b6-e4-b8-ad-e5-9b-bd-ef-bc-81the-essence-of-the-us-trade-war-is-to-contain-china-ef-bc-81/</id>
    <published>2019-05-16T06:26:43.000Z</published>
    <updated>2019-07-12T02:51:03.749Z</updated>
    
    <content type="html"><![CDATA[<p>打开看看？</p><a id="more"></a><p>当大部分人都预期中美贸易磋商即将迎来曙光的时候，美国政客又一次极力诋毁和指责中国，并不顾双方在加强知识产权保护、扩大市场准入、促进双边贸易平衡等方面取得的实质性进展，单方面举起关税大棒，开始对2000亿美元中国输美商品的关税从10%上调至25%，使眼看就要拨云见日的中美经贸磋商瞬间阴云密布。 　　美国政客的极限施压再次惊醒了中美贸易战这头“灰犀牛”，引发了全球投资者的极度不安，全球股票市场均呈现大幅下跌。 　　（一） 　　美国政客为自己的关税大棒找了个说法，声称中国要对之前谈判达成的条款进行重新协商。即使如特朗普先生所言，中国对谈判的文本提出修改意见，这也是中方的基本权利。 　　要知道，中美之间进行的是经贸磋商，磋商就是一个反复商量的过程，就是双方不断讨价还价的过程。你想要什么就给什么，那不是磋商，那是“一边倒”的压服。 　　中国人民历史上被西方列强强加过很多不平等条约，新中国成立后，中国人民好不容易挣脱了这些不平等条约。今天的中国，再也不愿意，也不可能接受新的不平等条约。 　　实际上，中美经贸磋商中一再出尔反尔的倒是美国。2017年11月，特朗普访华，两国元首表示，双方将继续致力于互利共赢的中美经贸合作，中美双方签署了高达2535亿美元的经贸合作协议。但4个月后，2018年3月22日，特朗普就指示美国贸易代表办公室要对中国商品加征关税，要限制中国投资。 　　2018年5月19日，经过艰苦努力，中美达成“不打贸易战，并停止互相加征关税”的共识，并对外发表了联合声明。但仅仅10天后，美国突然宣布将于6月15日公布将被征收25%关税的500亿美元中国产品最终名单，公然违背双方刚达成的共识。如果按照特朗普先生的做法，同美国打交道必然无言可信。 　　再扯远一点，美国在信守承诺上可是劣迹斑斑，他连正在执行中的协议都可以撕毁。比如说最近闹得比较凶的伊朗核问题，之所以横生波澜，就是美国单方面撕毁了伊核协议。要知道这份协议是美国政府自己主导签订的，是联合国安理会一致通过的。美国经常指责中国不遵守承诺，但其实常常不遵守承诺的是他自己。 　　（二） 　　那么美国为什么此时又抡起关税大棒呢？答案应该是美国想从中国身上压榨到更多的利益，想用关税搅乱中国的发展信心。在中美经贸摩擦中，要看透美国行为的本质。美国人看似和我国在谈经贸，但其很多要求早已超出经贸范畴，醉翁之意不在酒，在于遏制中国，在于搅乱中国的发展。 　　对于遏制中国，美国是一以贯之的，只不过不同时期，遏制手段不同而已。以前是制裁、封锁、轰炸使馆等等，今天成了贸易战。 　　美国之所以发起贸易战，其声称的理由是美中贸易不平衡，是美国对华贸易逆差。但其实美国人都清楚，贸易战也许会减少对华贸易逆差，但不可能减少美国的贸易逆差。 　　美国哈佛大学教授，曾经担任过副国务卿的哈珀教授就明确指出，关税不可能减少美国贸易逆差。“特朗普政府一旦真的对中国商品大规模征税，这部分进口来源只会转移到其他经济体，例如孟加拉国、越南等国都会快速替补空缺，因而征收高额关税并不能减少美国逆差总额。” 　　所以，美国关税真正的指向并不是减少其逆差，而是减少中国出口，减少中国顺差，进而遏制我国发展。 　　说白了，美国是不愿意看到中国的发展，中国的强大的。美国政府多次表达了维持“美国第一”的强烈意愿。特朗普曾明确讲：“当我上任时，我们面临的问题是，中国将在非常短的时间内超过我们。但那种情况不会再发生了。”为什么不会再发生了？因为美国正在不遗余力地予以遏制，而且他相信，他能像当年打击日本一样，成功地通过贸易战遏制中国发展势头。在遏制中国发展上，特朗普不是第一人，可能也不是最后一人。 　　美国一位前总统就曾经明确说过：“如果超过十亿的中国居民也像澳大利亚人、美国人现在这样生活，那么我们所有人都将陷入十分悲惨的境地，因为那是这个星球所无法承受的”。 　　而要遏制中国发展，最有效的就是打掉中国的制度优势。美国人对此清楚得很，便假借经贸之手，挥舞关税大棒，意图逼迫中国签署城下之盟，放弃制度优势。 　　但中国早已不是100年前之中国，经贸问题可以谈，但以贸易为幌子对我国的政治体制、对我国的主权行为横加干预，这是我们绝对不能接受的。 　　（三） 　　在经贸磋商中，美国之所以敢不断抡大棒，不断进行极限施压，其所凭借的是中美之间贸易的不对称性。美国的子弹似乎比我们多。但是，手中子弹的多少并不能决定战争的胜负，战争的胜负还要看双方的意志，双方的精神，双方的耐力。 　　遥想当年抗美援朝，志愿军用单衣加土豆加步枪，就打败了拥有当时最精良装备的美国军队。当时，中国手里的子弹不知比现在少多少，但我们还是取得了胜利。 　　自古以来，中国就不是一个任人欺凌的国家，中国人民自古就有伟大的抗争精神。 　　今天，中国不仅有伟大的斗争精神，我们还有强大的斗争能力。 　　中国人珍视和平，以和为贵，但也不会委屈求和。 　　“朋友来了有好酒，豺狼来了有猎枪”，谈，我们好酒相迎，打，我们也不怕，猎枪有的是。 　　中国人不惹事，但也不怕事，该亮剑时必亮剑。（文/陈壮） (责编：白宇) When most people anticipate the dawn of Sino-US trade negotiations, American politicians once again vigorously denigrate and accuse China of unilaterally raising tariff sticks and raising tariffs on $200 billion of Chinese goods exported to the United States from 10% to 25%, despite the substantial progress made by both sides in strengthening intellectual property protection, expanding market access and promoting bilateral trade balance. In the near future, the Sino-US economic and trade consultation will be cloudy. The extreme pressure of American politicians has once again awakened the “gray rhino” of the Sino-US trade war, triggering extreme anxiety among global investors and a sharp drop in global stock markets. (1) American politicians have come up with an argument for their tariff stick, claiming that China will renegotiate previously negotiated terms. Even if, as Mr. Trump said, China proposes amendments to the negotiating text, which is also China’s basic right. We should know that the economic and trade consultation between China and the United States is a process of repeated consultation, that is, the process of continuous bargaining between the two sides. Give whatever you want. It’s not negotiation. It’s one-sided persuasion. Many unequal treaties were imposed by Western powers in the history of the Chinese people. After the founding of New China, the Chinese people had no difficulty in breaking away from these unequal treaties. Today’s China is no longer willing or able to accept new unequal treaties. In fact, it is the United States that has repeatedly backfired in the Sino-US economic and trade negotiations. In November 2017, Trump visited China. The two heads of state said that they would continue to work for mutually beneficial and win-win economic and trade cooperation between China and the United States. The two sides signed an economic and trade cooperation agreement of up to 253.5 billion US dollars. But four months later, on March 22, 2018, Trump instructed the U.S. Trade Representative’s office to impose tariffs on Chinese goods and restrict Chinese investment. On May 19, 2018, after arduous efforts, China and the United States reached a consensus on “no trade war, and stop imposing tariffs on each other”, and issued a joint statement to the outside world. But just 10 days later, the United States suddenly announced on June 15 that it would publish a final list of $50 billion of Chinese products subject to a 25% tariff, in flagrant violation of the consensus just reached between the two sides. If Mr Trump’s approach is followed, dealing with the United States is bound to be wordless and credible. To put it further, the United States is so bad at keeping its promises that it can tear up even the agreements being implemented. For example, the recent Iranian nuclear issue, which has been more fierce, is caused by the unilateral tearing up of the Iranian nuclear agreement by the United States. We should know that this agreement was signed under the leadership of the United States Government and unanimously adopted by the United Nations Security Council. The United States often accuses China of failing to keep its promises, but in fact, it is often him who fails to keep his promises. (two) So why did the United States use the tariff stick again at this time? The answer should be that the United States wants to squeeze more benefits from China and use tariffs to disrupt China’s confidence in development. In the Sino-US economic and trade frictions, we should see through the essence of American behavior. Americans seem to be talking with our country about economy and trade, but many of their requirements have already gone beyond the scope of economy and trade. Drunken men are not interested in wine, but in curbing China and disrupting China’s development. To contain China, the United States is consistent, but in different periods, the means of containment are different. It used to be sanctions, blockades, bombing embassies and so on, but today it has become a trade war. The reason why the United States launched the trade war is that the trade imbalance between the United States and China is the trade deficit between the United States and China. But in fact, Americans know that the trade war may reduce the trade deficit with China, but it is impossible to reduce the trade deficit with the United States. Harvard University professor and former deputy secretary of state Professor Harper made it clear that tariffs could not reduce the U.S. trade deficit. “Once the Trump government really imposes a large-scale tax on Chinese goods, this part of the import source will only be transferred to other economies, such as Bangladesh, Vietnam and other countries will quickly replace the vacancy, so imposing high tariffs will not reduce the total deficit of the United States.” Therefore, the real direction of US tariffs is not to reduce its deficit, but to reduce China’s exports, reduce China’s surplus, and then curb China’s development. To put it bluntly, the United States is unwilling to see the development of China, China’s strong. The U.S. government has repeatedly expressed its strong willingness to maintain “America First”. Trump made it clear: “When I took office, the problem we faced was that China would surpass us in a very short time. But that won’t happen again.” Why won’t it happen again? Because the United States is doing its utmost to curb it, and he believes that he can successfully curb China’s momentum of development through trade wars, just as he did against Japan. Trump is not the first and probably not the last person to curb China’s development. A former president of the United States once said clearly: “If more than one billion Chinese residents live like Australians and Americans now, then all of us will be in a very tragic situation, because that is beyond the capacity of the planet.” To curb China’s development, the most effective way is to eliminate China’s institutional advantages. Americans know this very well, so they use the hand of trade and economy to wave tariff sticks, intending to force China to sign an alliance under the city and abandon its institutional advantages. But China is not China 100 years ago. Economic and trade issues can be discussed. However, it is absolutely unacceptable for us to interfere with our political system and sovereignty under the guise of trade. (three) In the economic and trade negotiations, the reason why the United States dares to continue to make big sticks and exert extreme pressure is the asymmetry of trade between China and the United States. America seems to have more bullets than us. However, the number of hand neutron bombs does not determine the victory or defeat of the war. The victory or defeat of the war depends on the will of both sides, the spirit of both sides and the endurance of both sides. Looking back on the war of resistance against the United States and aid to the DPRK, the volunteer military with single clothes and potatoes and rifles defeated the American army, which had the most sophisticated equipment at that time. At that time, China had fewer bullets than it does now, but we still won. Since ancient times, China has not been a bullying country. The Chinese people have a great spirit of resistance since ancient times. Today, China has not only a great spirit of struggle, but also a strong ability to fight. The Chinese cherish peace and value peace, but they will not compromise and seek peace. “Friends come with good wine, jackals come with shotguns.” Talk about it, we welcome each other with good wine, fight, we are not afraid, there are shotguns. Chinese people are not troublesome, but they are not afraid of things. When they shine their sword, they must shine their sword. (Wen/Chen Zhuang) (Responsibility: Bai Yu) 转载：人民网 Reprint: people.cn</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;打开看看？&lt;/p&gt;
    
    </summary>
    
      <category term="政治" scheme="http://yueyangwu.cn/categories/%E6%94%BF%E6%B2%BB/"/>
    
    
  </entry>
  
  <entry>
    <title> Luogu P1550 [USACO08OCT]打井Watering Hole		</title>
    <link href="http://yueyangwu.cn/2019/05/16/luogu-p1550-usaco08oct-e6-89-93-e4-ba-95watering-hole/"/>
    <id>http://yueyangwu.cn/2019/05/16/luogu-p1550-usaco08oct-e6-89-93-e4-ba-95watering-hole/</id>
    <published>2019-05-16T03:47:44.000Z</published>
    <updated>2019-07-11T17:26:02.274Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1550" title="题目链接" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><hr><p>这道题的思路感觉可以留下来，题目大意就是每个村能打一个井，也能挖水渠到其他村，但是需要所有村都有水，问最小花费。 - 可以建一个虚拟节点，和每个村连起来，边权就是打水井的花费，挖水渠就正常建边。 代码：</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n,fa[<span class="hljs-number">309</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> x==fa[x]?x:fa[x]=find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span></span><br><span class="line">    ll x,y,w;</span><br><span class="line">&#125;e[<span class="hljs-number">180009</span>];</span><br><span class="line"><span class="hljs-keyword">int</span> tot;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++tot].x=x;</span><br><span class="line">    e[tot].y=y;</span><br><span class="line">    e[tot].w=w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Edge a,Edge b)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> a.w&lt;b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function">ll <span class="hljs-title">kru</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    ll ans=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=tot;i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> xx=find(e[i].x),yy=find(e[i].y);</span><br><span class="line">        <span class="hljs-keyword">if</span>(xx==yy) <span class="hljs-keyword">continue</span>;</span><br><span class="line">        fa[xx]=yy;</span><br><span class="line">        ans+=e[i].w;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="hljs-keyword">if</span>(cnt==n) <span class="hljs-keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> w;</span><br><span class="line">        <span class="hljs-built_in">cin</span>&gt;&gt;w;</span><br><span class="line">        add(<span class="hljs-number">0</span>,i,w),add(i,<span class="hljs-number">0</span>,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> w;</span><br><span class="line">            <span class="hljs-built_in">cin</span>&gt;&gt;w;</span><br><span class="line">            add(i,j,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(e,e+tot+<span class="hljs-number">1</span>,cmp);</span><br><span class="line">    <span class="hljs-built_in">cout</span>&lt;&lt;kru();</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1550&quot; title=&quot;题目链接&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://yueyangwu.cn/categories/OI/"/>
    
      <category term="题目" scheme="http://yueyangwu.cn/categories/OI/%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="精" scheme="http://yueyangwu.cn/tags/%E7%B2%BE/"/>
    
      <category term="图论" scheme="http://yueyangwu.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最小生成树" scheme="http://yueyangwu.cn/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title> 最短路算法——SPFA		</title>
    <link href="http://yueyangwu.cn/2019/05/15/e6-9c-80-e7-9f-ad-e8-b7-af-e7-ae-97-e6-b3-95-spfa/"/>
    <id>http://yueyangwu.cn/2019/05/15/e6-9c-80-e7-9f-ad-e8-b7-af-e7-ae-97-e6-b3-95-spfa/</id>
    <published>2019-05-15T12:13:40.000Z</published>
    <updated>2019-07-11T17:07:45.266Z</updated>
    
    <content type="html"><![CDATA[<p>emmmm。。。我不得不承认。。。学OI这么长时间，并不会写SPFA。。。</p><a id="more"></a><hr><p>好吧。。直接上代码</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n,m,s,dis[<span class="hljs-number">10009</span>];</span><br><span class="line"><span class="hljs-keyword">bool</span> flag,vis[<span class="hljs-number">10009</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> cnt[<span class="hljs-number">10009</span>];<span class="hljs-comment">//环 </span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span> to,nxt,w;</span><br><span class="line">&#125;e[<span class="hljs-number">500009</span>];</span><br><span class="line"><span class="hljs-keyword">int</span> head[<span class="hljs-number">10009</span>],tot;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++tot].to=y;</span><br><span class="line">    e[tot].nxt=head[x];</span><br><span class="line">    e[tot].w=w;</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-keyword">int</span> st)</span></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;</span><br><span class="line">    q.push(st);</span><br><span class="line">    dis[st]=<span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> x=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[x]=<span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[x];i;i=e[i].nxt)&#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> y=e[i].to;</span><br><span class="line">            <span class="hljs-keyword">if</span>(dis[y]&gt;dis[x]+e[i].w)&#123;</span><br><span class="line">                dis[y]=dis[x]+e[i].w;</span><br><span class="line">                cnt[y]++;</span><br><span class="line">                <span class="hljs-keyword">if</span>(cnt[y]&gt;n)&#123;</span><br><span class="line">                    flag=<span class="hljs-number">1</span>;</span><br><span class="line">                    <span class="hljs-keyword">return</span>;</span><br><span class="line">                &#125;<span class="hljs-comment">//判环 </span></span><br><span class="line">                <span class="hljs-keyword">if</span>(!vis[y])&#123;</span><br><span class="line">                    q.push(y);</span><br><span class="line">                    vis[y]=<span class="hljs-number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x]=<span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> x,y,w;</span><br><span class="line">        <span class="hljs-built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        add(x,y,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span>(dis));</span><br><span class="line">    spfa(s);</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(dis[i]==<span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">2147483647</span>&lt;&lt;<span class="hljs-string">" "</span>;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;dis[i]&lt;&lt;<span class="hljs-string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;emmmm。。。我不得不承认。。。学OI这么长时间，并不会写SPFA。。。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://yueyangwu.cn/categories/OI/"/>
    
      <category term="知识点" scheme="http://yueyangwu.cn/categories/OI/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="图论" scheme="http://yueyangwu.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title> Luogu P2285 [HNOI2004]打鼹鼠		</title>
    <link href="http://yueyangwu.cn/2019/05/09/luogu-p2285-hnoi2004-e6-89-93-e9-bc-b9-e9-bc-a0/"/>
    <id>http://yueyangwu.cn/2019/05/09/luogu-p2285-hnoi2004-e6-89-93-e9-bc-b9-e9-bc-a0/</id>
    <published>2019-05-09T02:15:29.000Z</published>
    <updated>2019-07-11T17:28:16.096Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2285" title="题目链接" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><hr><p>我开始想到棋盘问题。。。三维数组爆空间。。。 然后就看了看算法标签 想了个一维dp $f[i]$表示前i个地鼠最多能被砸死几个，因为发现时间是按顺序排列的，所以可以想到从当前时间前面探出头的地鼠转移，所以 - $f[i]=max(f[i],f[j]+1)(a[j].t&lt;a[i].t$且$dis(i,j)\leq tim(i,j))$ 代码：</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> f[<span class="hljs-number">10009</span>],n,m;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span> t,x,y;</span><br><span class="line">&#125;a[<span class="hljs-number">10009</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a[i].x-a[j].x)+<span class="hljs-built_in">abs</span>(a[i].y-a[j].y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="hljs-built_in">cin</span>&gt;&gt;a[i].t&gt;&gt;a[i].x&gt;&gt;a[i].y;</span><br><span class="line">        f[i]=<span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=i<span class="hljs-number">-1</span>;j++)&#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(dis(i,j)&lt;=<span class="hljs-built_in">abs</span>(a[i].t-a[j].t))&#123;</span><br><span class="line">                f[i]=max(f[i],f[j]+<span class="hljs-number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        ans=max(ans,f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P2285&quot; title=&quot;题目链接&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://yueyangwu.cn/categories/OI/"/>
    
      <category term="题目" scheme="http://yueyangwu.cn/categories/OI/%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="dp" scheme="http://yueyangwu.cn/tags/dp/"/>
    
      <category term="优" scheme="http://yueyangwu.cn/tags/%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title> Luogu P1282 多米诺骨牌（精）		</title>
    <link href="http://yueyangwu.cn/2019/05/08/luogu-p1282-e5-a4-9a-e7-b1-b3-e8-af-ba-e9-aa-a8-e7-89-8c-ef-bc-88-e7-b2-be-ef-bc-89/"/>
    <id>http://yueyangwu.cn/2019/05/08/luogu-p1282-e5-a4-9a-e7-b1-b3-e8-af-ba-e9-aa-a8-e7-89-8c-ef-bc-88-e7-b2-be-ef-bc-89/</id>
    <published>2019-05-08T14:29:21.000Z</published>
    <updated>2019-07-11T17:24:06.581Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1282" title="题目链接" target="_blank" rel="noopener">题目链接</a> 总结一下：这种题用背包。。。（蒟蒻的我看不出来qwq）</p><a id="more"></a><hr><p>我们先把骨牌翻转，调整至点数大的在上面 这样，我们就能保证上方的点数一定比下方大，并且保证每翻转一 次，都能使上下的点数之差变小，而变小的点数，就是上下点数之差乘以2。 把改变的点数看成物品的体积，初始上下方的点数之差看做背包体积，不难看出背包问题的模型。 那么物品的重量是什么呢？ 因为我们一开始就把点数大的放在了上面，而每放一次，翻转次数就+1。考虑：要是我后来后悔了，我发现不翻这个骨牌更好怎么办？那我会把它翻回来，那么相当于没有翻这个骨牌。 因此，一开始翻过的骨牌重量就是-1，未翻过的骨牌重量就是1（重量等价于翻转次数） 当然，上下相同的骨牌就是体积为0，重量为0的物品，因为他们无论怎么翻，都不会对上下点数差造成影响。 至此，背包的模型就出来了。这个问题被简化成：有n个物品，给出每个物品的体积v[i],他们的重量是1或-1。背包的重量为base，体积为tot，现在请把这n个物品放到背包里去，总体积不能超过tot，体积最大的情况下使得物品重量之和最小。 其中，dp[i][j]表示前i件物品能装到体积为j的最小重量 vs[i][j]表示前i件物品能否装到j体积</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n,m,c;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span> a,b;</span><br><span class="line">&#125;a[<span class="hljs-number">1009</span>];</span><br><span class="line"><span class="hljs-keyword">int</span> f[<span class="hljs-number">1009</span>][<span class="hljs-number">5009</span>],v[<span class="hljs-number">1009</span>],w[<span class="hljs-number">1009</span>];</span><br><span class="line"><span class="hljs-keyword">bool</span> vis[<span class="hljs-number">1009</span>][<span class="hljs-number">5009</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="hljs-built_in">cin</span>&gt;&gt;a[i].a&gt;&gt;a[i].b;</span><br><span class="line">        <span class="hljs-keyword">if</span>(a[i].a&lt;a[i].b)&#123;</span><br><span class="line">            swap(a[i].a,a[i].b);</span><br><span class="line">            w[i]=<span class="hljs-number">-1</span>;</span><br><span class="line">            v[i]=a[i].a-a[i].b;</span><br><span class="line">            m+=v[i];</span><br><span class="line">            v[i]*=<span class="hljs-number">2</span>;</span><br><span class="line">            c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span>&#123;</span><br><span class="line">            w[i]=<span class="hljs-number">1</span>;</span><br><span class="line">            v[i]=a[i].a-a[i].b;</span><br><span class="line">            m+=v[i];</span><br><span class="line">            v[i]*=<span class="hljs-number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            f[i][j]=f[i<span class="hljs-number">-1</span>][j];</span><br><span class="line">            vis[i][j]=vis[i<span class="hljs-number">-1</span>][j];</span><br><span class="line">            <span class="hljs-keyword">if</span>(vis[i<span class="hljs-number">-1</span>][j-v[i]]||j-v[i]==<span class="hljs-number">0</span>)&#123;</span><br><span class="line">                <span class="hljs-keyword">if</span>(!vis[i][j])&#123;</span><br><span class="line">                    f[i][j]=f[i<span class="hljs-number">-1</span>][j-v[i]]+w[i];</span><br><span class="line">                    vis[i][j]=<span class="hljs-number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-keyword">else</span>&#123;</span><br><span class="line">                    f[i][j]=min(f[i][j],f[i<span class="hljs-number">-1</span>][j-v[i]]+w[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m;i&gt;=<span class="hljs-number">0</span>;i--)&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(vis[n][i])&#123;</span><br><span class="line">            <span class="hljs-built_in">cout</span>&lt;&lt;f[n][i]+c;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1282&quot; title=&quot;题目链接&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt; 总结一下：这种题用背包。。。（蒟蒻的我看不出来qwq）&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://yueyangwu.cn/categories/OI/"/>
    
      <category term="题目" scheme="http://yueyangwu.cn/categories/OI/%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="精" scheme="http://yueyangwu.cn/tags/%E7%B2%BE/"/>
    
      <category term="dp" scheme="http://yueyangwu.cn/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title> Luogu P2340 奶牛会展		</title>
    <link href="http://yueyangwu.cn/2019/05/07/luogu-p2340-e5-a5-b6-e7-89-9b-e4-bc-9a-e5-b1-95/"/>
    <id>http://yueyangwu.cn/2019/05/07/luogu-p2340-e5-a5-b6-e7-89-9b-e4-bc-9a-e5-b1-95/</id>
    <published>2019-05-07T02:45:41.000Z</published>
    <updated>2019-07-11T17:29:00.397Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题意：给定$n$组数，每组数包含2个数字$S_i$和$F_i$。 要求：取其中几组数，要求他们的和最大，并且所有$S_i$的和与$F_i$的和均大于0。</li><li>$1\leq N\leq 400$ $-1000\leq S_i,F_i\leq 1000$</li><li><a id="more"></a></li></ul><hr><ul><li>可以看出，每组数有选与不选两种情况，可以转化为01背包，让$S_i$作为物品体积，$F_i$作为物品价值。但是由题意可以发现，$S_i$有可能为负数，又因为$-1000\leq S_i\leq 1000$，所以背包体积可以是$-400000\leq m\leq 400000$，因为数组下标不可以为负，所以将整个数组向右平移$400000$个单位，把$400000$当做$0$。</li><li>这样如果$S_i&lt;0$那么正序枚举，反之倒序枚举。</li></ul><p>代码：</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> v[<span class="hljs-number">409</span>],w[<span class="hljs-number">409</span>];</span><br><span class="line"><span class="hljs-keyword">int</span> f[<span class="hljs-number">800009</span>],n;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="hljs-built_in">cin</span>&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">memset</span>(f,~<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="hljs-number">400000</span>]=<span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(v[i]&gt;=<span class="hljs-number">0</span>)&#123;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">800000</span>;j&gt;=v[i];j--)&#123;</span><br><span class="line">                f[j]=max(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span>&#123;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">800000</span>+v[i];j++)&#123;</span><br><span class="line">                f[j]=max(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">400000</span>;i&lt;=<span class="hljs-number">800000</span>;i++) <span class="hljs-keyword">if</span>(f[i]&gt;=<span class="hljs-number">0</span>) ans=max(ans,f[i]+i<span class="hljs-number">-400000</span>);</span><br><span class="line">    <span class="hljs-built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题意：给定$n$组数，每组数包含2个数字$S_i$和$F_i$。 要求：取其中几组数，要求他们的和最大，并且所有$S_i$的和与$F_i$的和均大于0。&lt;/li&gt;
&lt;li&gt;$1\leq N\leq 400$ $-1000\leq S_i,F_i\leq 1000$&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="OI" scheme="http://yueyangwu.cn/categories/OI/"/>
    
      <category term="题目" scheme="http://yueyangwu.cn/categories/OI/%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="精" scheme="http://yueyangwu.cn/tags/%E7%B2%BE/"/>
    
      <category term="dp" scheme="http://yueyangwu.cn/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title> OI之路——崔肇峰		</title>
    <link href="http://yueyangwu.cn/2019/05/06/oi-e4-b9-8b-e8-b7-af-e5-b4-94-e8-82-87-e5-b3-b0/"/>
    <id>http://yueyangwu.cn/2019/05/06/oi-e4-b9-8b-e8-b7-af-e5-b4-94-e8-82-87-e5-b3-b0/</id>
    <published>2019-05-06T13:34:02.000Z</published>
    <updated>2019-07-12T02:49:44.917Z</updated>
    
    <content type="html"><![CDATA[<p>OI之路——崔肇峰</p><a id="more"></a><p>OI 就像状态转移方程，由一个阶段转移到另一个阶段，但是， 不同的是，我们不知道下一个状态是什么。有时候坚定信念，有时候会感到迷茫 看着深夜微微发亮的屏幕，还有满屏的WA,当已经没信心的时候，告诉自己，已经结束了，现在是倒叙， 当不想学数论向量要崩溃的时候，告诉自己，已经考完了，没考上，许个愿给自己一个机会穿越回过去， 睁开眼睛愿望是实现了，代码就在眼前。 我作为一个信息竞赛生，对于现在网上对于信息竞赛的情况各有其词， 一些记者公众号为了吸引人的眼球而夸大一些事实，实在让人气愤。 对于我而言，确实一开始选择信息竞赛是出于一些功利的目的，虽然只有小小的热爱，却也不报希望， 清北以及顶尖院校的营地及自主招生简章中对于学科竞赛都有明确要求， 而且仔细读招生简章其实并不是对竞赛的打击，而是对一门学科的从高中开始的人才培养。 随着学习的深入，我心里的动力逐渐由功利转向对信息学的喜爱。 主席树，红黑树，平衡树，可持久化动态仙人掌，上下界最小费用流等等等等， 这些在noip联赛考点中并没有要求，但我依然去学习，出发点便是热爱。 信息竞赛的学习，丰富了我的知识，对于信息学有了更深刻的理解，对于一切的发展，都有了明确的打算。 或许在一些人看来，竞赛就是在走捷径，是“权贵”的游戏，但我想，对于一名真正的竞赛生而言，竞赛，或者说那一个 学科已经是生命中不可分割的一部分。 去qbxt，感受全国各地的OIer实力与风采，同时提升了自己的实力，慢慢地从只会看题解，到自己独自切掉一个题， AC的时候，那种喜悦感，常人根本无法理解。qbxt的老师学长们不同的讲课风格，只感觉能和一群与自己有相同爱好 的人在一起，真好；斜率优化，四边形不等式，凸包优化，轮廓线优化让我感受到信息学中数学的魅力；每年学长们 的励志小企鹅，还有一次次的祝福rp++，很让人感动。记忆很深的是一次中秋节校内集训，很强的一位学长给我们做 考前辅导，不过毕竟高一一群萌新，还是有一些恐惧以及胆小，不过，这位学长见我们的第一面，竟然是：泥萌要吃 月饼吗？从此以后，不在害怕与畏惧这个陌生的学校，只感到温暖。想起这一幕幕，不觉泪目。 这是我们的故事啊，其实还是挺惆怅的。一届一届的学长毕业，留下的不只是码风，更有传统。 一种不放弃，不服气，考跪了自己菜，就是这样； 在逆境中自我学习，在山西这样的弱省，在NOI中留下一席之地； 在比赛结束前，调试代码； 认真做好每一件小事，认真地写好每一个函数，每一句话； 以及，不畏惧一切。 “实中能搞个屁的信竞” “实中信息一年不如一年了” “在实中就毁了” “就算省队7个真的挤出来两个你中奖的概率又有多少” 我们在这一年里，在这样的声音里走过，顶着对手巨大的压力，最后走出了实中信息竞赛的一条路，选择实中并没有错，我们始终坚定着，对于自己选择的路，就是跪着，也要走下去！ 以上 ————实中OI队.崔肇峰</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OI之路——崔肇峰&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://yueyangwu.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title> 清北学堂noip2019-图论		</title>
    <link href="http://yueyangwu.cn/2019/05/04/e6-b8-85-e5-8c-97-e5-ad-a6-e5-a0-82noip2019-e5-9b-be-e8-ae-ba/"/>
    <id>http://yueyangwu.cn/2019/05/04/e6-b8-85-e5-8c-97-e5-ad-a6-e5-a0-82noip2019-e5-9b-be-e8-ae-ba/</id>
    <published>2019-05-03T23:59:08.000Z</published>
    <updated>2019-07-11T17:21:18.482Z</updated>
    
    <content type="html"><![CDATA[<h3 id="张浩威老师的图论"><a href="#张浩威老师的图论" class="headerlink" title="张浩威老师的图论"></a>张浩威老师的图论</h3><a id="more"></a><h4 id="存图"><a href="#存图" class="headerlink" title="存图"></a>存图</h4><ul><li>过（太菜了）</li></ul><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>过（awsl）</li><li>如果一个图中节点两两相连，那么称这是一个团。</li></ul><hr><h4 id="拓扑排序（DAG一定存在）"><a href="#拓扑排序（DAG一定存在）" class="headerlink" title="拓扑排序（DAG一定存在）"></a>拓扑排序（DAG一定存在）</h4><ul><li>例如： <img src="http://yueyangwu.cn/wp-content/uploads/2019/05/%E5%9B%BE%E7%89%871.png" alt></li><li>$v1,v2,v5,v4,v3,v7,v6$为该图的一个拓扑序。</li><li>我们每次寻找入度为$0$的点加入序列中。</li><li>并将当前点连接的所有边均删除，更新其它点的度数。</li><li>由于每条边至多被删除一次。</li><li>因此这个时间复杂度是$O(|E|)$的。<figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; a[];</span><br><span class="line"><span class="hljs-keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-built_in">cin</span>&gt;&gt;A&gt;&gt;B;</span><br><span class="line">    a[A].push_back(B);</span><br><span class="line">    du[B] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)</span><br><span class="line">  <span class="hljs-keyword">if</span> (du[i] == <span class="hljs-number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    ans[++r]=i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">l=<span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">while</span> (l!=r)</span><br><span class="line">&#123;</span><br><span class="line">    now = ans[++l];</span><br><span class="line">    <span class="hljs-built_in">cout</span>&lt;&lt;now&lt;&lt;<span class="hljs-string">' '</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;a[now].size(); a++) &#123;</span><br><span class="line">        du[a[now][i]] --;</span><br><span class="line">        <span class="hljs-keyword">if</span> (du[a[now][i]] == <span class="hljs-number">0</span>) ans[++r]=a[now][i];</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="拓扑排序计数"><a href="#拓扑排序计数" class="headerlink" title="拓扑排序计数"></a>拓扑排序计数</h4><ul><li>状压DP？</li></ul><h4 id="求“割点”"><a href="#求“割点”" class="headerlink" title="求“割点”"></a>求“割点”</h4><ul><li>给定一张n个点m条边的拓扑图（保证1号点能走到n号点），求存在多少点，将其删去后1号点走不到n号点。</li><li>$n,m\leq 100000$</li><li>这个题和图论没啥关系……</li><li>令$S[i]$表示从1号点走到i号点的方案总数，令$T[i]$表示从n号点反向走到i号点的方案总数。（这个可以用动态规划求出）</li><li>对于一个点i，若$S[i]*T[i]=S[n]$，则它是割点。</li></ul><hr><h3 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h3><h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><ul><li>令dis[i]表示当前u到i的最短路是多少。<ol><li>将dis[u]=0,dis[i]=inf(i!=u)。</li><li>寻找最小的dis[x]且x曾经没被找到过。</li><li>若x=v，输出答案并退出。</li><li>枚举x的所有边，用dis[x]去更新其余dis[]，回到步骤2。</li></ol></li><li>时间复杂度为$O(n^2)$。</li><li>使用范围：不存在负权边。 <img src="http://yueyangwu.cn/wp-content/uploads/2019/05/%E5%9B%BE%E7%89%872.jpg" alt> <img src="http://yueyangwu.cn/wp-content/uploads/2019/05/QQ%E5%9B%BE%E7%89%8720190501153441.gif" alt></li></ul><hr><h4 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h4><ul><li>令dis[i]表示当前u到i的最短路是多少。<ol><li>将$dis[u]=0,dis[i]=inf(i!=u)$，并将u加入队列中。</li><li>设当前队首为$x$，枚举$x$。</li><li>枚举x的所有边，用$dis[x]$去更新其余$dis[]$，若$dis[i]$此时被更新且$i$当前不在队列中，将其加入队列。</li><li>将$x$弹出队列，若此时队列为空，结束，否则返回步骤2。 复杂度$O(nm)$ <img src="http://yueyangwu.cn/wp-content/uploads/2019/05/%E5%9B%BE%E7%89%873.jpg" alt></li></ol></li><li>判断负环：如果有一个点进入队列超过$n-1$次，就有负权环。</li></ul><hr><h3 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h3><ul><li>设有$n$个变量和$m$个约束条件。</li><li>第i个约数条件形如$x[ai]-x[bi] \leq ci$，我们称之为差分约数系统。</li><li>求解一组解使得这$n$个变量满足所有约束条件即为差分约束系统。</li></ul><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><ul><li>对于一个ai - bi &lt;= ci的限制</li><li>我们抽象成bi -&gt; ai 有一条长为ci的边。</li><li>在跑最短路时，就保证了ai至多为bi+ci。</li><li>具体实现时可以再增加一个虚拟点来作为源点跑最短路。 <img src="http://yueyangwu.cn/wp-content/uploads/2019/05/1.png" alt></li></ul><hr><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><ul><li>过</li></ul><hr><h3 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h3><ul><li>定义：如果一个无向图$G$中$V$能分成两个点集$A$与$B$，且位于$A$中的顶点互相之间没有边，位于$B$中的顶点互相之间没有边，则称这个图为二分图。</li><li>性质：<ol><li>这个图中不存在奇环，反之如果不存在奇环，那它一定是一个二分图。</li></ol></li><li>判断二分图：用并查集，先将每个点分成两个点，比如点$A$分成$A$和$A^’$，然后每遇到一条边，都把$A$和$B^’$,$B$和$A^’$用并查集合并，然后当发现$A$和$A^’$被合并时，说明这不是二分图。 代码如下：<figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i&lt;=n; i++) p[i][<span class="hljs-number">0</span>]=++cnt,p[i][<span class="hljs-number">1</span>]=++cnt;</span><br><span class="line"><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i&lt;=cnt; i++) f[i]=i;</span><br><span class="line"><span class="hljs-keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-built_in">cin</span>&gt;&gt;A&gt;&gt;B;</span><br><span class="line">    f[get(p[A][<span class="hljs-number">0</span>])]=get(p[B][<span class="hljs-number">1</span>]);</span><br><span class="line">    f[get(p[A][<span class="hljs-number">1</span>])]=get(p[B][<span class="hljs-number">0</span>]);</span><br><span class="line">    <span class="hljs-keyword">if</span> (get(p[A][<span class="hljs-number">0</span>]) == get(p[A][<span class="hljs-number">1</span>]) ||</span><br><span class="line">        get(p[B][<span class="hljs-number">0</span>]) == get(p[B][<span class="hljs-number">1</span>]))</span><br><span class="line">          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="匈牙利算法（二分图最大匹配）"><a href="#匈牙利算法（二分图最大匹配）" class="headerlink" title="匈牙利算法（二分图最大匹配）"></a>匈牙利算法（二分图最大匹配）</h4><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> <span class="hljs-comment">// 编号为x的男生是否能匹配女生 </span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++)</span><br><span class="line">        <span class="hljs-keyword">if</span> (a[x][i])  <span class="hljs-comment">//如果有边相连 </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (!t[i]) <span class="hljs-comment">//该女生还未匹配 </span></span><br><span class="line">            &#123;</span><br><span class="line">                t[i] = x;</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> (!v[i])</span><br><span class="line">            &#123;</span><br><span class="line">                v[i]=<span class="hljs-literal">true</span>;</span><br><span class="line">                <span class="hljs-keyword">if</span> (work(t[i]))</span><br><span class="line">                &#123;</span><br><span class="line">                    t[i] = x;</span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i&lt;=m; i++) t[i]=<span class="hljs-number">0</span>; <span class="hljs-comment">// t[i] 编号为i的女生连接的男生编号 </span></span><br><span class="line"><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (j=<span class="hljs-number">1</span>; j&lt;=m; j++) v[j]=<span class="hljs-literal">false</span>; <span class="hljs-comment">// v[j] 编号为j的女生对应的男生是否已经谦让过了 </span></span><br><span class="line">    <span class="hljs-keyword">if</span> (work(i)) ans++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="搜索树"><a href="#搜索树" class="headerlink" title="搜索树"></a>搜索树</h3><ul><li>对一个图从某一点开始进行深度优先搜索。</li><li>搜索到的边构成的树称为搜索树。</li><li>在这棵树上的边称为树边，其余边称为非树边。</li><li>性质：对图求搜索树时，非树边连接的两个端点在搜索树中一定是其中一个点是另一个点的祖先。</li></ul><hr><h3 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h3><ul><li>求无向图的所有强连通分量</li><li>求联通块即可。</li><li>求有向图的所有强连通分量</li><li>Tarjan!</li></ul><h4 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h4><p><img src="http://yueyangwu.cn/wp-content/uploads/2019/03/t01fa3958a07f2aa839.png" alt> 存在3个极大强连通分量，1234，5，6。</p><ul><li>我们定义$DFN[x]$为搜索到x时的时间戳（即搜索到的时间）。$LOW[x]$为搜索树中x以及它的子孙可以访问到的最早祖先的时间戳。有$LOW[x]=min(DFN[x],DFN[j],LOW[k])$，其中存在边$(x,j)，(x,k)$，$j$为$x$的祖先，$k$为$x$的子孙。</li><li>令v[i]表示i是否已被搜索过以及是否找到了极大强连通分量。若i已经找到了极大强连通分量或者还未被搜索过，则$v[i]=0$，否则$v[i]=1$。</li></ul><ol><li>如果出点是自己的祖先，则拿祖先的DFN值更新。</li><li>如果出点不是自己的祖先，且出点的low值小于自己的DFN值，则可以用这个值更新自己的$low$值。</li><li>直到$low=DFN$ 找到了一个极大强连通分量。<figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    Time++;</span><br><span class="line">    DFN[x] = Time;</span><br><span class="line">    LOW[x] = Time;</span><br><span class="line">    v[x]=<span class="hljs-number">1</span>;  <span class="hljs-comment">// v为1的就表示x的祖先 </span></span><br><span class="line">    st[++r] = x;  <span class="hljs-comment">//当前搜索树中未找到极大强联通分量的点的编号 </span></span><br><span class="line">    <span class="hljs-keyword">int</span> R=r;  <span class="hljs-comment">// R表示x在st中的位置 </span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;a[x].size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!DFN[a[x][i]]) </span><br><span class="line">            dfs(a[x][i]);</span><br><span class="line">        <span class="hljs-keyword">if</span> (v[a[x][i]])</span><br><span class="line">            LOW[x] = min(LOW[x],DFN[a[x][i]]);</span><br><span class="line">        <span class="hljs-keyword">if</span> (!v[a[x][i]] &amp;&amp; !g[a[x][i]])</span><br><span class="line">            LOW[x] = min(LOW[x],LOW[a[x][i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (LOW[x] == DFN[x])  <span class="hljs-comment">//如果LOW[x] == DFN[x] 时 R~r一定构成极大强联通分量 </span></span><br><span class="line">    &#123;</span><br><span class="line">        num ++; <span class="hljs-comment">// 强联通分量的编号 </span></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=R; i&lt;=r; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            g[st[i]] = <span class="hljs-number">1</span>;</span><br><span class="line">            group[st[i]] = num;  <span class="hljs-comment">// group[i] i这个节点所在的编号 </span></span><br><span class="line">        &#125;</span><br><span class="line">        r = R<span class="hljs-number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v[x]=<span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)</span><br><span class="line">  <span class="hljs-keyword">if</span> (!DFN[i]) dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="无向图的割点和桥"><a href="#无向图的割点和桥" class="headerlink" title="无向图的割点和桥"></a>无向图的割点和桥</h4><ul><li>我们称一个点$u$为这个图的割点，当且仅当删去这个点以及与该点连接的所有边后，这个图不连通。</li><li>我们称一条边$(u,v)$为这个图的割边，当且仅当删去这条边后这个图不连通。</li></ul><hr><h3 id="倍增问题"><a href="#倍增问题" class="headerlink" title="倍增问题"></a>倍增问题</h3><ul><li>给定n个数，有Q次询问，每次询问一段区间的最小值。</li></ul><h4 id="RMQ问题"><a href="#RMQ问题" class="headerlink" title="RMQ问题"></a>RMQ问题</h4><ul><li>$f[i][j]$表示从$i$开始，长度为$2^i-1$的序列的最小值。</li><li>我们考虑记录$a[x]~a[x+2^k-1]$的最小值，令其为$f[x][k]$。这可以在nlgn的时间内求出。</li><li>对于每次询问$L~R$，令$k=log[R-L+1]$。有$ans=min(f[L][k],f[R-2^k+1][k])$。(即进行$O(1)$询问)<figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">f[x][<span class="hljs-number">0</span>] = a[x]</span><br><span class="line"></span><br><span class="line">f[x][i]  x~x+<span class="hljs-number">2</span>^i<span class="hljs-number">-1</span></span><br><span class="line">f[x][i<span class="hljs-number">-1</span>]  x~x+<span class="hljs-number">2</span>^(i<span class="hljs-number">-1</span>)<span class="hljs-number">-1</span></span><br><span class="line">f[x+<span class="hljs-number">2</span>^(i<span class="hljs-number">-1</span>)][i<span class="hljs-number">-1</span>]  x</span><br><span class="line">f[x][i] = min(f[x][i<span class="hljs-number">-1</span>],f[x+<span class="hljs-number">2</span>^(i<span class="hljs-number">-1</span>)][i<span class="hljs-number">-1</span>])</span><br><span class="line"></span><br><span class="line">n  i <span class="hljs-built_in">log</span>(n)/<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i&lt;=n; i++) LG[i]=<span class="hljs-keyword">int</span>(<span class="hljs-built_in">log</span>(i)/<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>));  <span class="hljs-comment">//  log(i)  lglgi </span></span><br><span class="line"><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i&lt;=LG[n]; i++)</span><br><span class="line">    <span class="hljs-keyword">for</span> (x=<span class="hljs-number">1</span>; x&lt;=n-(<span class="hljs-number">1</span>&lt;&lt;i)+<span class="hljs-number">1</span>; x++) </span><br><span class="line">        f[x][i] = min(f[x][i<span class="hljs-number">-1</span>],f[x+<span class="hljs-number">2</span>^(i<span class="hljs-number">-1</span>)][i<span class="hljs-number">-1</span>])</span><br></pre></td></tr></table></figure></li></ul><h3 id="求LCA"><a href="#求LCA" class="headerlink" title="求LCA"></a>求LCA</h3><ul><li>先让两个点到同一深度，然后一起向上跳，当跳到的点相同时，就找见了LCA。</li></ul><h4 id="倍增法"><a href="#倍增法" class="headerlink" title="倍增法"></a>倍增法</h4><ul><li><p>为了简化问题，我们假设$x,y$在同一高度。</p></li><li><p>令$f[i][j]$表示i向上跳$2^j$步的父亲是啥。</p></li><li><p>将k从$logn$枚举到$0$，若$f[x][k]$与$f[y][k]$不同，则将$x$跳至$f[x][k]$，将$y$跳至$f[y][k]$。</p></li><li><p>最后若$x=y$，则$LCA=x$，否则$LCA=f[x][0]$。</p><p>f[x][i] 表示从x出发向上跳2^i步能到达的点的编号<br>g[x][i] 表示x向上跳2^i步经过的路径中最长边是多少 </p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f[x][<span class="hljs-number">0</span>] = fa[x];</span><br><span class="line">g[x][<span class="hljs-number">0</span>] = x和fa[x]的边的长度 </span><br><span class="line"><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i&lt;=LG[n]; i++)</span><br><span class="line">    <span class="hljs-keyword">for</span> (j=<span class="hljs-number">1</span>; j&lt;=n; j++) </span><br><span class="line">        f[j][i] = f[f[j][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>],</span><br><span class="line">        g[j][i] = max(g[j][i<span class="hljs-number">-1</span>],g[f[j][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>]);</span><br></pre></td></tr></table></figure><p>求出了以任意点为起点，向上跳2的幂次方步能跳到哪里</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">cin</span>&gt;&gt;x&gt;&gt;y; <span class="hljs-comment">//dep表示深度 </span></span><br><span class="line"><span class="hljs-keyword">if</span> (dep[x]&gt;dep[y]) swap(x,y); <span class="hljs-comment">// dep[x] &lt;= dep[y]  因为LCA(x,y) == LCA(y,x)</span></span><br><span class="line"><span class="hljs-comment">//y向上跳dep[y] - dep[x] 次</span></span><br><span class="line"><span class="hljs-keyword">int</span> leng=dep[y]-dep[x];</span><br><span class="line"><span class="hljs-comment">//tot = 0 while (leng) &#123;idx = leng%2; if (idx == 1) y = f[y][tot]; tot+=1; leng/=2;&#125;</span></span><br><span class="line"><span class="hljs-keyword">for</span> (i=LG[n]; i&gt;=<span class="hljs-number">0</span>; i--) <span class="hljs-keyword">if</span> (leng&gt;=(<span class="hljs-number">1</span>&lt;&lt;i)) leng-=(<span class="hljs-number">1</span>&lt;&lt;i), MAX=max(MAX,g[y][i]),y=f[y][i];</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (x==y) &#123;<span class="hljs-built_in">cout</span>&lt;&lt;MAX; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (i=LG[n]; i&gt;=<span class="hljs-number">0</span>; i--)</span><br><span class="line">    <span class="hljs-keyword">if</span> (f[x][i] != f[y][i])  <span class="hljs-comment">//LCA(x,y) == LCA(f[x][i],f[y][i]) </span></span><br><span class="line">        MAX=max(MAX,max(g[x][i],g[i])), x = f[x][i], y = f[y][i];</span><br><span class="line">MAX=max(MAX,max(g[x][<span class="hljs-number">0</span>],g[y][<span class="hljs-number">0</span>]))</span><br><span class="line"><span class="hljs-built_in">cout</span>&lt;&lt;MAX;</span><br></pre></td></tr></table></figure></li></ul><h4 id="链上最大值问题"><a href="#链上最大值问题" class="headerlink" title="链上最大值问题"></a>链上最大值问题</h4><ul><li>给定一棵树，每次询问两个点x,y，求这两个点的路径上最长的边是多少。</li></ul><h5 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h5><ul><li>同样的令f[i][j]表示i向上跳2^j能跳到哪儿。</li><li>也令g[i][j]表示i向上跳2^j的过程中遇到的最长的边是多少。</li><li>现在我们先求出两个点x,y的LCA。</li><li>用倍增的方法求出x到LCA的最长边，y到LCA的最长边就可以了。</li></ul><h4 id="链上和问题"><a href="#链上和问题" class="headerlink" title="链上和问题"></a>链上和问题</h4><ul><li>给定一棵树，每次询问两个点x,y，求这条路径上边权和是多少。</li></ul><h4 id="链上异或和"><a href="#链上异或和" class="headerlink" title="链上异或和"></a>链上异或和</h4><ul><li>给定一棵树，每次询问两个点x,y，求这条路径上边权异或和是多少。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;张浩威老师的图论&quot;&gt;&lt;a href=&quot;#张浩威老师的图论&quot; class=&quot;headerlink&quot; title=&quot;张浩威老师的图论&quot;&gt;&lt;/a&gt;张浩威老师的图论&lt;/h3&gt;
    
    </summary>
    
      <category term="OI" scheme="http://yueyangwu.cn/categories/OI/"/>
    
      <category term="集训" scheme="http://yueyangwu.cn/categories/OI/%E9%9B%86%E8%AE%AD/"/>
    
    
  </entry>
  
  <entry>
    <title> 清北学堂noip2019-DP图论-Day2背包		</title>
    <link href="http://yueyangwu.cn/2019/05/01/e6-b8-85-e5-8c-97-e5-ad-a6-e5-a0-82noip2019-dp-e5-9b-be-e8-ae-ba-day2-e8-83-8c-e5-8c-85/"/>
    <id>http://yueyangwu.cn/2019/05/01/e6-b8-85-e5-8c-97-e5-ad-a6-e5-a0-82noip2019-dp-e5-9b-be-e8-ae-ba-day2-e8-83-8c-e5-8c-85/</id>
    <published>2019-04-30T16:20:32.000Z</published>
    <updated>2019-07-11T17:19:30.601Z</updated>
    
    <content type="html"><![CDATA[<p>A.M.</p><a id="more"></a><hr><h4 id="背包和数位DP"><a href="#背包和数位DP" class="headerlink" title="背包和数位DP"></a>背包和数位DP</h4><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><ul><li>注意：<ol><li>虽然一维空间的 0-1 背包不但省空间而且好写，但这并不意味着你可以忘记 0-1 背包二维的写法，有些题目其实会用到，而且输出方案的时候需要保持数组两维</li><li>0-1 背包问题有两种：第一种是输出容量不超过 V 的最大收益，而第二种则是输出容量恰好为 V 的最大收益，两者的预处理并不相同</li></ol></li></ul><p>Q：如何计算背包的方案总数与最优方案总数？</p><h5 id="方案总数"><a href="#方案总数" class="headerlink" title="方案总数"></a>方案总数</h5><pre><code>for(int i=1;i&lt;=n;i++){    for(int j=0;j&lt;=m;j++){        f[i][j]=f[i-1][j];        if(j-v[i]&gt;=0)            f[i][j]+=f[i-1][j-v[i]];    }}</code></pre><h5 id="最优方案总数"><a href="#最优方案总数" class="headerlink" title="最优方案总数"></a>最优方案总数</h5><p>$f[i][j]$是一个正常01背包，$g[i][j]$表示前i个物品选择j体积的物品的最优方案总数。</p><pre><code>for (int i = 1; i &lt;= n; i++)    for (int j = 1; j &lt;= V; j++) {        f[i][j] = f[i - 1][j];        if (j &gt;= v[i])            f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);    }for (int i = 1; i &lt;= n; i++)    for (int j = 1; j &lt;= V; j++) {        g[i][j] = g[i - 1][j];        if (j &gt;= v[i] &amp;&amp; f[i][j] == f[i - 1][j - v[i]] + w[i])            g[i][j] += g[i - 1][j - v[i]];    }</code></pre><h5 id="例题——Luogu-P1489"><a href="#例题——Luogu-P1489" class="headerlink" title="例题——Luogu P1489"></a>例题——Luogu P1489</h5><ul><li><p>Q1：问一共 n 个人分成两队拔河，要求在保证两队人数的差的绝对值不超过1的情况下，输出两队体重差的绝对值的最小值。</p></li><li><p>这题看起来和背包没啥关系，但是仔细思考，可以发现$f[i][j][k]$表示前i个人里选j个可否组成k，这样问题就变成了01背包变形，第一维可以省去。</p><p>#include&lt;bits/stdc++.h&gt;<br>using namespace std;</p><p>int n,a[209],sum;<br>bool f[209][80009];</p><p>int main(){</p><pre><code>cin&gt;&gt;n;for(int i=1;i&lt;=n;i++){    cin&gt;&gt;a[i];    sum+=a[i];}f[0][0]=1;for(int i=1;i&lt;=n;i++){    for(int j=n/2;j&gt;=1;j--){        for(int k=sum;k&gt;=a[i];k--){            if(f[j][k]||f[j-1][k-a[i]]) f[j][k]=1;        }    }}int ans1,ans2;for(int i=sum/2;i&gt;=0;i--){    if(f[n/2][i]) {ans1=i;break;}}ans2=sum-ans1;if(ans1&gt;ans2) swap(ans1,ans2);cout&lt;&lt;ans1&lt;&lt;&quot; &quot;&lt;&lt;ans2;return 0;</code></pre><p>}</p></li></ul><hr><h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><ul><li>和01背包没啥区别，一个贪心预处理优化： 对于所有 Vi≥Vj，Ci≤Cj 的物品 i，都可以完全扔掉。 对于体积相同的物品只需要留下价值最大的物品。</li><li>对于随机数据，该优化力度很大。</li></ul><hr><h4 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h4><p>多重背包问题，即每样物品 i ，有自己的体积 Vi，价值 Ci，和数量 Ti，数量并不是无限的，求最大价值 - 思路1：直接把其当做01背包，写出代码。</p><pre><code>for(int i=1;i&lt;=n;i++){    for(int j=1;j&lt;=m;j++){        for(int k=1;k&lt;=t[i];k++){            if(j-k*w[i]&gt;=0) f[j]=max(f[j],f[j-k*v[i]]+k*w[i]);        }    }}</code></pre><p>但很明显，这样做复杂度很高。 - 思路2：我们注意到我们只关心最终答案是几，而不关心我放进几个物品，所以当$T_i=3$时，我们可以不必放入3个$(V_i,W_i)$，而可以放入一个$(V_i,W_i)$和一个$(2V_i,2W_i)$，这样仍然可以枚举出放入3个的情况。因此，我们把每个$T_i$都分解为2的幂次，复杂度可以降到$O(n^2logn)$。</p><pre><code>for(int i=1;i&lt;=n;i++){    int tt=t[i];    for(int k=1;k&lt;=tt;k&lt;&lt;=1){        for(int j=v;j&gt;=k*w[i];j--){            f[j]=max(f[j],f[j-k*w[i]]+k*v[i]);            tt-=k;        }    }    if(tt&gt;0){        for(int j=v;j&gt;=tt*w[i];j--){            f[j]=max(f[j],f[j-tt*w[i]]+tt*v[i]);        }    }}</code></pre><hr><h4 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h4><p>每一个物品隶属于一个组，每个组里的物品是互斥的，意味着你在一组物品中只能选择一个物品。</p><pre><code>for (int i = 1; i &lt;= K; i++)        //一共有 K 组    for (int j = V; j &gt;= 0; j--)        for (对于第 i 组内的物品k)            dp[j] = max(dp[j], dp[j - v[k]] + w[k])</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;A.M.&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://yueyangwu.cn/categories/OI/"/>
    
    
  </entry>
  
</feed>
